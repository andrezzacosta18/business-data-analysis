import numpy as np
import pandas as pd
import pyarrow as pa
from .. import config as config
from ..features import Features as Features
from ..features.features import decode_nested_example as decode_nested_example, pandas_types_mapper as pandas_types_mapper
from ..table import Table as Table
from ..utils.py_utils import no_op_if_value_is_null as no_op_if_value_is_null
from _typeshed import Incomplete
from collections.abc import Mapping, MutableMapping
from typing import Callable, Generic, Iterable, TypeVar

T = TypeVar('T')
RowFormat = TypeVar('RowFormat')
ColumnFormat = TypeVar('ColumnFormat')
BatchFormat = TypeVar('BatchFormat')

class BaseArrowExtractor(Generic[RowFormat, ColumnFormat, BatchFormat]):
    """
    Arrow extractor are used to extract data from pyarrow tables.
    It makes it possible to extract rows, columns and batches.
    These three extractions types have to be implemented.
    """
    def extract_row(self, pa_table: pa.Table) -> RowFormat: ...
    def extract_column(self, pa_table: pa.Table) -> ColumnFormat: ...
    def extract_batch(self, pa_table: pa.Table) -> BatchFormat: ...

class SimpleArrowExtractor(BaseArrowExtractor[pa.Table, pa.Array, pa.Table]):
    def extract_row(self, pa_table: pa.Table) -> pa.Table: ...
    def extract_column(self, pa_table: pa.Table) -> pa.Array: ...
    def extract_batch(self, pa_table: pa.Table) -> pa.Table: ...

class PythonArrowExtractor(BaseArrowExtractor[dict, list, dict]):
    def extract_row(self, pa_table: pa.Table) -> dict: ...
    def extract_column(self, pa_table: pa.Table) -> list: ...
    def extract_batch(self, pa_table: pa.Table) -> dict: ...

class NumpyArrowExtractor(BaseArrowExtractor[dict, np.ndarray, dict]):
    np_array_kwargs: Incomplete
    def __init__(self, **np_array_kwargs) -> None: ...
    def extract_row(self, pa_table: pa.Table) -> dict: ...
    def extract_column(self, pa_table: pa.Table) -> np.ndarray: ...
    def extract_batch(self, pa_table: pa.Table) -> dict: ...

class PandasArrowExtractor(BaseArrowExtractor[pd.DataFrame, pd.Series, pd.DataFrame]):
    def extract_row(self, pa_table: pa.Table) -> pd.DataFrame: ...
    def extract_column(self, pa_table: pa.Table) -> pd.Series: ...
    def extract_batch(self, pa_table: pa.Table) -> pd.DataFrame: ...

class PythonFeaturesDecoder:
    features: Incomplete
    def __init__(self, features: Features | None) -> None: ...
    def decode_row(self, row: dict) -> dict: ...
    def decode_column(self, column: list, column_name: str) -> list: ...
    def decode_batch(self, batch: dict) -> dict: ...

class PandasFeaturesDecoder:
    features: Incomplete
    def __init__(self, features: Features | None) -> None: ...
    def decode_row(self, row: pd.DataFrame) -> pd.DataFrame: ...
    def decode_column(self, column: pd.Series, column_name: str) -> pd.Series: ...
    def decode_batch(self, batch: pd.DataFrame) -> pd.DataFrame: ...

class LazyDict(MutableMapping):
    """A dictionary backed by Arrow data. The values are formatted on-the-fly when accessing the dictionary."""
    pa_table: Incomplete
    formatter: Incomplete
    data: Incomplete
    keys_to_format: Incomplete
    def __init__(self, pa_table: pa.Table, formatter: Formatter) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, key): ...
    def __setitem__(self, key, value) -> None: ...
    def __delitem__(self, key) -> None: ...
    def __iter__(self): ...
    def __contains__(self, key) -> bool: ...
    def __or__(self, other): ...
    def __ror__(self, other): ...
    def __ior__(self, other): ...
    def __copy__(self): ...
    def copy(self): ...
    @classmethod
    def fromkeys(cls, iterable, value: Incomplete | None = None) -> None: ...
    def format(self, key) -> None: ...

class LazyRow(LazyDict):
    def format(self, key): ...

class LazyBatch(LazyDict):
    def format(self, key): ...

class Formatter(Generic[RowFormat, ColumnFormat, BatchFormat]):
    """
    A formatter is an object that extracts and formats data from pyarrow tables.
    It defines the formatting for rows, columns and batches.
    """
    simple_arrow_extractor = SimpleArrowExtractor
    python_arrow_extractor = PythonArrowExtractor
    numpy_arrow_extractor = NumpyArrowExtractor
    pandas_arrow_extractor = PandasArrowExtractor
    features: Incomplete
    python_features_decoder: Incomplete
    pandas_features_decoder: Incomplete
    def __init__(self, features: Features | None = None) -> None: ...
    def __call__(self, pa_table: pa.Table, query_type: str) -> RowFormat | ColumnFormat | BatchFormat: ...
    def format_row(self, pa_table: pa.Table) -> RowFormat: ...
    def format_column(self, pa_table: pa.Table) -> ColumnFormat: ...
    def format_batch(self, pa_table: pa.Table) -> BatchFormat: ...

class TensorFormatter(Formatter[RowFormat, ColumnFormat, BatchFormat]):
    def recursive_tensorize(self, data_struct: dict): ...

class ArrowFormatter(Formatter[pa.Table, pa.Array, pa.Table]):
    def format_row(self, pa_table: pa.Table) -> pa.Table: ...
    def format_column(self, pa_table: pa.Table) -> pa.Array: ...
    def format_batch(self, pa_table: pa.Table) -> pa.Table: ...

class PythonFormatter(Formatter[Mapping, list, Mapping]):
    lazy: Incomplete
    def __init__(self, features: Incomplete | None = None, lazy: bool = False) -> None: ...
    def format_row(self, pa_table: pa.Table) -> Mapping: ...
    def format_column(self, pa_table: pa.Table) -> list: ...
    def format_batch(self, pa_table: pa.Table) -> Mapping: ...

class PandasFormatter(Formatter[pd.DataFrame, pd.Series, pd.DataFrame]):
    def format_row(self, pa_table: pa.Table) -> pd.DataFrame: ...
    def format_column(self, pa_table: pa.Table) -> pd.Series: ...
    def format_batch(self, pa_table: pa.Table) -> pd.DataFrame: ...

class CustomFormatter(Formatter[dict, ColumnFormat, dict]):
    """
    A user-defined custom formatter function defined by a ``transform``.
    The transform must take as input a batch of data extracted for an arrow table using the python extractor,
    and return a batch.
    If the output batch is not a dict, then output_all_columns won't work.
    If the ouput batch has several fields, then querying a single column won't work since we don't know which field
    to return.
    """
    transform: Incomplete
    def __init__(self, transform: Callable[[dict], dict], features: Incomplete | None = None, **kwargs) -> None: ...
    def format_row(self, pa_table: pa.Table) -> dict: ...
    def format_column(self, pa_table: pa.Table) -> ColumnFormat: ...
    def format_batch(self, pa_table: pa.Table) -> dict: ...

def key_to_query_type(key: int | slice | range | str | Iterable) -> str: ...
def query_table(table: Table, key: int | slice | range | str | Iterable, indices: Table | None = None) -> pa.Table:
    '''
    Query a Table to extract the subtable that correspond to the given key.

    Args:
        table (``datasets.table.Table``): The input Table to query from
        key (``Union[int, slice, range, str, Iterable]``): The key can be of different types:
            - an integer i: the subtable containing only the i-th row
            - a slice [i:j:k]: the subtable containing the rows that correspond to this slice
            - a range(i, j, k): the subtable containing the rows that correspond to this range
            - a string c: the subtable containing all the rows but only the column c
            - an iterable l: the subtable that is the concatenation of all the i-th rows for all i in the iterable
        indices (Optional ``datasets.table.Table``): If not None, it is used to re-map the given key to the table rows.
            The indices table must contain one column named "indices" of type uint64.
            This is used in case of shuffling or rows selection.


    Returns:
        ``pyarrow.Table``: the result of the query on the input table
    '''
def format_table(table: Table, key: int | slice | range | str | Iterable, formatter: Formatter, format_columns: list | None = None, output_all_columns: bool = False):
    """
    Format a Table depending on the key that was used and a Formatter object.

    Args:
        table (``datasets.table.Table``): The input Table to format
        key (``Union[int, slice, range, str, Iterable]``): Depending on the key that was used, the formatter formats
            the table as either a row, a column or a batch.
        formatter (``datasets.formatting.formatting.Formatter``): Any subclass of a Formatter such as
            PythonFormatter, NumpyFormatter, etc.
        format_columns (:obj:`List[str]`, optional): if not None, it defines the columns that will be formatted using the
            given formatter. Other columns are discarded (unless ``output_all_columns`` is True)
        output_all_columns (:obj:`bool`, defaults to False). If True, the formatted output is completed using the columns
            that are not in the ``format_columns`` list. For these columns, the PythonFormatter is used.


    Returns:
        A row, column or batch formatted object defined by the Formatter:
        - the PythonFormatter returns a dictionary for a row or a batch, and a list for a column.
        - the NumpyFormatter returns a dictionary for a row or a batch, and a np.array for a column.
        - the PandasFormatter returns a pd.DataFrame for a row or a batch, and a pd.Series for a column.
        - the TorchFormatter returns a dictionary for a row or a batch, and a torch.Tensor for a column.
        - the TFFormatter returns a dictionary for a row or a batch, and a tf.Tensor for a column.
    """
