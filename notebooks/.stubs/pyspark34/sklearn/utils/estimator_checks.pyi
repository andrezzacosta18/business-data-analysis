from . import IS_PYPY as IS_PYPY, is_scalar_nan as is_scalar_nan, shuffle as shuffle
from .. import config_context as config_context
from ..base import ClusterMixin as ClusterMixin, RegressorMixin as RegressorMixin, clone as clone, is_classifier as is_classifier, is_outlier_detector as is_outlier_detector, is_regressor as is_regressor
from ..datasets import load_iris as load_iris, make_blobs as make_blobs, make_classification as make_classification, make_multilabel_classification as make_multilabel_classification, make_regression as make_regression
from ..exceptions import DataConversionWarning as DataConversionWarning, NotFittedError as NotFittedError, SkipTestWarning as SkipTestWarning
from ..feature_selection import SelectFromModel as SelectFromModel, SelectKBest as SelectKBest
from ..linear_model import LinearRegression as LinearRegression, LogisticRegression as LogisticRegression, RANSACRegressor as RANSACRegressor, Ridge as Ridge, SGDRegressor as SGDRegressor
from ..metrics import accuracy_score as accuracy_score, adjusted_rand_score as adjusted_rand_score, f1_score as f1_score
from ..metrics.pairwise import linear_kernel as linear_kernel, pairwise_distances as pairwise_distances, rbf_kernel as rbf_kernel
from ..model_selection import ShuffleSplit as ShuffleSplit, train_test_split as train_test_split
from ..pipeline import make_pipeline as make_pipeline
from ..preprocessing import StandardScaler as StandardScaler, scale as scale
from ..random_projection import BaseRandomProjection as BaseRandomProjection
from ..utils._array_api import get_namespace as get_namespace
from ..utils._param_validation import InvalidParameterError as InvalidParameterError, generate_invalid_param_val as generate_invalid_param_val, make_constraint as make_constraint
from ..utils.fixes import parse_version as parse_version, sp_version as sp_version
from ..utils.validation import check_is_fitted as check_is_fitted
from ._param_validation import Interval as Interval
from ._testing import SkipTest as SkipTest, assert_allclose as assert_allclose, assert_allclose_dense_sparse as assert_allclose_dense_sparse, assert_array_almost_equal as assert_array_almost_equal, assert_array_equal as assert_array_equal, assert_array_less as assert_array_less, assert_raise_message as assert_raise_message, create_memmap_backed_data as create_memmap_backed_data, ignore_warnings as ignore_warnings, raises as raises, set_random_state as set_random_state
from .validation import has_fit_parameter as has_fit_parameter
from _typeshed import Incomplete

REGRESSION_DATASET: Incomplete
CROSS_DECOMPOSITION: Incomplete

def check_supervised_y_no_nan(name, estimator_orig) -> None: ...
def parametrize_with_checks(estimators):
    """Pytest specific decorator for parametrizing estimator checks.

    The `id` of each check is set to be a pprint version of the estimator
    and the name of the check with its keyword arguments.
    This allows to use `pytest -k` to specify which tests to run::

        pytest test_check_estimators.py -k check_estimators_fit_returns_self

    Parameters
    ----------
    estimators : list of estimators instances
        Estimators to generated checks for.

        .. versionchanged:: 0.24
           Passing a class was deprecated in version 0.23, and support for
           classes was removed in 0.24. Pass an instance instead.

        .. versionadded:: 0.24

    Returns
    -------
    decorator : `pytest.mark.parametrize`

    See Also
    --------
    check_estimator : Check if estimator adheres to scikit-learn conventions.

    Examples
    --------
    >>> from sklearn.utils.estimator_checks import parametrize_with_checks
    >>> from sklearn.linear_model import LogisticRegression
    >>> from sklearn.tree import DecisionTreeRegressor

    >>> @parametrize_with_checks([LogisticRegression(),
    ...                           DecisionTreeRegressor()])
    ... def test_sklearn_compatible_estimator(estimator, check):
    ...     check(estimator)

    """
def check_estimator(estimator: Incomplete | None = None, generate_only: bool = False):
    """Check if estimator adheres to scikit-learn conventions.

    This function will run an extensive test-suite for input validation,
    shapes, etc, making sure that the estimator complies with `scikit-learn`
    conventions as detailed in :ref:`rolling_your_own_estimator`.
    Additional tests for classifiers, regressors, clustering or transformers
    will be run if the Estimator class inherits from the corresponding mixin
    from sklearn.base.

    Setting `generate_only=True` returns a generator that yields (estimator,
    check) tuples where the check can be called independently from each
    other, i.e. `check(estimator)`. This allows all checks to be run
    independently and report the checks that are failing.

    scikit-learn provides a pytest specific decorator,
    :func:`~sklearn.utils.parametrize_with_checks`, making it easier to test
    multiple estimators.

    Parameters
    ----------
    estimator : estimator object
        Estimator instance to check.

        .. versionadded:: 1.1
           Passing a class was deprecated in version 0.23, and support for
           classes was removed in 0.24.

    generate_only : bool, default=False
        When `False`, checks are evaluated when `check_estimator` is called.
        When `True`, `check_estimator` returns a generator that yields
        (estimator, check) tuples. The check is run by calling
        `check(estimator)`.

        .. versionadded:: 0.22

    Returns
    -------
    checks_generator : generator
        Generator that yields (estimator, check) tuples. Returned when
        `generate_only=True`.

    See Also
    --------
    parametrize_with_checks : Pytest specific decorator for parametrizing estimator
        checks.
    """

class _NotAnArray:
    """An object that is convertible to an array.

    Parameters
    ----------
    data : array-like
        The data.
    """
    data: Incomplete
    def __init__(self, data) -> None: ...
    def __array__(self, dtype: Incomplete | None = None): ...
    def __array_function__(self, func, types, args, kwargs): ...

def check_array_api_input(name, estimator_orig, *, array_namespace, device: Incomplete | None = None, dtype: str = 'float64') -> None:
    """Check that the array_api Array gives the same results as ndarrays."""
def check_estimator_sparse_data(name, estimator_orig) -> None: ...
def check_sample_weights_pandas_series(name, estimator_orig) -> None: ...
def check_sample_weights_not_an_array(name, estimator_orig) -> None: ...
def check_sample_weights_list(name, estimator_orig) -> None: ...
def check_sample_weights_shape(name, estimator_orig) -> None: ...
def check_sample_weights_invariance(name, estimator_orig, kind: str = 'ones') -> None: ...
def check_sample_weights_not_overwritten(name, estimator_orig) -> None: ...
def check_dtype_object(name, estimator_orig) -> None: ...
def check_complex_data(name, estimator_orig) -> None: ...
def check_dict_unchanged(name, estimator_orig) -> None: ...
def check_dont_overwrite_parameters(name, estimator_orig) -> None: ...
def check_fit2d_predict1d(name, estimator_orig) -> None: ...
def check_methods_subset_invariance(name, estimator_orig) -> None: ...
def check_methods_sample_order_invariance(name, estimator_orig) -> None: ...
def check_fit2d_1sample(name, estimator_orig) -> None: ...
def check_fit2d_1feature(name, estimator_orig) -> None: ...
def check_fit1d(name, estimator_orig) -> None: ...
def check_transformer_general(name, transformer, readonly_memmap: bool = False) -> None: ...
def check_transformer_data_not_an_array(name, transformer) -> None: ...
def check_transformers_unfitted(name, transformer) -> None: ...
def check_transformers_unfitted_stateless(name, transformer) -> None:
    """Check that using transform without prior fitting
    doesn't raise a NotFittedError for stateless transformers.
    """
def check_pipeline_consistency(name, estimator_orig) -> None: ...
def check_fit_score_takes_y(name, estimator_orig) -> None: ...
def check_estimators_dtypes(name, estimator_orig) -> None: ...
def check_transformer_preserve_dtypes(name, transformer_orig) -> None: ...
def check_estimators_empty_data_messages(name, estimator_orig) -> None: ...
def check_estimators_nan_inf(name, estimator_orig) -> None: ...
def check_nonsquare_error(name, estimator_orig) -> None:
    """Test that error is thrown when non-square data provided."""
def check_estimators_pickle(name, estimator_orig, readonly_memmap: bool = False) -> None:
    """Test that we can pickle all estimators."""
def check_estimators_partial_fit_n_features(name, estimator_orig) -> None: ...
def check_classifier_multioutput(name, estimator) -> None: ...
def check_regressor_multioutput(name, estimator) -> None: ...
def check_clustering(name, clusterer_orig, readonly_memmap: bool = False) -> None: ...
def check_clusterer_compute_labels_predict(name, clusterer_orig) -> None:
    """Check that predict is invariant of compute_labels."""
def check_classifiers_one_label(name, classifier_orig) -> None: ...
def check_classifiers_one_label_sample_weights(name, classifier_orig) -> None:
    """Check that classifiers accepting sample_weight fit or throws a ValueError with
    an explicit message if the problem is reduced to one class.
    """
def check_classifiers_train(name, classifier_orig, readonly_memmap: bool = False, X_dtype: str = 'float64') -> None: ...
def check_outlier_corruption(num_outliers, expected_outliers, decision) -> None: ...
def check_outliers_train(name, estimator_orig, readonly_memmap: bool = True) -> None: ...
def check_outlier_contamination(name, estimator_orig) -> None: ...
def check_classifiers_multilabel_representation_invariance(name, classifier_orig) -> None: ...
def check_classifiers_multilabel_output_format_predict(name, classifier_orig) -> None:
    """Check the output of the `predict` method for classifiers supporting
    multilabel-indicator targets."""
def check_classifiers_multilabel_output_format_predict_proba(name, classifier_orig) -> None:
    """Check the output of the `predict_proba` method for classifiers supporting
    multilabel-indicator targets."""
def check_classifiers_multilabel_output_format_decision_function(name, classifier_orig) -> None:
    """Check the output of the `decision_function` method for classifiers supporting
    multilabel-indicator targets."""
def check_get_feature_names_out_error(name, estimator_orig) -> None:
    """Check the error raised by get_feature_names_out when called before fit.

    Unfitted estimators with get_feature_names_out should raise a NotFittedError.
    """
def check_estimators_fit_returns_self(name, estimator_orig, readonly_memmap: bool = False) -> None:
    """Check if self is returned when calling fit."""
def check_estimators_unfitted(name, estimator_orig) -> None:
    """Check that predict raises an exception in an unfitted estimator.

    Unfitted estimators should raise a NotFittedError.
    """
def check_supervised_y_2d(name, estimator_orig) -> None: ...
def check_classifiers_predictions(X, y, name, classifier_orig) -> None: ...
def check_classifiers_classes(name, classifier_orig) -> None: ...
def check_regressors_int(name, regressor_orig) -> None: ...
def check_regressors_train(name, regressor_orig, readonly_memmap: bool = False, X_dtype=...) -> None: ...
def check_regressors_no_decision_function(name, regressor_orig) -> None: ...
def check_class_weight_classifiers(name, classifier_orig) -> None: ...
def check_class_weight_balanced_classifiers(name, classifier_orig, X_train, y_train, X_test, y_test, weights) -> None: ...
def check_class_weight_balanced_linear_classifier(name, Classifier) -> None:
    """Test class weights with non-contiguous class labels."""
def check_estimators_overwrite_params(name, estimator_orig) -> None: ...
def check_no_attributes_set_in_init(name, estimator_orig) -> None:
    """Check setting during init."""
def check_sparsify_coefficients(name, estimator_orig) -> None: ...
def check_classifier_data_not_an_array(name, estimator_orig) -> None: ...
def check_regressor_data_not_an_array(name, estimator_orig) -> None: ...
def check_estimators_data_not_an_array(name, estimator_orig, X, y, obj_type) -> None: ...
def check_parameters_default_constructible(name, Estimator): ...
def check_non_transformer_estimators_n_iter(name, estimator_orig) -> None: ...
def check_transformer_n_iter(name, estimator_orig) -> None: ...
def check_get_params_invariance(name, estimator_orig) -> None: ...
def check_set_params(name, estimator_orig) -> None: ...
def check_classifiers_regression_target(name, estimator_orig) -> None: ...
def check_decision_proba_consistency(name, estimator_orig) -> None: ...
def check_outliers_fit_predict(name, estimator_orig) -> None: ...
def check_fit_non_negative(name, estimator_orig) -> None: ...
def check_fit_idempotent(name, estimator_orig) -> None: ...
def check_fit_check_is_fitted(name, estimator_orig) -> None: ...
def check_n_features_in(name, estimator_orig) -> None: ...
def check_requires_y_none(name, estimator_orig) -> None: ...
def check_n_features_in_after_fitting(name, estimator_orig) -> None: ...
def check_estimator_get_tags_default_keys(name, estimator_orig) -> None: ...
def check_dataframe_column_names_consistency(name, estimator_orig) -> None: ...
def check_transformer_get_feature_names_out(name, transformer_orig) -> None: ...
def check_transformer_get_feature_names_out_pandas(name, transformer_orig) -> None: ...
def check_param_validation(name, estimator_orig) -> None: ...
def check_set_output_transform(name, transformer_orig): ...
def check_set_output_transform_pandas(name, transformer_orig) -> None: ...
def check_global_ouptut_transform_pandas(name, transformer_orig) -> None:
    """Check that setting globally the output of a transformer to pandas lead to the
    right results."""
