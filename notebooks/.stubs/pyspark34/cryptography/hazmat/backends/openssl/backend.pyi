import typing
from _typeshed import Incomplete
from cryptography import utils as utils, x509 as x509
from cryptography.exceptions import UnsupportedAlgorithm as UnsupportedAlgorithm
from cryptography.hazmat.backends.openssl import aead as aead
from cryptography.hazmat.backends.openssl.ciphers import _CipherContext
from cryptography.hazmat.backends.openssl.cmac import _CMACContext
from cryptography.hazmat.bindings._rust import openssl as rust_openssl
from cryptography.hazmat.bindings.openssl import binding as binding
from cryptography.hazmat.primitives import hashes as hashes, serialization as serialization
from cryptography.hazmat.primitives._asymmetric import AsymmetricPadding as AsymmetricPadding
from cryptography.hazmat.primitives.asymmetric import dh as dh, dsa as dsa, ec as ec, ed25519 as ed25519, ed448 as ed448, rsa as rsa, x25519 as x25519, x448 as x448
from cryptography.hazmat.primitives.asymmetric.padding import MGF1 as MGF1, OAEP as OAEP, PKCS1v15 as PKCS1v15, PSS as PSS
from cryptography.hazmat.primitives.asymmetric.types import PrivateKeyTypes as PrivateKeyTypes, PublicKeyTypes as PublicKeyTypes
from cryptography.hazmat.primitives.ciphers import BlockCipherAlgorithm as BlockCipherAlgorithm, CipherAlgorithm as CipherAlgorithm
from cryptography.hazmat.primitives.ciphers.algorithms import AES as AES, AES128 as AES128, AES256 as AES256, ARC4 as ARC4, Camellia as Camellia, ChaCha20 as ChaCha20, SM4 as SM4, TripleDES as TripleDES
from cryptography.hazmat.primitives.ciphers.modes import CBC as CBC, CFB as CFB, CFB8 as CFB8, CTR as CTR, ECB as ECB, GCM as GCM, Mode as Mode, OFB as OFB, XTS as XTS
from cryptography.hazmat.primitives.serialization import ssh as ssh
from cryptography.hazmat.primitives.serialization.pkcs12 import PBES as PBES, PKCS12Certificate as PKCS12Certificate, PKCS12KeyAndCertificates as PKCS12KeyAndCertificates, PKCS12PrivateKeyTypes as PKCS12PrivateKeyTypes, _PKCS12CATypes
from typing import NamedTuple

class _MemoryBIO(NamedTuple):
    bio: Incomplete
    char_ptr: Incomplete

class _RC2: ...

class Backend:
    """
    OpenSSL API binding interfaces.
    """
    name: str
    def __init__(self) -> None: ...
    def openssl_assert(self, ok: bool, errors: typing.List[rust_openssl.OpenSSLError] | None = None) -> None: ...
    def openssl_version_text(self) -> str:
        """
        Friendly string name of the loaded OpenSSL library. This is not
        necessarily the same version as it was compiled against.

        Example: OpenSSL 1.1.1d  10 Sep 2019
        """
    def openssl_version_number(self) -> int: ...
    def hash_supported(self, algorithm: hashes.HashAlgorithm) -> bool: ...
    def signature_hash_supported(self, algorithm: hashes.HashAlgorithm) -> bool: ...
    def scrypt_supported(self) -> bool: ...
    def hmac_supported(self, algorithm: hashes.HashAlgorithm) -> bool: ...
    def cipher_supported(self, cipher: CipherAlgorithm, mode: Mode) -> bool: ...
    def register_cipher_adapter(self, cipher_cls, mode_cls, adapter) -> None: ...
    def create_symmetric_encryption_ctx(self, cipher: CipherAlgorithm, mode: Mode) -> _CipherContext: ...
    def create_symmetric_decryption_ctx(self, cipher: CipherAlgorithm, mode: Mode) -> _CipherContext: ...
    def pbkdf2_hmac_supported(self, algorithm: hashes.HashAlgorithm) -> bool: ...
    def generate_rsa_private_key(self, public_exponent: int, key_size: int) -> rsa.RSAPrivateKey: ...
    def generate_rsa_parameters_supported(self, public_exponent: int, key_size: int) -> bool: ...
    def load_rsa_private_numbers(self, numbers: rsa.RSAPrivateNumbers, unsafe_skip_rsa_key_validation: bool) -> rsa.RSAPrivateKey: ...
    def load_rsa_public_numbers(self, numbers: rsa.RSAPublicNumbers) -> rsa.RSAPublicKey: ...
    def rsa_padding_supported(self, padding: AsymmetricPadding) -> bool: ...
    def rsa_encryption_supported(self, padding: AsymmetricPadding) -> bool: ...
    def generate_dsa_parameters(self, key_size: int) -> dsa.DSAParameters: ...
    def generate_dsa_private_key(self, parameters: dsa.DSAParameters) -> dsa.DSAPrivateKey: ...
    def generate_dsa_private_key_and_parameters(self, key_size: int) -> dsa.DSAPrivateKey: ...
    def load_dsa_private_numbers(self, numbers: dsa.DSAPrivateNumbers) -> dsa.DSAPrivateKey: ...
    def load_dsa_public_numbers(self, numbers: dsa.DSAPublicNumbers) -> dsa.DSAPublicKey: ...
    def load_dsa_parameter_numbers(self, numbers: dsa.DSAParameterNumbers) -> dsa.DSAParameters: ...
    def dsa_supported(self) -> bool: ...
    def dsa_hash_supported(self, algorithm: hashes.HashAlgorithm) -> bool: ...
    def cmac_algorithm_supported(self, algorithm) -> bool: ...
    def create_cmac_ctx(self, algorithm: BlockCipherAlgorithm) -> _CMACContext: ...
    def load_pem_private_key(self, data: bytes, password: bytes | None, unsafe_skip_rsa_key_validation: bool) -> PrivateKeyTypes: ...
    def load_pem_public_key(self, data: bytes) -> PublicKeyTypes: ...
    def load_pem_parameters(self, data: bytes) -> dh.DHParameters: ...
    def load_der_private_key(self, data: bytes, password: bytes | None, unsafe_skip_rsa_key_validation: bool) -> PrivateKeyTypes: ...
    def load_der_public_key(self, data: bytes) -> PublicKeyTypes: ...
    def load_der_parameters(self, data: bytes) -> dh.DHParameters: ...
    def elliptic_curve_supported(self, curve: ec.EllipticCurve) -> bool: ...
    def elliptic_curve_signature_algorithm_supported(self, signature_algorithm: ec.EllipticCurveSignatureAlgorithm, curve: ec.EllipticCurve) -> bool: ...
    def generate_elliptic_curve_private_key(self, curve: ec.EllipticCurve) -> ec.EllipticCurvePrivateKey:
        """
        Generate a new private key on the named curve.
        """
    def load_elliptic_curve_private_numbers(self, numbers: ec.EllipticCurvePrivateNumbers) -> ec.EllipticCurvePrivateKey: ...
    def load_elliptic_curve_public_numbers(self, numbers: ec.EllipticCurvePublicNumbers) -> ec.EllipticCurvePublicKey: ...
    def load_elliptic_curve_public_bytes(self, curve: ec.EllipticCurve, point_bytes: bytes) -> ec.EllipticCurvePublicKey: ...
    def derive_elliptic_curve_private_key(self, private_value: int, curve: ec.EllipticCurve) -> ec.EllipticCurvePrivateKey: ...
    def elliptic_curve_exchange_algorithm_supported(self, algorithm: ec.ECDH, curve: ec.EllipticCurve) -> bool: ...
    def dh_supported(self) -> bool: ...
    def generate_dh_parameters(self, generator: int, key_size: int) -> dh.DHParameters: ...
    def generate_dh_private_key(self, parameters: dh.DHParameters) -> dh.DHPrivateKey: ...
    def generate_dh_private_key_and_parameters(self, generator: int, key_size: int) -> dh.DHPrivateKey: ...
    def load_dh_private_numbers(self, numbers: dh.DHPrivateNumbers) -> dh.DHPrivateKey: ...
    def load_dh_public_numbers(self, numbers: dh.DHPublicNumbers) -> dh.DHPublicKey: ...
    def load_dh_parameter_numbers(self, numbers: dh.DHParameterNumbers) -> dh.DHParameters: ...
    def dh_parameters_supported(self, p: int, g: int, q: int | None = None) -> bool: ...
    def dh_x942_serialization_supported(self) -> bool: ...
    def x25519_load_public_bytes(self, data: bytes) -> x25519.X25519PublicKey: ...
    def x25519_load_private_bytes(self, data: bytes) -> x25519.X25519PrivateKey: ...
    def x25519_generate_key(self) -> x25519.X25519PrivateKey: ...
    def x25519_supported(self) -> bool: ...
    def x448_load_public_bytes(self, data: bytes) -> x448.X448PublicKey: ...
    def x448_load_private_bytes(self, data: bytes) -> x448.X448PrivateKey: ...
    def x448_generate_key(self) -> x448.X448PrivateKey: ...
    def x448_supported(self) -> bool: ...
    def ed25519_supported(self) -> bool: ...
    def ed25519_load_public_bytes(self, data: bytes) -> ed25519.Ed25519PublicKey: ...
    def ed25519_load_private_bytes(self, data: bytes) -> ed25519.Ed25519PrivateKey: ...
    def ed25519_generate_key(self) -> ed25519.Ed25519PrivateKey: ...
    def ed448_supported(self) -> bool: ...
    def ed448_load_public_bytes(self, data: bytes) -> ed448.Ed448PublicKey: ...
    def ed448_load_private_bytes(self, data: bytes) -> ed448.Ed448PrivateKey: ...
    def ed448_generate_key(self) -> ed448.Ed448PrivateKey: ...
    def aead_cipher_supported(self, cipher) -> bool: ...
    def load_key_and_certificates_from_pkcs12(self, data: bytes, password: bytes | None) -> typing.Tuple[PrivateKeyTypes | None, x509.Certificate | None, typing.List[x509.Certificate]]: ...
    def load_pkcs12(self, data: bytes, password: bytes | None) -> PKCS12KeyAndCertificates: ...
    def serialize_key_and_certificates_to_pkcs12(self, name: bytes | None, key: PKCS12PrivateKeyTypes | None, cert: x509.Certificate | None, cas: typing.List[_PKCS12CATypes] | None, encryption_algorithm: serialization.KeySerializationEncryption) -> bytes: ...
    def poly1305_supported(self) -> bool: ...
    def pkcs7_supported(self) -> bool: ...
    def load_pem_pkcs7_certificates(self, data: bytes) -> typing.List[x509.Certificate]: ...
    def load_der_pkcs7_certificates(self, data: bytes) -> typing.List[x509.Certificate]: ...

class GetCipherByName:
    def __init__(self, fmt: str) -> None: ...
    def __call__(self, backend: Backend, cipher: CipherAlgorithm, mode: Mode): ...

backend: Incomplete
