from _typeshed import Incomplete
from enum import Enum
from mypy import checker as checker, errorcodes as errorcodes
from mypy.messages import MessageBuilder as MessageBuilder
from mypy.nodes import AssertStmt as AssertStmt, AssignmentExpr as AssignmentExpr, AssignmentStmt as AssignmentStmt, BreakStmt as BreakStmt, ClassDef as ClassDef, Context as Context, ContinueStmt as ContinueStmt, DictionaryComprehension as DictionaryComprehension, Expression as Expression, ExpressionStmt as ExpressionStmt, ForStmt as ForStmt, FuncDef as FuncDef, FuncItem as FuncItem, GeneratorExpr as GeneratorExpr, GlobalDecl as GlobalDecl, IfStmt as IfStmt, Import as Import, ImportFrom as ImportFrom, LambdaExpr as LambdaExpr, ListExpr as ListExpr, Lvalue as Lvalue, MatchStmt as MatchStmt, MypyFile as MypyFile, NameExpr as NameExpr, NonlocalDecl as NonlocalDecl, RaiseStmt as RaiseStmt, ReturnStmt as ReturnStmt, StarExpr as StarExpr, SymbolTable as SymbolTable, TryStmt as TryStmt, TupleExpr as TupleExpr, WhileStmt as WhileStmt, WithStmt as WithStmt, implicit_module_attrs as implicit_module_attrs
from mypy.options import Options as Options
from mypy.patterns import AsPattern as AsPattern, StarredPattern as StarredPattern
from mypy.reachability import ALWAYS_TRUE as ALWAYS_TRUE, infer_pattern_value as infer_pattern_value
from mypy.traverser import ExtendedTraverserVisitor as ExtendedTraverserVisitor
from mypy.types import Type as Type, UninhabitedType as UninhabitedType

class BranchState:
    """BranchState contains information about variable definition at the end of a branching statement.
    `if` and `match` are examples of branching statements.

    `may_be_defined` contains variables that were defined in only some branches.
    `must_be_defined` contains variables that were defined in all branches.
    """
    may_be_defined: Incomplete
    must_be_defined: Incomplete
    skipped: Incomplete
    def __init__(self, must_be_defined: set[str] | None = None, may_be_defined: set[str] | None = None, skipped: bool = False) -> None: ...
    def copy(self) -> BranchState: ...

class BranchStatement:
    initial_state: Incomplete
    branches: Incomplete
    def __init__(self, initial_state: BranchState | None = None) -> None: ...
    def copy(self) -> BranchStatement: ...
    def next_branch(self) -> None: ...
    def record_definition(self, name: str) -> None: ...
    def delete_var(self, name: str) -> None: ...
    def record_nested_branch(self, state: BranchState) -> None: ...
    def skip_branch(self) -> None: ...
    def is_possibly_undefined(self, name: str) -> bool: ...
    def is_undefined(self, name: str) -> bool: ...
    def is_defined_in_a_branch(self, name: str) -> bool: ...
    def done(self) -> BranchState: ...

class ScopeType(Enum):
    Global: int
    Class: int
    Func: int
    Generator: int

class Scope:
    branch_stmts: Incomplete
    scope_type: Incomplete
    undefined_refs: Incomplete
    def __init__(self, stmts: list[BranchStatement], scope_type: ScopeType) -> None: ...
    def copy(self) -> Scope: ...
    def record_undefined_ref(self, o: NameExpr) -> None: ...
    def pop_undefined_ref(self, name: str) -> set[NameExpr]: ...

class DefinedVariableTracker:
    """DefinedVariableTracker manages the state and scope for the UndefinedVariablesVisitor."""
    scopes: Incomplete
    disable_branch_skip: bool
    def __init__(self) -> None: ...
    def copy(self) -> DefinedVariableTracker: ...
    def enter_scope(self, scope_type: ScopeType) -> None: ...
    def exit_scope(self) -> None: ...
    def in_scope(self, scope_type: ScopeType) -> bool: ...
    def start_branch_statement(self) -> None: ...
    def next_branch(self) -> None: ...
    def end_branch_statement(self) -> None: ...
    def skip_branch(self) -> None: ...
    def record_definition(self, name: str) -> None: ...
    def delete_var(self, name: str) -> None: ...
    def record_undefined_ref(self, o: NameExpr) -> None:
        """Records an undefined reference. These can later be retrieved via `pop_undefined_ref`."""
    def pop_undefined_ref(self, name: str) -> set[NameExpr]:
        """If name has previously been reported as undefined, the NameExpr that was called will be returned."""
    def is_possibly_undefined(self, name: str) -> bool: ...
    def is_defined_in_different_branch(self, name: str) -> bool:
        """This will return true if a variable is defined in a branch that's not the current branch."""
    def is_undefined(self, name: str) -> bool: ...

class Loop:
    has_break: bool
    def __init__(self) -> None: ...

class PossiblyUndefinedVariableVisitor(ExtendedTraverserVisitor):
    '''Detects the following cases:
    - A variable that\'s defined only part of the time.
    - If a variable is used before definition

    An example of a partial definition:
    if foo():
        x = 1
    print(x)  # Error: "x" may be undefined.

    Example of a used before definition:
    x = y
    y: int = 2

    Note that this code does not detect variables not defined in any of the branches -- that is
    handled by the semantic analyzer.
    '''
    msg: Incomplete
    type_map: Incomplete
    options: Incomplete
    builtins: Incomplete
    loops: Incomplete
    try_depth: int
    tracker: Incomplete
    def __init__(self, msg: MessageBuilder, type_map: dict[Expression, Type], options: Options, names: SymbolTable) -> None: ...
    def var_used_before_def(self, name: str, context: Context) -> None: ...
    def variable_may_be_undefined(self, name: str, context: Context) -> None: ...
    def process_definition(self, name: str) -> None: ...
    def visit_global_decl(self, o: GlobalDecl) -> None: ...
    def visit_nonlocal_decl(self, o: NonlocalDecl) -> None: ...
    def process_lvalue(self, lvalue: Lvalue | None) -> None: ...
    def visit_assignment_stmt(self, o: AssignmentStmt) -> None: ...
    def visit_assignment_expr(self, o: AssignmentExpr) -> None: ...
    def visit_if_stmt(self, o: IfStmt) -> None: ...
    def visit_match_stmt(self, o: MatchStmt) -> None: ...
    def visit_func_def(self, o: FuncDef) -> None: ...
    def visit_func(self, o: FuncItem) -> None: ...
    def visit_generator_expr(self, o: GeneratorExpr) -> None: ...
    def visit_dictionary_comprehension(self, o: DictionaryComprehension) -> None: ...
    def visit_for_stmt(self, o: ForStmt) -> None: ...
    def visit_return_stmt(self, o: ReturnStmt) -> None: ...
    def visit_lambda_expr(self, o: LambdaExpr) -> None: ...
    def visit_assert_stmt(self, o: AssertStmt) -> None: ...
    def visit_raise_stmt(self, o: RaiseStmt) -> None: ...
    def visit_continue_stmt(self, o: ContinueStmt) -> None: ...
    def visit_break_stmt(self, o: BreakStmt) -> None: ...
    def visit_expression_stmt(self, o: ExpressionStmt) -> None: ...
    def visit_try_stmt(self, o: TryStmt) -> None:
        """
        Note that finding undefined vars in `finally` requires different handling from
        the rest of the code. In particular, we want to disallow skipping branches due to jump
        statements in except/else clauses for finally but not for other cases. Imagine a case like:
        def f() -> int:
            try:
                x = 1
            except:
                # This jump statement needs to be handled differently depending on whether or
                # not we're trying to process `finally` or not.
                return 0
            finally:
                # `x` may be undefined here.
                pass
            # `x` is always defined here.
            return x
        """
    def process_try_stmt(self, o: TryStmt) -> None:
        """
        Processes try statement decomposing it into the following:
        if ...:
            body
            else_body
        elif ...:
            except 1
        elif ...:
            except 2
        else:
            except n
        finally
        """
    def visit_while_stmt(self, o: WhileStmt) -> None: ...
    def visit_as_pattern(self, o: AsPattern) -> None: ...
    def visit_starred_pattern(self, o: StarredPattern) -> None: ...
    def visit_name_expr(self, o: NameExpr) -> None: ...
    def visit_with_stmt(self, o: WithStmt) -> None: ...
    def visit_class_def(self, o: ClassDef) -> None: ...
    def visit_import(self, o: Import) -> None: ...
    def visit_import_from(self, o: ImportFrom) -> None: ...
