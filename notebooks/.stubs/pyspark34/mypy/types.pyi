import abc
import mypy.nodes
from _typeshed import Incomplete
from abc import abstractmethod
from mypy.bogus_type import Bogus as Bogus
from mypy.expandtype import ExpandTypeVisitor as ExpandTypeVisitor
from mypy.nodes import ARG_POS as ARG_POS, ARG_STAR as ARG_STAR, ARG_STAR2 as ARG_STAR2, ArgKind as ArgKind, FakeInfo as FakeInfo, FuncDef as FuncDef, INVARIANT as INVARIANT, SymbolNode as SymbolNode
from mypy.options import Options as Options
from mypy.state import state as state
from mypy.type_visitor import BoolTypeQuery as BoolTypeQuery, SyntheticTypeVisitor as SyntheticTypeVisitor, TypeTranslator as TypeTranslator, TypeVisitor as TypeVisitor
from mypy.typetraverser import TypeTraverserVisitor as TypeTraverserVisitor
from mypy.util import IdMapper as IdMapper
from typing import Any, ClassVar, Iterable, NamedTuple, Sequence, TypeVar
from typing_extensions import Final, Self, TypeAlias as _TypeAlias, TypeGuard, overload

T = TypeVar('T')
JsonDict: _TypeAlias
LiteralValue: _TypeAlias
TYPED_NAMEDTUPLE_NAMES: Final[Incomplete]
TPDICT_NAMES: Final[Incomplete]
TPDICT_FB_NAMES: Final[Incomplete]
PROTOCOL_NAMES: Final[Incomplete]
TYPE_ALIAS_NAMES: Final[Incomplete]
FINAL_TYPE_NAMES: Final[Incomplete]
FINAL_DECORATOR_NAMES: Final[Incomplete]
LITERAL_TYPE_NAMES: Final[Incomplete]
ANNOTATED_TYPE_NAMES: Final[Incomplete]
TUPLE_LIKE_INSTANCE_NAMES: Final[Incomplete]
REVEAL_TYPE_NAMES: Final[Incomplete]
ASSERT_TYPE_NAMES: Final[Incomplete]
OVERLOAD_NAMES: Final[Incomplete]
ENUM_REMOVED_PROPS: Final[Incomplete]
NEVER_NAMES: Final[Incomplete]
MYPYC_NATIVE_INT_NAMES: Final[Incomplete]
DATACLASS_TRANSFORM_NAMES: Final[Incomplete]
OVERRIDE_DECORATOR_NAMES: Final[Incomplete]

class TypeOfAny:
    """
    This class describes different types of Any. Each 'Any' can be of only one type at a time.
    """
    unannotated: Final[int]
    explicit: Final[int]
    from_unimported_type: Final[int]
    from_omitted_generics: Final[int]
    from_error: Final[int]
    special_form: Final[int]
    from_another_any: Final[int]
    implementation_artifact: Final[int]
    suggestion_engine: Final[int]

def deserialize_type(data: JsonDict | str) -> Type: ...

class Type(mypy.nodes.Context):
    """Abstract base class for all types."""
    def __init__(self, line: int = -1, column: int = -1) -> None: ...
    @property
    def can_be_true(self) -> bool: ...
    @can_be_true.setter
    def can_be_true(self, v: bool) -> None: ...
    @property
    def can_be_false(self) -> bool: ...
    @can_be_false.setter
    def can_be_false(self, v: bool) -> None: ...
    def can_be_true_default(self) -> bool: ...
    def can_be_false_default(self) -> bool: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def str_with_options(self, options: Options) -> str: ...
    def serialize(self) -> JsonDict | str: ...
    @classmethod
    def deserialize(cls, data: JsonDict) -> Type: ...
    def is_singleton_type(self) -> bool: ...

class TypeAliasType(Type):
    """A type alias to another type.

    To support recursive type aliases we don't immediately expand a type alias
    during semantic analysis, but create an instance of this type that records the target alias
    definition node (mypy.nodes.TypeAlias) and type arguments (for generic aliases).

    This is very similar to how TypeInfo vs Instance interact, where a recursive class-based
    structure like
        class Node:
            value: int
            children: List[Node]
    can be represented in a tree-like manner.
    """
    alias: Incomplete
    args: Incomplete
    type_ref: Incomplete
    def __init__(self, alias: mypy.nodes.TypeAlias | None, args: list[Type], line: int = -1, column: int = -1) -> None: ...
    def expand_all_if_possible(self, nothing_args: bool = False) -> ProperType | None:
        """Attempt a full expansion of the type alias (including nested aliases).

        If the expansion is not possible, i.e. the alias is (mutually-)recursive,
        return None. If nothing_args is True, replace all type arguments with an
        UninhabitedType() (used to detect recursively defined aliases).
        """
    @property
    def is_recursive(self) -> bool:
        """Whether this type alias is recursive.

        Note this doesn't check generic alias arguments, but only if this alias
        *definition* is recursive. The property value thus can be cached on the
        underlying TypeAlias node. If you want to include all nested types, use
        has_recursive_types() function.
        """
    def can_be_true_default(self) -> bool: ...
    def can_be_false_default(self) -> bool: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def serialize(self) -> JsonDict: ...
    @classmethod
    def deserialize(cls, data: JsonDict) -> TypeAliasType: ...
    def copy_modified(self, *, args: list[Type] | None = None) -> TypeAliasType: ...

class TypeGuardedType(Type):
    """Only used by find_isinstance_check() etc."""
    type_guard: Incomplete
    def __init__(self, type_guard: Type) -> None: ...

class RequiredType(Type):
    """Required[T] or NotRequired[T]. Only usable at top-level of a TypedDict definition."""
    item: Incomplete
    required: Incomplete
    def __init__(self, item: Type, *, required: bool) -> None: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...

class ProperType(Type):
    """Not a type alias.

    Every type except TypeAliasType must inherit from this type.
    """

class TypeVarId:
    raw_id: int
    meta_level: int
    next_raw_id: ClassVar[int]
    namespace: str
    def __init__(self, raw_id: int, meta_level: int = 0, *, namespace: str = '') -> None: ...
    @staticmethod
    def new(meta_level: int) -> TypeVarId: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def is_meta_var(self) -> bool: ...

class TypeVarLikeType(ProperType):
    name: str
    fullname: str
    id: TypeVarId
    upper_bound: Type
    default: Type
    def __init__(self, name: str, fullname: str, id: TypeVarId | int, upper_bound: Type, default: Type, line: int = -1, column: int = -1) -> None: ...
    def serialize(self) -> JsonDict: ...
    @classmethod
    def deserialize(cls, data: JsonDict) -> TypeVarLikeType: ...
    def copy_modified(self, *, id: TypeVarId, **kwargs: Any) -> Self: ...
    @classmethod
    def new_unification_variable(cls, old: Self) -> Self: ...
    def has_default(self) -> bool: ...

class TypeVarType(TypeVarLikeType):
    """Type that refers to a type variable."""
    values: list[Type]
    variance: int
    def __init__(self, name: str, fullname: str, id: TypeVarId | int, values: list[Type], upper_bound: Type, default: Type, variance: int = ..., line: int = -1, column: int = -1) -> None: ...
    def copy_modified(self, *, values: Bogus[list[Type]] = ..., upper_bound: Bogus[Type] = ..., default: Bogus[Type] = ..., id: Bogus[TypeVarId | int] = ..., line: int = ..., column: int = ..., **kwargs: Any) -> TypeVarType: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def serialize(self) -> JsonDict: ...
    @classmethod
    def deserialize(cls, data: JsonDict) -> TypeVarType: ...

class ParamSpecFlavor:
    BARE: Final[int]
    ARGS: Final[int]
    KWARGS: Final[int]

class ParamSpecType(TypeVarLikeType):
    """Type that refers to a ParamSpec.

    A ParamSpec is a type variable that represents the parameter
    types, names and kinds of a callable (i.e., the signature without
    the return type).

    This can be one of these forms
     * P (ParamSpecFlavor.BARE)
     * P.args (ParamSpecFlavor.ARGS)
     * P.kwargs (ParamSpecFLavor.KWARGS)

    The upper_bound is really used as a fallback type -- it's shared
    with TypeVarType for simplicity. It can't be specified by the user
    and the value is directly derived from the flavor (currently
    always just 'object').
    """
    flavor: int
    prefix: Parameters
    def __init__(self, name: str, fullname: str, id: TypeVarId | int, flavor: int, upper_bound: Type, default: Type, *, line: int = -1, column: int = -1, prefix: Parameters | None = None) -> None: ...
    def with_flavor(self, flavor: int) -> ParamSpecType: ...
    def copy_modified(self, *, id: Bogus[TypeVarId | int] = ..., flavor: int = ..., prefix: Bogus[Parameters] = ..., default: Bogus[Type] = ..., **kwargs: Any) -> ParamSpecType: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def name_with_suffix(self) -> str: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def serialize(self) -> JsonDict: ...
    @classmethod
    def deserialize(cls, data: JsonDict) -> ParamSpecType: ...

class TypeVarTupleType(TypeVarLikeType):
    """Type that refers to a TypeVarTuple.

    See PEP646 for more information.
    """
    tuple_fallback: Incomplete
    def __init__(self, name: str, fullname: str, id: TypeVarId | int, upper_bound: Type, tuple_fallback: Instance, default: Type, *, line: int = -1, column: int = -1) -> None: ...
    def serialize(self) -> JsonDict: ...
    @classmethod
    def deserialize(cls, data: JsonDict) -> TypeVarTupleType: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def copy_modified(self, *, id: Bogus[TypeVarId | int] = ..., upper_bound: Bogus[Type] = ..., default: Bogus[Type] = ..., **kwargs: Any) -> TypeVarTupleType: ...

class UnboundType(ProperType):
    """Instance type that has not been bound during semantic analysis."""
    name: Incomplete
    args: Incomplete
    optional: Incomplete
    empty_tuple_index: Incomplete
    original_str_expr: Incomplete
    original_str_fallback: Incomplete
    def __init__(self, name: str | None, args: Sequence[Type] | None = None, line: int = -1, column: int = -1, optional: bool = False, empty_tuple_index: bool = False, original_str_expr: str | None = None, original_str_fallback: str | None = None) -> None: ...
    def copy_modified(self, args: Bogus[Sequence[Type] | None] = ...) -> UnboundType: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def serialize(self) -> JsonDict: ...
    @classmethod
    def deserialize(cls, data: JsonDict) -> UnboundType: ...

class CallableArgument(ProperType):
    """Represents a Arg(type, 'name') inside a Callable's type list.

    Note that this is a synthetic type for helping parse ASTs, not a real type.
    """
    typ: Type
    name: str | None
    constructor: str | None
    def __init__(self, typ: Type, name: str | None, constructor: str | None, line: int = -1, column: int = -1) -> None: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def serialize(self) -> JsonDict: ...

class TypeList(ProperType):
    """Information about argument types and names [...].

    This is used for the arguments of a Callable type, i.e. for
    [arg, ...] in Callable[[arg, ...], ret]. This is not a real type
    but a syntactic AST construct. UnboundTypes can also have TypeList
    types before they are processed into Callable types.
    """
    items: list[Type]
    def __init__(self, items: list[Type], line: int = -1, column: int = -1) -> None: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def serialize(self) -> JsonDict: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...

class UnpackType(ProperType):
    """Type operator Unpack from PEP646. Can be either with Unpack[]
    or unpacking * syntax.

    The inner type should be either a TypeVarTuple, a constant size
    tuple, or a variable length tuple, or a union of one of those.
    """
    type: Incomplete
    def __init__(self, typ: Type, line: int = -1, column: int = -1) -> None: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def serialize(self) -> JsonDict: ...
    @classmethod
    def deserialize(cls, data: JsonDict) -> UnpackType: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...

class AnyType(ProperType):
    """The type 'Any'."""
    type_of_any: Incomplete
    source_any: Incomplete
    missing_import_name: Incomplete
    def __init__(self, type_of_any: int, source_any: AnyType | None = None, missing_import_name: str | None = None, line: int = -1, column: int = -1) -> None: ...
    @property
    def is_from_error(self) -> bool: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def copy_modified(self, type_of_any: int = ..., original_any: Bogus[AnyType | None] = ...) -> AnyType: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def serialize(self) -> JsonDict: ...
    @classmethod
    def deserialize(cls, data: JsonDict) -> AnyType: ...

class UninhabitedType(ProperType):
    """This type has no members.

    This type is the bottom type.
    With strict Optional checking, it is the only common subtype between all
    other types, which allows `meet` to be well defined.  Without strict
    Optional checking, NoneType fills this role.

    In general, for any type T:
        join(UninhabitedType, T) = T
        meet(UninhabitedType, T) = UninhabitedType
        is_subtype(UninhabitedType, T) = True
    """
    is_noreturn: bool
    ambiguous: bool
    def __init__(self, is_noreturn: bool = False, line: int = -1, column: int = -1) -> None: ...
    def can_be_true_default(self) -> bool: ...
    def can_be_false_default(self) -> bool: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def serialize(self) -> JsonDict: ...
    @classmethod
    def deserialize(cls, data: JsonDict) -> UninhabitedType: ...

class NoneType(ProperType):
    """The type of 'None'.

    This type can be written by users as 'None'.
    """
    def __init__(self, line: int = -1, column: int = -1) -> None: ...
    def can_be_true_default(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def serialize(self) -> JsonDict: ...
    @classmethod
    def deserialize(cls, data: JsonDict) -> None: ...
    def is_singleton_type(self) -> bool: ...
NoneTyp = NoneType

class ErasedType(ProperType):
    """Placeholder for an erased type.

    This is used during type inference. This has the special property that
    it is ignored during type inference.
    """
    def accept(self, visitor: TypeVisitor[T]) -> T: ...

class DeletedType(ProperType):
    """Type of deleted variables.

    These can be used as lvalues but not rvalues.
    """
    source: str | None
    def __init__(self, source: str | None = None, line: int = -1, column: int = -1) -> None: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def serialize(self) -> JsonDict: ...
    @classmethod
    def deserialize(cls, data: JsonDict) -> DeletedType: ...

NOT_READY: Final[Incomplete]

class ExtraAttrs:
    """Summary of module attributes and types.

    This is used for instances of types.ModuleType, because they can have different
    attributes per instance, and for type narrowing with hasattr() checks.
    """
    attrs: Incomplete
    immutable: Incomplete
    mod_name: Incomplete
    def __init__(self, attrs: dict[str, Type], immutable: set[str] | None = None, mod_name: str | None = None) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def copy(self) -> ExtraAttrs: ...

class Instance(ProperType):
    '''An instance type of form C[T1, ..., Tn].

    The list of type variables may be empty.

    Several types have fallbacks to `Instance`, because in Python everything is an object
    and this concept is impossible to express without intersection types. We therefore use
    fallbacks for all "non-special" (like UninhabitedType, ErasedType etc) types.
    '''
    type: Incomplete
    args: Incomplete
    type_ref: Incomplete
    invalid: bool
    last_known_value: Incomplete
    extra_attrs: Incomplete
    def __init__(self, typ: mypy.nodes.TypeInfo, args: Sequence[Type], line: int = -1, column: int = -1, *, last_known_value: LiteralType | None = None, extra_attrs: ExtraAttrs | None = None) -> None: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def serialize(self) -> JsonDict | str: ...
    @classmethod
    def deserialize(cls, data: JsonDict | str) -> Instance: ...
    def copy_modified(self, *, args: Bogus[list[Type]] = ..., last_known_value: Bogus[LiteralType | None] = ...) -> Instance: ...
    def copy_with_extra_attr(self, name: str, typ: Type) -> Instance: ...
    def is_singleton_type(self) -> bool: ...
    def get_enum_values(self) -> list[str]:
        """Return the list of values for an Enum."""

class FunctionLike(ProperType, metaclass=abc.ABCMeta):
    """Abstract base class for function types."""
    fallback: Instance
    def __init__(self, line: int = -1, column: int = -1) -> None: ...
    @abstractmethod
    def is_type_obj(self) -> bool: ...
    @abstractmethod
    def type_object(self) -> mypy.nodes.TypeInfo: ...
    @property
    @abstractmethod
    def items(self) -> list[CallableType]: ...
    @abstractmethod
    def with_name(self, name: str) -> FunctionLike: ...
    @abstractmethod
    def get_name(self) -> str | None: ...

class FormalArgument(NamedTuple):
    name: str | None
    pos: int | None
    typ: Type
    required: bool

class Parameters(ProperType):
    """Type that represents the parameters to a function.

    Used for ParamSpec analysis."""
    arg_types: Incomplete
    arg_kinds: Incomplete
    arg_names: Incomplete
    min_args: Incomplete
    is_ellipsis_args: Incomplete
    variables: Incomplete
    def __init__(self, arg_types: Sequence[Type], arg_kinds: list[ArgKind], arg_names: Sequence[str | None], *, variables: Sequence[TypeVarLikeType] | None = None, is_ellipsis_args: bool = False, line: int = -1, column: int = -1) -> None: ...
    def copy_modified(self, arg_types: Bogus[Sequence[Type]] = ..., arg_kinds: Bogus[list[ArgKind]] = ..., arg_names: Bogus[Sequence[str | None]] = ..., *, variables: Bogus[Sequence[TypeVarLikeType]] = ..., is_ellipsis_args: Bogus[bool] = ...) -> Parameters: ...
    def var_arg(self) -> FormalArgument | None:
        """The formal argument for *args."""
    def kw_arg(self) -> FormalArgument | None:
        """The formal argument for **kwargs."""
    def formal_arguments(self, include_star_args: bool = False) -> list[FormalArgument]:
        """Yields the formal arguments corresponding to this callable, ignoring *arg and **kwargs.

        To handle *args and **kwargs, use the 'callable.var_args' and 'callable.kw_args' fields,
        if they are not None.

        If you really want to include star args in the yielded output, set the
        'include_star_args' parameter to 'True'."""
    def argument_by_name(self, name: str | None) -> FormalArgument | None: ...
    def argument_by_position(self, position: int | None) -> FormalArgument | None: ...
    def try_synthesizing_arg_from_kwarg(self, name: str | None) -> FormalArgument | None: ...
    def try_synthesizing_arg_from_vararg(self, position: int | None) -> FormalArgument | None: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def serialize(self) -> JsonDict: ...
    @classmethod
    def deserialize(cls, data: JsonDict) -> Parameters: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
CT = TypeVar('CT', bound='CallableType')

class CallableType(FunctionLike):
    """Type of a non-overloaded callable object (such as function)."""
    arg_types: Incomplete
    arg_kinds: Incomplete
    arg_names: Incomplete
    min_args: Incomplete
    ret_type: Incomplete
    fallback: Incomplete
    name: Incomplete
    definition: Incomplete
    variables: Incomplete
    is_ellipsis_args: Incomplete
    implicit: Incomplete
    special_sig: Incomplete
    from_type_type: Incomplete
    from_concatenate: Incomplete
    bound_args: Incomplete
    def_extras: Incomplete
    type_guard: Incomplete
    unpack_kwargs: Incomplete
    def __init__(self, arg_types: Sequence[Type], arg_kinds: list[ArgKind], arg_names: Sequence[str | None], ret_type: Type, fallback: Instance, name: str | None = None, definition: SymbolNode | None = None, variables: Sequence[TypeVarLikeType] | None = None, line: int = -1, column: int = -1, is_ellipsis_args: bool = False, implicit: bool = False, special_sig: str | None = None, from_type_type: bool = False, bound_args: Sequence[Type | None] = (), def_extras: dict[str, Any] | None = None, type_guard: Type | None = None, from_concatenate: bool = False, unpack_kwargs: bool = False) -> None: ...
    def copy_modified(self, arg_types: Bogus[Sequence[Type]] = ..., arg_kinds: Bogus[list[ArgKind]] = ..., arg_names: Bogus[Sequence[str | None]] = ..., ret_type: Bogus[Type] = ..., fallback: Bogus[Instance] = ..., name: Bogus[str | None] = ..., definition: Bogus[SymbolNode] = ..., variables: Bogus[Sequence[TypeVarLikeType]] = ..., line: int = ..., column: int = ..., is_ellipsis_args: Bogus[bool] = ..., implicit: Bogus[bool] = ..., special_sig: Bogus[str | None] = ..., from_type_type: Bogus[bool] = ..., bound_args: Bogus[list[Type | None]] = ..., def_extras: Bogus[dict[str, Any]] = ..., type_guard: Bogus[Type | None] = ..., from_concatenate: Bogus[bool] = ..., unpack_kwargs: Bogus[bool] = ...) -> CT: ...
    def var_arg(self) -> FormalArgument | None:
        """The formal argument for *args."""
    def kw_arg(self) -> FormalArgument | None:
        """The formal argument for **kwargs."""
    @property
    def is_var_arg(self) -> bool:
        """Does this callable have a *args argument?"""
    @property
    def is_kw_arg(self) -> bool:
        """Does this callable have a **kwargs argument?"""
    def is_type_obj(self) -> bool: ...
    def type_object(self) -> mypy.nodes.TypeInfo: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def with_name(self, name: str) -> CallableType:
        """Return a copy of this type with the specified name."""
    def get_name(self) -> str | None: ...
    def max_possible_positional_args(self) -> int:
        """Returns maximum number of positional arguments this method could possibly accept.

        This takes into account *arg and **kwargs but excludes keyword-only args."""
    def formal_arguments(self, include_star_args: bool = False) -> list[FormalArgument]:
        """Return a list of the formal arguments of this callable, ignoring *arg and **kwargs.

        To handle *args and **kwargs, use the 'callable.var_args' and 'callable.kw_args' fields,
        if they are not None.

        If you really want to include star args in the yielded output, set the
        'include_star_args' parameter to 'True'."""
    def argument_by_name(self, name: str | None) -> FormalArgument | None: ...
    def argument_by_position(self, position: int | None) -> FormalArgument | None: ...
    def try_synthesizing_arg_from_kwarg(self, name: str | None) -> FormalArgument | None: ...
    def try_synthesizing_arg_from_vararg(self, position: int | None) -> FormalArgument | None: ...
    @property
    def items(self) -> list[CallableType]: ...
    def is_generic(self) -> bool: ...
    def type_var_ids(self) -> list[TypeVarId]: ...
    def param_spec(self) -> ParamSpecType | None:
        """Return ParamSpec if callable can be called with one.

        A Callable accepting ParamSpec P args (*args, **kwargs) must have the
        two final parameters like this: *args: P.args, **kwargs: P.kwargs.
        """
    def expand_param_spec(self, c: CallableType | Parameters, no_prefix: bool = False) -> CallableType: ...
    def with_unpacked_kwargs(self) -> NormalizedCallableType: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def serialize(self) -> JsonDict: ...
    @classmethod
    def deserialize(cls, data: JsonDict) -> CallableType: ...

NormalizedCallableType: Incomplete

class Overloaded(FunctionLike):
    """Overloaded function type T1, ... Tn, where each Ti is CallableType.

    The variant to call is chosen based on static argument
    types. Overloaded function types can only be defined in stub
    files, and thus there is no explicit runtime dispatch
    implementation.
    """
    fallback: Incomplete
    def __init__(self, items: list[CallableType]) -> None: ...
    @property
    def items(self) -> list[CallableType]: ...
    def name(self) -> str | None: ...
    def is_type_obj(self) -> bool: ...
    def type_object(self) -> mypy.nodes.TypeInfo: ...
    def with_name(self, name: str) -> Overloaded: ...
    def get_name(self) -> str | None: ...
    def with_unpacked_kwargs(self) -> Overloaded: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def serialize(self) -> JsonDict: ...
    @classmethod
    def deserialize(cls, data: JsonDict) -> Overloaded: ...

class TupleType(ProperType):
    """The tuple type Tuple[T1, ..., Tn] (at least one type argument).

    Instance variables:
        items: Tuple item types
        partial_fallback: The (imprecise) underlying instance type that is used
            for non-tuple methods. This is generally builtins.tuple[Any, ...] for
            regular tuples, but it's different for named tuples and classes with
            a tuple base class. Use mypy.typeops.tuple_fallback to calculate the
            precise fallback type derived from item types.
        implicit: If True, derived from a tuple expression (t,....) instead of Tuple[t, ...]
    """
    items: list[Type]
    partial_fallback: Instance
    implicit: bool
    def __init__(self, items: list[Type], fallback: Instance, line: int = -1, column: int = -1, implicit: bool = False) -> None: ...
    def can_be_true_default(self) -> bool: ...
    def can_be_false_default(self) -> bool: ...
    def can_be_any_bool(self) -> bool: ...
    def length(self) -> int: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def serialize(self) -> JsonDict: ...
    @classmethod
    def deserialize(cls, data: JsonDict) -> TupleType: ...
    def copy_modified(self, *, fallback: Instance | None = None, items: list[Type] | None = None) -> TupleType: ...
    def slice(self, begin: int | None, end: int | None, stride: int | None) -> TupleType: ...

class TypedDictType(ProperType):
    '''Type of TypedDict object {\'k1\': v1, ..., \'kn\': vn}.

    A TypedDict object is a dictionary with specific string (literal) keys. Each
    key has a value with a distinct type that depends on the key. TypedDict objects
    are normal dict objects at runtime.

    A TypedDictType can be either named or anonymous. If it\'s anonymous, its
    fallback will be typing_extensions._TypedDict (Instance). _TypedDict is a subclass
    of Mapping[str, object] and defines all non-mapping dict methods that TypedDict
    supports. Some dict methods are unsafe and not supported. _TypedDict isn\'t defined
    at runtime.

    If a TypedDict is named, its fallback will be an Instance of the named type
    (ex: "Point") whose TypeInfo has a typeddict_type that is anonymous. This
    is similar to how named tuples work.

    TODO: The fallback structure is perhaps overly complicated.
    '''
    items: dict[str, Type]
    required_keys: set[str]
    fallback: Instance
    can_be_true: Incomplete
    can_be_false: Incomplete
    def __init__(self, items: dict[str, Type], required_keys: set[str], fallback: Instance, line: int = -1, column: int = -1) -> None: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def serialize(self) -> JsonDict: ...
    @classmethod
    def deserialize(cls, data: JsonDict) -> TypedDictType: ...
    @property
    def is_final(self) -> bool: ...
    def is_anonymous(self) -> bool: ...
    def as_anonymous(self) -> TypedDictType: ...
    def copy_modified(self, *, fallback: Instance | None = None, item_types: list[Type] | None = None, required_keys: set[str] | None = None) -> TypedDictType: ...
    def create_anonymous_fallback(self) -> Instance: ...
    def names_are_wider_than(self, other: TypedDictType) -> bool: ...
    def zip(self, right: TypedDictType) -> Iterable[tuple[str, Type, Type]]: ...
    def zipall(self, right: TypedDictType) -> Iterable[tuple[str, Type | None, Type | None]]: ...

class RawExpressionType(ProperType):
    '''A synthetic type representing some arbitrary expression that does not cleanly
    translate into a type.

    This synthetic type is only used at the beginning stages of semantic analysis
    and should be completely removing during the process for mapping UnboundTypes to
    actual types: we either turn it into a LiteralType or an AnyType.

    For example, suppose `Foo[1]` is initially represented as the following:

        UnboundType(
            name=\'Foo\',
            args=[
                RawExpressionType(value=1, base_type_name=\'builtins.int\'),
            ],
        )

    As we perform semantic analysis, this type will transform into one of two
    possible forms.

    If \'Foo\' was an alias for \'Literal\' all along, this type is transformed into:

        LiteralType(value=1, fallback=int_instance_here)

    Alternatively, if \'Foo\' is an unrelated class, we report an error and instead
    produce something like this:

        Instance(type=typeinfo_for_foo, args=[AnyType(TypeOfAny.from_error))

    If the "note" field is not None, the provided note will be reported alongside the
    error at this point.

    Note: if "literal_value" is None, that means this object is representing some
    expression that cannot possibly be a parameter of Literal[...]. For example,
    "Foo[3j]" would be represented as:

        UnboundType(
            name=\'Foo\',
            args=[
                RawExpressionType(value=None, base_type_name=\'builtins.complex\'),
            ],
        )
    '''
    literal_value: Incomplete
    base_type_name: Incomplete
    note: Incomplete
    def __init__(self, literal_value: LiteralValue | None, base_type_name: str, line: int = -1, column: int = -1, note: str | None = None) -> None: ...
    def simple_name(self) -> str: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def serialize(self) -> JsonDict: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...

class LiteralType(ProperType):
    '''The type of a Literal instance. Literal[Value]

    A Literal always consists of:

    1. A native Python object corresponding to the contained inner value
    2. A fallback for this Literal. The fallback also corresponds to the
       parent type this Literal subtypes.

    For example, \'Literal[42]\' is represented as
    \'LiteralType(value=42, fallback=instance_of_int)\'

    As another example, `Literal[Color.RED]` (where Color is an enum) is
    represented as `LiteralType(value="RED", fallback=instance_of_color)\'.
    '''
    value: Incomplete
    fallback: Incomplete
    def __init__(self, value: LiteralValue, fallback: Instance, line: int = -1, column: int = -1) -> None: ...
    def can_be_false_default(self) -> bool: ...
    def can_be_true_default(self) -> bool: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def is_enum_literal(self) -> bool: ...
    def value_repr(self) -> str:
        """Returns the string representation of the underlying type.

        This function is almost equivalent to running `repr(self.value)`,
        except it includes some additional logic to correctly handle cases
        where the value is a string, byte string, a unicode string, or an enum.
        """
    def serialize(self) -> JsonDict | str: ...
    @classmethod
    def deserialize(cls, data: JsonDict) -> LiteralType: ...
    def is_singleton_type(self) -> bool: ...

class UnionType(ProperType):
    """The union type Union[T1, ..., Tn] (at least one type argument)."""
    items: Incomplete
    is_evaluated: Incomplete
    uses_pep604_syntax: Incomplete
    def __init__(self, items: Sequence[Type], line: int = -1, column: int = -1, is_evaluated: bool = True, uses_pep604_syntax: bool = False) -> None: ...
    def can_be_true_default(self) -> bool: ...
    def can_be_false_default(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    @overload
    @staticmethod
    def make_union(items: Sequence[ProperType], line: int = -1, column: int = -1) -> ProperType: ...
    @overload
    @staticmethod
    def make_union(items: Sequence[Type], line: int = -1, column: int = -1) -> Type: ...
    def length(self) -> int: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def relevant_items(self) -> list[Type]:
        """Removes NoneTypes from Unions when strict Optional checking is off."""
    def serialize(self) -> JsonDict: ...
    @classmethod
    def deserialize(cls, data: JsonDict) -> UnionType: ...

class PartialType(ProperType):
    """Type such as List[?] where type arguments are unknown, or partial None type.

    These are used for inferring types in multiphase initialization such as this:

      x = []       # x gets a partial type List[?], as item type is unknown
      x.append(1)  # partial type gets replaced with normal type List[int]

    Or with None:

      x = None  # x gets a partial type None
      if c:
          x = 1  # Infer actual type int for x
    """
    type: mypy.nodes.TypeInfo | None
    var: mypy.nodes.Var
    value_type: Instance | None
    def __init__(self, type: mypy.nodes.TypeInfo | None, var: mypy.nodes.Var, value_type: Instance | None = None) -> None: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...

class EllipsisType(ProperType):
    """The type ... (ellipsis).

    This is not a real type but a syntactic AST construct, used in Callable[..., T], for example.

    A semantically analyzed type will never have ellipsis types.
    """
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def serialize(self) -> JsonDict: ...

class TypeType(ProperType):
    """For types like Type[User].

    This annotates variables that are class objects, constrained by
    the type argument.  See PEP 484 for more details.

    We may encounter expressions whose values are specific classes;
    those are represented as callables (possibly overloaded)
    corresponding to the class's constructor's signature and returning
    an instance of that class.  The difference with Type[C] is that
    those callables always represent the exact class given as the
    return type; Type[C] represents any class that's a subclass of C,
    and C may also be a type variable or a union (or Any).

    Many questions around subtype relationships between Type[C1] and
    def(...) -> C2 are answered by looking at the subtype
    relationships between C1 and C2, since Type[] is considered
    covariant.

    There's an unsolved problem with constructor signatures (also
    unsolved in PEP 484): calling a variable whose type is Type[C]
    assumes the constructor signature for C, even though a subclass of
    C might completely change the constructor signature.  For now we
    just assume that users of Type[C] are careful not to do that (in
    the future we might detect when they are violating that
    assumption).
    """
    item: ProperType
    def __init__(self, item: Bogus[Instance | AnyType | TypeVarType | TupleType | None | CallableType], *, line: int = -1, column: int = -1) -> None:
        """To ensure Type[Union[A, B]] is always represented as Union[Type[A], Type[B]], item of
        type UnionType must be handled through make_normalized static method.
        """
    @staticmethod
    def make_normalized(item: Type, *, line: int = -1, column: int = -1) -> ProperType: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def serialize(self) -> JsonDict: ...
    @classmethod
    def deserialize(cls, data: JsonDict) -> Type: ...

class PlaceholderType(ProperType):
    """Temporary, yet-unknown type during semantic analysis.

    This is needed when there's a reference to a type before the real symbol
    table entry of the target type is available (specifically, we use a
    temporary PlaceholderNode symbol node). Consider this example:

      class str(Sequence[str]): ...

    We use a PlaceholderType for the 'str' in 'Sequence[str]' since we can't create
    a TypeInfo for 'str' until all base classes have been resolved. We'll soon
    perform another analysis iteration which replaces the base class with a complete
    type without any placeholders. After semantic analysis, no placeholder types must
    exist.
    """
    fullname: Incomplete
    args: Incomplete
    def __init__(self, fullname: str | None, args: list[Type], line: int) -> None: ...
    def accept(self, visitor: TypeVisitor[T]) -> T: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def serialize(self) -> str: ...

@overload
def get_proper_type(typ: None) -> None: ...
@overload
def get_proper_type(typ: Type) -> ProperType: ...
@overload
def get_proper_types(types: list[Type] | tuple[Type, ...]) -> list[ProperType]: ...
@overload
def get_proper_types(types: list[Type | None] | tuple[Type | None, ...]) -> list[ProperType | None]: ...

class TypeStrVisitor(SyntheticTypeVisitor[str]):
    """Visitor for pretty-printing types into strings.

    This is mostly for debugging/testing.

    Do not preserve original formatting.

    Notes:
     - Represent unbound types as Foo? or Foo?[...].
     - Represent the NoneType type as None.
    """
    id_mapper: Incomplete
    any_as_dots: bool
    options: Incomplete
    def __init__(self, id_mapper: IdMapper | None = None, *, options: Options) -> None: ...
    def visit_unbound_type(self, t: UnboundType) -> str: ...
    def visit_type_list(self, t: TypeList) -> str: ...
    def visit_callable_argument(self, t: CallableArgument) -> str: ...
    def visit_any(self, t: AnyType) -> str: ...
    def visit_none_type(self, t: None) -> str: ...
    def visit_uninhabited_type(self, t: UninhabitedType) -> str: ...
    def visit_erased_type(self, t: ErasedType) -> str: ...
    def visit_deleted_type(self, t: DeletedType) -> str: ...
    def visit_instance(self, t: Instance) -> str: ...
    def visit_type_var(self, t: TypeVarType) -> str: ...
    def visit_param_spec(self, t: ParamSpecType) -> str: ...
    def visit_parameters(self, t: Parameters) -> str: ...
    def visit_type_var_tuple(self, t: TypeVarTupleType) -> str: ...
    def visit_callable_type(self, t: CallableType) -> str: ...
    def visit_overloaded(self, t: Overloaded) -> str: ...
    def visit_tuple_type(self, t: TupleType) -> str: ...
    def visit_typeddict_type(self, t: TypedDictType) -> str: ...
    def visit_raw_expression_type(self, t: RawExpressionType) -> str: ...
    def visit_literal_type(self, t: LiteralType) -> str: ...
    def visit_union_type(self, t: UnionType) -> str: ...
    def visit_partial_type(self, t: PartialType) -> str: ...
    def visit_ellipsis_type(self, t: EllipsisType) -> str: ...
    def visit_type_type(self, t: TypeType) -> str: ...
    def visit_placeholder_type(self, t: PlaceholderType) -> str: ...
    def visit_type_alias_type(self, t: TypeAliasType) -> str: ...
    def visit_unpack_type(self, t: UnpackType) -> str: ...
    def list_str(self, a: Iterable[Type]) -> str:
        """Convert items of an array to strings (pretty-print types)
        and join the results with commas.
        """

class TrivialSyntheticTypeTranslator(TypeTranslator, SyntheticTypeVisitor[Type], metaclass=abc.ABCMeta):
    """A base class for type translators that need to be run during semantic analysis."""
    def visit_placeholder_type(self, t: PlaceholderType) -> Type: ...
    def visit_callable_argument(self, t: CallableArgument) -> Type: ...
    def visit_ellipsis_type(self, t: EllipsisType) -> Type: ...
    def visit_raw_expression_type(self, t: RawExpressionType) -> Type: ...
    def visit_type_list(self, t: TypeList) -> Type: ...

class UnrollAliasVisitor(TrivialSyntheticTypeTranslator):
    recursed: bool
    initial_aliases: Incomplete
    def __init__(self, initial_aliases: set[TypeAliasType]) -> None: ...
    def visit_type_alias_type(self, t: TypeAliasType) -> Type: ...

def is_named_instance(t: Type, fullnames: str | tuple[str, ...]) -> TypeGuard[Instance]: ...

class LocationSetter(TypeTraverserVisitor):
    line: Incomplete
    column: Incomplete
    def __init__(self, line: int, column: int) -> None: ...
    def visit_instance(self, typ: Instance) -> None: ...

class HasTypeVars(BoolTypeQuery):
    skip_alias_target: bool
    def __init__(self) -> None: ...
    def visit_type_var(self, t: TypeVarType) -> bool: ...
    def visit_type_var_tuple(self, t: TypeVarTupleType) -> bool: ...
    def visit_param_spec(self, t: ParamSpecType) -> bool: ...

def has_type_vars(typ: Type) -> bool:
    """Check if a type contains any type variables (recursively)."""

class HasRecursiveType(BoolTypeQuery):
    def __init__(self) -> None: ...
    def visit_type_alias_type(self, t: TypeAliasType) -> bool: ...

def has_recursive_types(typ: Type) -> bool:
    """Check if a type contains any recursive aliases (recursively)."""
def split_with_prefix_and_suffix(types: tuple[Type, ...], prefix: int, suffix: int) -> tuple[tuple[Type, ...], tuple[Type, ...], tuple[Type, ...]]: ...
def extend_args_for_prefix_and_suffix(types: tuple[Type, ...], prefix: int, suffix: int) -> tuple[Type, ...]:
    """Extend list of types by eating out from variadic tuple to satisfy prefix and suffix."""
def flatten_nested_unions(types: Sequence[Type], handle_type_alias_type: bool = True) -> list[Type]:
    """Flatten nested unions in a type list."""
def flatten_nested_tuples(types: Sequence[Type]) -> list[Type]:
    """Recursively flatten TupleTypes nested with Unpack.

    For example this will transform
        Tuple[A, Unpack[Tuple[B, Unpack[Tuple[C, D]]]]]
    into
        Tuple[A, B, C, D]
    """
def is_literal_type(typ: ProperType, fallback_fullname: str, value: LiteralValue) -> bool:
    """Check if this type is a LiteralType with the given fallback type and value."""

names: Final[Incomplete]
deserialize_map: Final[Incomplete]

def callable_with_ellipsis(any_type: AnyType, ret_type: Type, fallback: Instance) -> CallableType:
    """Construct type Callable[..., ret_type]."""

class InstantiateAliasVisitor(ExpandTypeVisitor):
    def visit_union_type(self, t: UnionType) -> Type: ...
