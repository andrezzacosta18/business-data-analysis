from _typeshed import Incomplete
from mypy import message_registry as message_registry
from mypy.erasetype import erase_type as erase_type
from mypy.errorcodes import ErrorCode as ErrorCode
from mypy.errors import ErrorInfo as ErrorInfo, ErrorWatcher as ErrorWatcher, Errors as Errors
from mypy.nodes import ARG_NAMED as ARG_NAMED, ARG_NAMED_OPT as ARG_NAMED_OPT, ARG_OPT as ARG_OPT, ARG_POS as ARG_POS, ARG_STAR as ARG_STAR, ARG_STAR2 as ARG_STAR2, ArgKind as ArgKind, CONTRAVARIANT as CONTRAVARIANT, COVARIANT as COVARIANT, CallExpr as CallExpr, ClassDef as ClassDef, Context as Context, Expression as Expression, FuncDef as FuncDef, IndexExpr as IndexExpr, MypyFile as MypyFile, NameExpr as NameExpr, ReturnStmt as ReturnStmt, SYMBOL_FUNCBASE_TYPES as SYMBOL_FUNCBASE_TYPES, StrExpr as StrExpr, SymbolNode as SymbolNode, SymbolTable as SymbolTable, TypeInfo as TypeInfo, Var as Var, reverse_builtin_aliases as reverse_builtin_aliases
from mypy.operators import op_methods as op_methods, op_methods_to_symbols as op_methods_to_symbols
from mypy.options import Options as Options
from mypy.subtypes import IS_CLASSVAR as IS_CLASSVAR, IS_CLASS_OR_STATIC as IS_CLASS_OR_STATIC, IS_SETTABLE as IS_SETTABLE, IS_VAR as IS_VAR, find_member as find_member, get_member_flags as get_member_flags, is_same_type as is_same_type, is_subtype as is_subtype
from mypy.typeops import separate_union_literals as separate_union_literals
from mypy.types import AnyType as AnyType, CallableType as CallableType, DeletedType as DeletedType, FunctionLike as FunctionLike, Instance as Instance, LiteralType as LiteralType, NoneType as NoneType, Overloaded as Overloaded, ParamSpecType as ParamSpecType, Parameters as Parameters, PartialType as PartialType, ProperType as ProperType, TupleType as TupleType, Type as Type, TypeAliasType as TypeAliasType, TypeOfAny as TypeOfAny, TypeStrVisitor as TypeStrVisitor, TypeType as TypeType, TypeVarTupleType as TypeVarTupleType, TypeVarType as TypeVarType, TypedDictType as TypedDictType, UnboundType as UnboundType, UninhabitedType as UninhabitedType, UnionType as UnionType, UnpackType as UnpackType, get_proper_type as get_proper_type, get_proper_types as get_proper_types
from mypy.typetraverser import TypeTraverserVisitor as TypeTraverserVisitor
from mypy.util import plural_s as plural_s, unmangle as unmangle
from typing import Any, Callable, Collection, Iterable, Iterator, Sequence
from typing_extensions import Final

TYPES_FOR_UNIMPORTED_HINTS: Final[Incomplete]
ARG_CONSTRUCTOR_NAMES: Final[Incomplete]
SUGGESTED_TEST_FIXTURES: Final[Incomplete]
UNSUPPORTED_NUMBERS_TYPES: Final[Incomplete]

class MessageBuilder:
    """Helper class for reporting type checker error messages with parameters.

    The methods of this class need to be provided with the context within a
    file; the errors member manages the wider context.

    IDEA: Support a 'verbose mode' that includes full information about types
          in error messages and that may otherwise produce more detailed error
          messages.
    """
    errors: Errors
    modules: dict[str, MypyFile]
    options: Incomplete
    def __init__(self, errors: Errors, modules: dict[str, MypyFile]) -> None: ...
    def filter_errors(self, *, filter_errors: bool | Callable[[str, ErrorInfo], bool] = True, save_filtered_errors: bool = False) -> ErrorWatcher: ...
    def add_errors(self, errors: list[ErrorInfo]) -> None:
        """Add errors in messages to this builder."""
    def disable_type_names(self) -> Iterator[None]: ...
    def are_type_names_disabled(self) -> bool: ...
    def prefer_simple_messages(self) -> bool:
        """Should we generate simple/fast error messages?

        If errors aren't shown to the user, we don't want to waste cyles producing
        complex error messages.
        """
    def report(self, msg: str, context: Context | None, severity: str, *, code: ErrorCode | None = None, file: str | None = None, origin: Context | None = None, offset: int = 0, allow_dups: bool = False, secondary_context: Context | None = None) -> None:
        """Report an error or note (unless disabled).

        Note that context controls where error is reported, while origin controls
        where # type: ignore comments have effect.
        """
    def fail(self, msg: str, context: Context | None, *, code: ErrorCode | None = None, file: str | None = None, allow_dups: bool = False, secondary_context: Context | None = None) -> None:
        """Report an error message (unless disabled)."""
    def note(self, msg: str, context: Context, file: str | None = None, origin: Context | None = None, offset: int = 0, allow_dups: bool = False, *, code: ErrorCode | None = None, secondary_context: Context | None = None) -> None:
        """Report a note (unless disabled)."""
    def note_multiline(self, messages: str, context: Context, file: str | None = None, offset: int = 0, allow_dups: bool = False, code: ErrorCode | None = None, *, secondary_context: Context | None = None) -> None:
        """Report as many notes as lines in the message (unless disabled)."""
    def has_no_attr(self, original_type: Type, typ: Type, member: str, context: Context, module_symbol_table: SymbolTable | None = None) -> Type:
        """Report a missing or non-accessible member.

        original_type is the top-level type on which the error occurred.
        typ is the actual type that is missing the member. These can be
        different, e.g., in a union, original_type will be the union and typ
        will be the specific item in the union that does not have the member
        attribute.

        'module_symbol_table' is passed to this function if the type for which we
        are trying to get a member was originally a module. The SymbolTable allows
        us to look up and suggests attributes of the module since they are not
        directly available on original_type

        If member corresponds to an operator, use the corresponding operator
        name in the messages. Return type Any.
        """
    def unsupported_operand_types(self, op: str, left_type: Any, right_type: Any, context: Context, *, code: ErrorCode = ...) -> None:
        """Report unsupported operand types for a binary operation.

        Types can be Type objects or strings.
        """
    def unsupported_left_operand(self, op: str, typ: Type, context: Context) -> None: ...
    def not_callable(self, typ: Type, context: Context) -> Type: ...
    def untyped_function_call(self, callee: CallableType, context: Context) -> Type: ...
    def incompatible_argument(self, n: int, m: int, callee: CallableType, arg_type: Type, arg_kind: ArgKind, object_type: Type | None, context: Context, outer_context: Context) -> ErrorCode | None:
        """Report an error about an incompatible argument type.

        The argument type is arg_type, argument number is n and the
        callee type is 'callee'. If the callee represents a method
        that corresponds to an operator, use the corresponding
        operator name in the messages.

        Return the error code that used for the argument (multiple error
        codes are possible).
        """
    def incompatible_argument_note(self, original_caller_type: ProperType, callee_type: ProperType, context: Context, code: ErrorCode | None) -> None: ...
    def maybe_note_concatenate_pos_args(self, original_caller_type: ProperType, callee_type: ProperType, context: Context, code: ErrorCode | None = None) -> None: ...
    def invalid_index_type(self, index_type: Type, expected_type: Type, base_str: str, context: Context, *, code: ErrorCode) -> None: ...
    def too_few_arguments(self, callee: CallableType, context: Context, argument_names: Sequence[str | None] | None) -> None: ...
    def missing_named_argument(self, callee: CallableType, context: Context, name: str) -> None: ...
    def too_many_arguments(self, callee: CallableType, context: Context) -> None: ...
    def too_many_arguments_from_typed_dict(self, callee: CallableType, arg_type: TypedDictType, context: Context) -> None: ...
    def too_many_positional_arguments(self, callee: CallableType, context: Context) -> None: ...
    def maybe_note_about_special_args(self, callee: CallableType, context: Context) -> None: ...
    def unexpected_keyword_argument(self, callee: CallableType, name: str, arg_type: Type, context: Context) -> None: ...
    def duplicate_argument_value(self, callee: CallableType, index: int, context: Context) -> None: ...
    def does_not_return_value(self, callee_type: Type | None, context: Context) -> None:
        """Report an error about use of an unusable type."""
    def deleted_as_rvalue(self, typ: DeletedType, context: Context) -> None:
        """Report an error about using an deleted type as an rvalue."""
    def deleted_as_lvalue(self, typ: DeletedType, context: Context) -> None:
        """Report an error about using an deleted type as an lvalue.

        Currently, this only occurs when trying to assign to an
        exception variable outside the local except: blocks.
        """
    def no_variant_matches_arguments(self, overload: Overloaded, arg_types: list[Type], context: Context, *, code: ErrorCode | None = None) -> None: ...
    def wrong_number_values_to_unpack(self, provided: int, expected: int, context: Context) -> None: ...
    def unpacking_strings_disallowed(self, context: Context) -> None: ...
    def type_not_iterable(self, type: Type, context: Context) -> None: ...
    def possible_missing_await(self, context: Context) -> None: ...
    def incompatible_operator_assignment(self, op: str, context: Context) -> None: ...
    def overload_signature_incompatible_with_supertype(self, name: str, name_in_super: str, supertype: str, context: Context) -> None: ...
    def signature_incompatible_with_supertype(self, name: str, name_in_super: str, supertype: str, context: Context, *, original: ProperType, override: ProperType) -> None: ...
    def pretty_callable_or_overload(self, tp: CallableType | Overloaded, context: Context, *, offset: int = 0, add_class_or_static_decorator: bool = False, allow_dups: bool = False, code: ErrorCode | None = None) -> None: ...
    def argument_incompatible_with_supertype(self, arg_num: int, name: str, type_name: str | None, name_in_supertype: str, arg_type_in_supertype: Type, supertype: str, context: Context, secondary_context: Context) -> None: ...
    def comparison_method_example_msg(self, class_name: str) -> str: ...
    def return_type_incompatible_with_supertype(self, name: str, name_in_supertype: str, supertype: str, original: Type, override: Type, context: Context) -> None: ...
    def override_target(self, name: str, name_in_super: str, supertype: str) -> str: ...
    def incompatible_type_application(self, expected_arg_count: int, actual_arg_count: int, context: Context) -> None: ...
    def could_not_infer_type_arguments(self, callee_type: CallableType, n: int, context: Context) -> None: ...
    def invalid_var_arg(self, typ: Type, context: Context) -> None: ...
    def invalid_keyword_var_arg(self, typ: Type, is_mapping: bool, context: Context) -> None: ...
    def undefined_in_superclass(self, member: str, context: Context) -> None: ...
    def variable_may_be_undefined(self, name: str, context: Context) -> None: ...
    def var_used_before_def(self, name: str, context: Context) -> None: ...
    def first_argument_for_super_must_be_type(self, actual: Type, context: Context) -> None: ...
    def unsafe_super(self, method: str, cls: str, ctx: Context) -> None: ...
    def too_few_string_formatting_arguments(self, context: Context) -> None: ...
    def too_many_string_formatting_arguments(self, context: Context) -> None: ...
    def unsupported_placeholder(self, placeholder: str, context: Context) -> None: ...
    def string_interpolation_with_star_and_key(self, context: Context) -> None: ...
    def requires_int_or_single_byte(self, context: Context, format_call: bool = False) -> None: ...
    def requires_int_or_char(self, context: Context, format_call: bool = False) -> None: ...
    def key_not_in_mapping(self, key: str, context: Context) -> None: ...
    def string_interpolation_mixing_key_and_non_keys(self, context: Context) -> None: ...
    def cannot_determine_type(self, name: str, context: Context) -> None: ...
    def cannot_determine_type_in_base(self, name: str, base: str, context: Context) -> None: ...
    def no_formal_self(self, name: str, item: CallableType, context: Context) -> None: ...
    def incompatible_self_argument(self, name: str, arg: Type, sig: CallableType, is_classmethod: bool, context: Context) -> None: ...
    def incompatible_conditional_function_def(self, defn: FuncDef, old_type: FunctionLike, new_type: FunctionLike) -> None: ...
    def cannot_instantiate_abstract_class(self, class_name: str, abstract_attributes: dict[str, bool], context: Context) -> None: ...
    def base_class_definitions_incompatible(self, name: str, base1: TypeInfo, base2: TypeInfo, context: Context) -> None: ...
    def cant_assign_to_method(self, context: Context) -> None: ...
    def cant_assign_to_classvar(self, name: str, context: Context) -> None: ...
    def no_overridable_method(self, name: str, context: Context) -> None: ...
    def final_cant_override_writable(self, name: str, ctx: Context) -> None: ...
    def cant_override_final(self, name: str, base_name: str, ctx: Context) -> None: ...
    def cant_assign_to_final(self, name: str, attr_assign: bool, ctx: Context) -> None:
        """Warn about a prohibited assignment to a final attribute.

        Pass `attr_assign=True` if the assignment assigns to an attribute.
        """
    def protocol_members_cant_be_final(self, ctx: Context) -> None: ...
    def final_without_value(self, ctx: Context) -> None: ...
    def read_only_property(self, name: str, type: TypeInfo, context: Context) -> None: ...
    def incompatible_typevar_value(self, callee: CallableType, typ: Type, typevar_name: str, context: Context) -> None: ...
    def dangerous_comparison(self, left: Type, right: Type, kind: str, ctx: Context) -> None: ...
    def overload_inconsistently_applies_decorator(self, decorator: str, context: Context) -> None: ...
    def overloaded_signatures_overlap(self, index1: int, index2: int, context: Context) -> None: ...
    def overloaded_signature_will_never_match(self, index1: int, index2: int, context: Context) -> None: ...
    def overloaded_signatures_typevar_specific(self, index: int, context: Context) -> None: ...
    def overloaded_signatures_arg_specific(self, index: int, context: Context) -> None: ...
    def overloaded_signatures_ret_specific(self, index: int, context: Context) -> None: ...
    def warn_both_operands_are_from_unions(self, context: Context) -> None: ...
    def warn_operand_was_from_union(self, side: str, original: Type, context: Context) -> None: ...
    def operator_method_signatures_overlap(self, reverse_class: TypeInfo, reverse_method: str, forward_class: Type, forward_method: str, context: Context) -> None: ...
    def forward_operator_not_callable(self, forward_method: str, context: Context) -> None: ...
    def signatures_incompatible(self, method: str, other_method: str, context: Context) -> None: ...
    def yield_from_invalid_operand_type(self, expr: Type, context: Context) -> Type: ...
    def invalid_signature(self, func_type: Type, context: Context) -> None: ...
    def invalid_signature_for_special_method(self, func_type: Type, context: Context, method_name: str) -> None: ...
    def reveal_type(self, typ: Type, context: Context) -> None: ...
    def reveal_locals(self, type_map: dict[str, Type | None], context: Context) -> None: ...
    def unsupported_type_type(self, item: Type, context: Context) -> None: ...
    def redundant_cast(self, typ: Type, context: Context) -> None: ...
    def assert_type_fail(self, source_type: Type, target_type: Type, context: Context) -> None: ...
    def unimported_type_becomes_any(self, prefix: str, typ: Type, ctx: Context) -> None: ...
    def need_annotation_for_var(self, node: SymbolNode, context: Context, python_version: tuple[int, int] | None = None) -> None: ...
    def explicit_any(self, ctx: Context) -> None: ...
    def unexpected_typeddict_keys(self, typ: TypedDictType, expected_keys: list[str], actual_keys: list[str], context: Context) -> None: ...
    def typeddict_key_must_be_string_literal(self, typ: TypedDictType, context: Context) -> None: ...
    def typeddict_key_not_found(self, typ: TypedDictType, item_name: str, context: Context, setitem: bool = False) -> None:
        """Handle error messages for TypedDicts that have unknown keys.

        Note, that we differentiate in between reading a value and setting a
        value.
        Setting a value on a TypedDict is an 'unknown-key' error, whereas
        reading it is the more serious/general 'item' error.
        """
    def typeddict_context_ambiguous(self, types: list[TypedDictType], context: Context) -> None: ...
    def typeddict_key_cannot_be_deleted(self, typ: TypedDictType, item_name: str, context: Context) -> None: ...
    def typeddict_setdefault_arguments_inconsistent(self, default: Type, expected: Type, context: Context) -> None: ...
    def type_arguments_not_allowed(self, context: Context) -> None: ...
    def disallowed_any_type(self, typ: Type, context: Context) -> None: ...
    def incorrectly_returning_any(self, typ: Type, context: Context) -> None: ...
    def incorrect__exit__return(self, context: Context) -> None: ...
    def untyped_decorated_function(self, typ: Type, context: Context) -> None: ...
    def typed_function_untyped_decorator(self, func_name: str, context: Context) -> None: ...
    def bad_proto_variance(self, actual: int, tvar_name: str, expected: int, context: Context) -> None: ...
    def concrete_only_assign(self, typ: Type, context: Context) -> None: ...
    def concrete_only_call(self, typ: Type, context: Context) -> None: ...
    def cannot_use_function_with_type(self, method_name: str, type_name: str, context: Context) -> None: ...
    def report_non_method_protocol(self, tp: TypeInfo, members: list[str], context: Context) -> None: ...
    def note_call(self, subtype: Type, call: Type, context: Context, *, code: ErrorCode | None) -> None: ...
    def unreachable_statement(self, context: Context) -> None: ...
    def redundant_left_operand(self, op_name: str, context: Context) -> None:
        '''Indicates that the left operand of a boolean expression is redundant:
        it does not change the truth value of the entire condition as a whole.
        \'op_name\' should either be the string "and" or the string "or".
        '''
    def unreachable_right_operand(self, op_name: str, context: Context) -> None:
        '''Indicates that the right operand of a boolean expression is redundant:
        it does not change the truth value of the entire condition as a whole.
        \'op_name\' should either be the string "and" or the string "or".
        '''
    def redundant_condition_in_comprehension(self, truthiness: bool, context: Context) -> None: ...
    def redundant_condition_in_if(self, truthiness: bool, context: Context) -> None: ...
    def redundant_expr(self, description: str, truthiness: bool, context: Context) -> None: ...
    def impossible_intersection(self, formatted_base_class_list: str, reason: str, context: Context) -> None: ...
    def report_protocol_problems(self, subtype: Instance | TupleType | TypedDictType | TypeType | CallableType, supertype: Instance, context: Context, *, code: ErrorCode | None) -> None:
        """Report possible protocol conflicts between 'subtype' and 'supertype'.

        This includes missing members, incompatible types, and incompatible
        attribute flags, such as settable vs read-only or class variable vs
        instance variable.
        """
    def pretty_overload(self, tp: Overloaded, context: Context, offset: int, *, add_class_or_static_decorator: bool = False, allow_dups: bool = False, code: ErrorCode | None = None, skip_self: bool = False) -> None: ...
    def print_more(self, conflicts: Sequence[Any], context: Context, offset: int, max_items: int, *, code: ErrorCode | None = None) -> None: ...
    def try_report_long_tuple_assignment_error(self, subtype: ProperType, supertype: ProperType, context: Context, msg: message_registry.ErrorMessage, subtype_label: str | None = None, supertype_label: str | None = None) -> bool:
        """Try to generate meaningful error message for very long tuple assignment

        Returns a bool: True when generating long tuple assignment error,
        False when no such error reported
        """
    def format_long_tuple_type(self, typ: TupleType) -> str:
        """Format very long tuple type using an ellipsis notation"""
    def generate_incompatible_tuple_error(self, lhs_types: list[Type], rhs_types: list[Type], context: Context, msg: message_registry.ErrorMessage) -> None:
        """Generate error message for individual incompatible tuple pairs"""
    def add_fixture_note(self, fullname: str, ctx: Context) -> None: ...
    def annotation_in_unchecked_function(self, context: Context) -> None: ...

def quote_type_string(type_string: str) -> str:
    """Quotes a type representation for use in messages."""
def format_callable_args(arg_types: list[Type], arg_kinds: list[ArgKind], arg_names: list[str | None], format: Callable[[Type], str], verbosity: int) -> str:
    """Format a bunch of Callable arguments into a string"""
def format_type_inner(typ: Type, verbosity: int, options: Options, fullnames: set[str] | None, module_names: bool = False) -> str:
    """
    Convert a type to a relatively short string suitable for error messages.

    Args:
      verbosity: a coarse grained control on the verbosity of the type
      fullnames: a set of names that should be printed in full
    """
def collect_all_instances(t: Type) -> list[Instance]:
    """Return all instances that `t` contains (including `t`).

    This is similar to collect_all_inner_types from typeanal but only
    returns instances and will recurse into fallbacks.
    """

class CollectAllInstancesQuery(TypeTraverserVisitor):
    instances: Incomplete
    def __init__(self) -> None: ...
    def visit_instance(self, t: Instance) -> None: ...
    def visit_type_alias_type(self, t: TypeAliasType) -> None: ...

def find_type_overlaps(*types: Type) -> set[str]:
    """Return a set of fullnames that share a short name and appear in either type.

    This is used to ensure that distinct types with the same short name are printed
    with their fullname.
    """
def format_type(typ: Type, options: Options, verbosity: int = 0, module_names: bool = False) -> str:
    """
    Convert a type to a relatively short string suitable for error messages.

    `verbosity` is a coarse grained control on the verbosity of the type

    This function returns a string appropriate for unmodified use in error
    messages; this means that it will be quoted in most cases.  If
    modification of the formatted string is required, callers should use
    format_type_bare.
    """
def format_type_bare(typ: Type, options: Options, verbosity: int = 0, module_names: bool = False) -> str:
    """
    Convert a type to a relatively short string suitable for error messages.

    `verbosity` is a coarse grained control on the verbosity of the type
    `fullnames` specifies a set of names that should be printed in full

    This function will return an unquoted string.  If a caller doesn't need to
    perform post-processing on the string output, format_type should be used
    instead.  (The caller may want to use quote_type_string after
    processing has happened, to maintain consistent quoting in messages.)
    """
def format_type_distinctly(*types: Type, options: Options, bare: bool = False) -> tuple[str, ...]:
    """Jointly format types to distinct strings.

    Increase the verbosity of the type strings until they become distinct
    while also requiring that distinct types with the same short name are
    formatted distinctly.

    By default, the returned strings are created using format_type() and will be
    quoted accordingly. If ``bare`` is True, the returned strings will not
    be quoted; callers who need to do post-processing of the strings before
    quoting them (such as prepending * or **) should use this.
    """
def pretty_class_or_static_decorator(tp: CallableType) -> str | None:
    """Return @classmethod or @staticmethod, if any, for the given callable type."""
def pretty_callable(tp: CallableType, options: Options, skip_self: bool = False) -> str:
    """Return a nice easily-readable representation of a callable type.
    For example:
        def [T <: int] f(self, x: int, y: T) -> None

    If skip_self is True, print an actual callable type, as it would appear
    when bound on an instance/class, rather than how it would appear in the
    defining statement.
    """
def variance_string(variance: int) -> str: ...
def get_missing_protocol_members(left: Instance, right: Instance, skip: list[str]) -> list[str]:
    """Find all protocol members of 'right' that are not implemented
    (i.e. completely missing) in 'left'.
    """
def get_conflict_protocol_types(left: Instance, right: Instance, class_obj: bool = False) -> list[tuple[str, Type, Type]]:
    """Find members that are defined in 'left' but have incompatible types.
    Return them as a list of ('member', 'got', 'expected').
    """
def get_bad_protocol_flags(left: Instance, right: Instance, class_obj: bool = False) -> list[tuple[str, set[int], set[int]]]:
    """Return all incompatible attribute flags for members that are present in both
    'left' and 'right'.
    """
def capitalize(s: str) -> str:
    """Capitalize the first character of a string."""
def extract_type(name: str) -> str:
    '''If the argument is the name of a method (of form C.m), return
    the type portion in quotes (e.g. "y"). Otherwise, return the string
    unmodified.
    '''
def strip_quotes(s: str) -> str:
    """Strip a double quote at the beginning and end of the string, if any."""
def format_string_list(lst: list[str]) -> str: ...
def format_item_name_list(s: Iterable[str]) -> str: ...
def callable_name(type: FunctionLike) -> str | None: ...
def for_function(callee: CallableType) -> str: ...
def wrong_type_arg_count(n: int, act: str, name: str) -> str: ...
def find_defining_module(modules: dict[str, MypyFile], typ: CallableType) -> MypyFile | None: ...

COMMON_MISTAKES: Final[dict[str, Sequence[str]]]

def best_matches(current: str, options: Collection[str], n: int) -> list[str]: ...
def pretty_seq(args: Sequence[str], conjunction: str) -> str: ...
def append_invariance_notes(notes: list[str], arg_type: Instance, expected_type: Instance) -> list[str]:
    """Explain that the type is invariant and give notes for how to solve the issue."""
def append_numbers_notes(notes: list[str], arg_type: Instance, expected_type: Instance) -> list[str]:
    '''Explain if an unsupported type from "numbers" is used in a subtype check.'''
def make_inferred_type_note(context: Context, subtype: Type, supertype: Type, supertype_str: str) -> str:
    """Explain that the user may have forgotten to type a variable.

    The user does not expect an error if the inferred container type is the same as the return
    type of a function and the argument type(s) are a subtype of the argument type(s) of the
    return type. This note suggests that they add a type annotation with the return type instead
    of relying on the inferred type.
    """
def format_key_list(keys: list[str], *, short: bool = False) -> str: ...
