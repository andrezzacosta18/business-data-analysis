from _typeshed import Incomplete
from mypy import message_registry as message_registry
from mypy.errorcodes import ErrorCode as ErrorCode
from mypy.errors import Errors as Errors
from mypy.messages import format_type as format_type
from mypy.mixedtraverser import MixedTraverserVisitor as MixedTraverserVisitor
from mypy.nodes import Block as Block, ClassDef as ClassDef, Context as Context, FakeInfo as FakeInfo, FuncItem as FuncItem, MypyFile as MypyFile
from mypy.options import Options as Options
from mypy.scope import Scope as Scope
from mypy.subtypes import is_same_type as is_same_type, is_subtype as is_subtype
from mypy.typeanal import set_any_tvars as set_any_tvars
from mypy.types import AnyType as AnyType, Instance as Instance, ParamSpecType as ParamSpecType, Parameters as Parameters, TupleType as TupleType, Type as Type, TypeAliasType as TypeAliasType, TypeOfAny as TypeOfAny, TypeVarLikeType as TypeVarLikeType, TypeVarTupleType as TypeVarTupleType, TypeVarType as TypeVarType, UnboundType as UnboundType, UnpackType as UnpackType, flatten_nested_tuples as flatten_nested_tuples, get_proper_type as get_proper_type, get_proper_types as get_proper_types, split_with_prefix_and_suffix as split_with_prefix_and_suffix
from typing import Sequence

class TypeArgumentAnalyzer(MixedTraverserVisitor):
    errors: Incomplete
    options: Incomplete
    is_typeshed_file: Incomplete
    scope: Incomplete
    recurse_into_functions: bool
    seen_aliases: Incomplete
    def __init__(self, errors: Errors, options: Options, is_typeshed_file: bool) -> None: ...
    def visit_mypy_file(self, o: MypyFile) -> None: ...
    def visit_func(self, defn: FuncItem) -> None: ...
    def visit_class_def(self, defn: ClassDef) -> None: ...
    def visit_block(self, o: Block) -> None: ...
    def visit_type_alias_type(self, t: TypeAliasType) -> None: ...
    def visit_instance(self, t: Instance) -> None: ...
    def validate_args(self, name: str, args: Sequence[Type], type_vars: list[TypeVarLikeType], ctx: Context) -> bool: ...
    def visit_unpack_type(self, typ: UnpackType) -> None: ...
    def check_type_var_values(self, name: str, actuals: list[Type], arg_name: str, valids: list[Type], context: Context) -> bool: ...
    def fail(self, msg: str, context: Context, *, code: ErrorCode | None = None) -> None: ...
    def note(self, msg: str, context: Context, *, code: ErrorCode | None = None) -> None: ...
