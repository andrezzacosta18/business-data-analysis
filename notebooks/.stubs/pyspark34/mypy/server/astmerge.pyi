from _typeshed import Incomplete
from mypy.nodes import AssertTypeExpr as AssertTypeExpr, AssignmentStmt as AssignmentStmt, Block as Block, CallExpr as CallExpr, CastExpr as CastExpr, ClassDef as ClassDef, EnumCallExpr as EnumCallExpr, FuncBase as FuncBase, FuncDef as FuncDef, LambdaExpr as LambdaExpr, MDEF as MDEF, MemberExpr as MemberExpr, MypyFile as MypyFile, NameExpr as NameExpr, NamedTupleExpr as NamedTupleExpr, NewTypeExpr as NewTypeExpr, OverloadedFuncDef as OverloadedFuncDef, RefExpr as RefExpr, Statement as Statement, SuperExpr as SuperExpr, SymbolNode as SymbolNode, SymbolTable as SymbolTable, TypeAlias as TypeAlias, TypeAliasExpr as TypeAliasExpr, TypeInfo as TypeInfo, TypedDictExpr as TypedDictExpr, Var as Var
from mypy.traverser import TraverserVisitor as TraverserVisitor
from mypy.types import AnyType as AnyType, CallableArgument as CallableArgument, CallableType as CallableType, DeletedType as DeletedType, EllipsisType as EllipsisType, ErasedType as ErasedType, Instance as Instance, LiteralType as LiteralType, NoneType as NoneType, Overloaded as Overloaded, ParamSpecType as ParamSpecType, Parameters as Parameters, PartialType as PartialType, PlaceholderType as PlaceholderType, RawExpressionType as RawExpressionType, SyntheticTypeVisitor as SyntheticTypeVisitor, TupleType as TupleType, Type as Type, TypeAliasType as TypeAliasType, TypeList as TypeList, TypeType as TypeType, TypeVarTupleType as TypeVarTupleType, TypeVarType as TypeVarType, TypedDictType as TypedDictType, UnboundType as UnboundType, UninhabitedType as UninhabitedType, UnionType as UnionType, UnpackType as UnpackType
from mypy.typestate import type_state as type_state
from mypy.util import get_prefix as get_prefix, replace_object_state as replace_object_state
from typing import TypeVar

def merge_asts(old: MypyFile, old_symbols: SymbolTable, new: MypyFile, new_symbols: SymbolTable) -> None:
    """Merge a new version of a module AST to a previous version.

    The main idea is to preserve the identities of externally visible
    nodes in the old AST (that have a corresponding node in the new AST).
    All old node state (outside identity) will come from the new AST.

    When this returns, 'old' will refer to the merged AST, but 'new_symbols'
    will be the new symbol table. 'new' and 'old_symbols' will no longer be
    valid.
    """
def replacement_map_from_symbol_table(old: SymbolTable, new: SymbolTable, prefix: str) -> dict[SymbolNode, SymbolNode]:
    """Create a new-to-old object identity map by comparing two symbol table revisions.

    Both symbol tables must refer to revisions of the same module id. The symbol tables
    are compared recursively (recursing into nested class symbol tables), but only within
    the given module prefix. Don't recurse into other modules accessible through the symbol
    table.
    """
def replace_nodes_in_ast(node: SymbolNode, replacements: dict[SymbolNode, SymbolNode]) -> SymbolNode:
    """Replace all references to replacement map keys within an AST node, recursively.

    Also replace the *identity* of any nodes that have replacements. Return the
    *replaced* version of the argument node (which may have a different identity, if
    it's included in the replacement map).
    """
SN = TypeVar('SN', bound=SymbolNode)

class NodeReplaceVisitor(TraverserVisitor):
    """Transform some nodes to new identities in an AST.

    Only nodes that live in the symbol table may be
    replaced, which simplifies the implementation some. Also
    replace all references to the old identities.
    """
    replacements: Incomplete
    def __init__(self, replacements: dict[SymbolNode, SymbolNode]) -> None: ...
    def visit_mypy_file(self, node: MypyFile) -> None: ...
    def visit_block(self, node: Block) -> None: ...
    def visit_func_def(self, node: FuncDef) -> None: ...
    def visit_overloaded_func_def(self, node: OverloadedFuncDef) -> None: ...
    def visit_class_def(self, node: ClassDef) -> None: ...
    def process_base_func(self, node: FuncBase) -> None: ...
    def process_type_var_def(self, tv: TypeVarType) -> None: ...
    def process_param_spec_def(self, tv: ParamSpecType) -> None: ...
    def process_type_var_tuple_def(self, tv: TypeVarTupleType) -> None: ...
    def visit_assignment_stmt(self, node: AssignmentStmt) -> None: ...
    def visit_name_expr(self, node: NameExpr) -> None: ...
    def visit_member_expr(self, node: MemberExpr) -> None: ...
    def visit_ref_expr(self, node: RefExpr) -> None: ...
    def visit_namedtuple_expr(self, node: NamedTupleExpr) -> None: ...
    def visit_cast_expr(self, node: CastExpr) -> None: ...
    def visit_assert_type_expr(self, node: AssertTypeExpr) -> None: ...
    def visit_super_expr(self, node: SuperExpr) -> None: ...
    def visit_call_expr(self, node: CallExpr) -> None: ...
    def visit_newtype_expr(self, node: NewTypeExpr) -> None: ...
    def visit_lambda_expr(self, node: LambdaExpr) -> None: ...
    def visit_typeddict_expr(self, node: TypedDictExpr) -> None: ...
    def visit_enum_call_expr(self, node: EnumCallExpr) -> None: ...
    def visit_type_alias_expr(self, node: TypeAliasExpr) -> None: ...
    def visit_var(self, node: Var) -> None: ...
    def visit_type_alias(self, node: TypeAlias) -> None: ...
    def fixup(self, node: SN) -> SN: ...
    def fixup_and_reset_typeinfo(self, node: TypeInfo) -> TypeInfo:
        """Fix-up type info and reset subtype caches.

        This needs to be called at least once per each merged TypeInfo, as otherwise we
        may leak stale caches.
        """
    def fixup_type(self, typ: Type | None) -> None: ...
    def process_type_info(self, info: TypeInfo | None) -> None: ...
    def process_synthetic_type_info(self, info: TypeInfo) -> None: ...
    def replace_statements(self, nodes: list[Statement]) -> list[Statement]: ...

class TypeReplaceVisitor(SyntheticTypeVisitor[None]):
    """Similar to NodeReplaceVisitor, but for type objects.

    Note: this visitor may sometimes visit unanalyzed types
    such as 'UnboundType' and 'RawExpressionType' For example, see
    NodeReplaceVisitor.process_base_func.
    """
    replacements: Incomplete
    def __init__(self, replacements: dict[SymbolNode, SymbolNode]) -> None: ...
    def visit_instance(self, typ: Instance) -> None: ...
    def visit_type_alias_type(self, typ: TypeAliasType) -> None: ...
    def visit_any(self, typ: AnyType) -> None: ...
    def visit_none_type(self, typ: None) -> None: ...
    def visit_callable_type(self, typ: CallableType) -> None: ...
    def visit_overloaded(self, t: Overloaded) -> None: ...
    def visit_erased_type(self, t: ErasedType) -> None: ...
    def visit_deleted_type(self, typ: DeletedType) -> None: ...
    def visit_partial_type(self, typ: PartialType) -> None: ...
    def visit_tuple_type(self, typ: TupleType) -> None: ...
    def visit_type_type(self, typ: TypeType) -> None: ...
    def visit_type_var(self, typ: TypeVarType) -> None: ...
    def visit_param_spec(self, typ: ParamSpecType) -> None: ...
    def visit_type_var_tuple(self, typ: TypeVarTupleType) -> None: ...
    def visit_unpack_type(self, typ: UnpackType) -> None: ...
    def visit_parameters(self, typ: Parameters) -> None: ...
    def visit_typeddict_type(self, typ: TypedDictType) -> None: ...
    def visit_raw_expression_type(self, t: RawExpressionType) -> None: ...
    def visit_literal_type(self, typ: LiteralType) -> None: ...
    def visit_unbound_type(self, typ: UnboundType) -> None: ...
    def visit_type_list(self, typ: TypeList) -> None: ...
    def visit_callable_argument(self, typ: CallableArgument) -> None: ...
    def visit_ellipsis_type(self, typ: EllipsisType) -> None: ...
    def visit_uninhabited_type(self, typ: UninhabitedType) -> None: ...
    def visit_union_type(self, typ: UnionType) -> None: ...
    def visit_placeholder_type(self, t: PlaceholderType) -> None: ...
    def fixup(self, node: SN) -> SN: ...

def replace_nodes_in_symbol_table(symbols: SymbolTable, replacements: dict[SymbolNode, SymbolNode]) -> None: ...
