from _typeshed import Incomplete
from mypy.nodes import AssignmentStmt as AssignmentStmt, Block as Block, CLASSDEF_NO_INFO as CLASSDEF_NO_INFO, CallExpr as CallExpr, ClassDef as ClassDef, Decorator as Decorator, ForStmt as ForStmt, FuncDef as FuncDef, ImportAll as ImportAll, ImportFrom as ImportFrom, IndexExpr as IndexExpr, ListExpr as ListExpr, MemberExpr as MemberExpr, MypyFile as MypyFile, NameExpr as NameExpr, Node as Node, OpExpr as OpExpr, OverloadedFuncDef as OverloadedFuncDef, RefExpr as RefExpr, StarExpr as StarExpr, SuperExpr as SuperExpr, SymbolTableNode as SymbolTableNode, TupleExpr as TupleExpr, TypeInfo as TypeInfo, Var as Var
from mypy.traverser import TraverserVisitor as TraverserVisitor
from mypy.types import CallableType as CallableType
from mypy.typestate import type_state as type_state
from typing import Iterator
from typing_extensions import TypeAlias as _TypeAlias

SavedAttributes: _TypeAlias

def strip_target(node: MypyFile | FuncDef | OverloadedFuncDef, saved_attrs: SavedAttributes) -> None:
    """Reset a fine-grained incremental target to state before semantic analysis.

    All TypeInfos are killed. Therefore we need to preserve the variables
    defined as attributes on self. This is done by patches (callbacks)
    returned from this function that re-add these variables when called.

    Args:
        node: node to strip
        saved_attrs: collect attributes here that may need to be re-added to
            classes afterwards if stripping a class body (this dict is mutated)
    """

class NodeStripVisitor(TraverserVisitor):
    type: Incomplete
    is_class_body: bool
    recurse_into_functions: bool
    saved_class_attrs: Incomplete
    def __init__(self, saved_class_attrs: SavedAttributes) -> None: ...
    def strip_file_top_level(self, file_node: MypyFile) -> None:
        """Strip a module top-level (don't recursive into functions)."""
    def visit_block(self, b: Block) -> None: ...
    def visit_class_def(self, node: ClassDef) -> None:
        """Strip class body and type info, but don't strip methods."""
    def save_implicit_attributes(self, node: ClassDef) -> None:
        """Produce callbacks that re-add attributes defined on self."""
    def visit_func_def(self, node: FuncDef) -> None: ...
    def visit_decorator(self, node: Decorator) -> None: ...
    def visit_overloaded_func_def(self, node: OverloadedFuncDef) -> None: ...
    def visit_assignment_stmt(self, node: AssignmentStmt) -> None: ...
    def visit_import_from(self, node: ImportFrom) -> None: ...
    def visit_import_all(self, node: ImportAll) -> None: ...
    def visit_for_stmt(self, node: ForStmt) -> None: ...
    def visit_name_expr(self, node: NameExpr) -> None: ...
    def visit_member_expr(self, node: MemberExpr) -> None: ...
    def visit_index_expr(self, node: IndexExpr) -> None: ...
    def visit_op_expr(self, node: OpExpr) -> None: ...
    def strip_ref_expr(self, node: RefExpr) -> None: ...
    def visit_call_expr(self, node: CallExpr) -> None: ...
    def visit_super_expr(self, node: SuperExpr) -> None: ...
    def process_lvalue_in_method(self, lvalue: Node) -> None: ...
    def enter_class(self, info: TypeInfo) -> Iterator[None]: ...
    def enter_method(self, info: TypeInfo) -> Iterator[None]: ...
