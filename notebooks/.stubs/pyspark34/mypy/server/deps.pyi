from _typeshed import Incomplete
from collections import defaultdict
from mypy.nodes import AssertTypeExpr as AssertTypeExpr, AssignmentStmt as AssignmentStmt, AwaitExpr as AwaitExpr, Block as Block, CallExpr as CallExpr, CastExpr as CastExpr, ClassDef as ClassDef, ComparisonExpr as ComparisonExpr, Decorator as Decorator, DelStmt as DelStmt, DictionaryComprehension as DictionaryComprehension, EnumCallExpr as EnumCallExpr, Expression as Expression, ForStmt as ForStmt, FuncBase as FuncBase, FuncDef as FuncDef, GDEF as GDEF, GeneratorExpr as GeneratorExpr, Import as Import, ImportAll as ImportAll, ImportFrom as ImportFrom, IndexExpr as IndexExpr, LDEF as LDEF, MDEF as MDEF, MemberExpr as MemberExpr, MypyFile as MypyFile, NameExpr as NameExpr, NamedTupleExpr as NamedTupleExpr, NewTypeExpr as NewTypeExpr, Node as Node, OpExpr as OpExpr, OperatorAssignmentStmt as OperatorAssignmentStmt, OverloadedFuncDef as OverloadedFuncDef, RefExpr as RefExpr, StarExpr as StarExpr, SuperExpr as SuperExpr, TupleExpr as TupleExpr, TypeAliasExpr as TypeAliasExpr, TypeApplication as TypeApplication, TypeInfo as TypeInfo, TypeVarExpr as TypeVarExpr, TypedDictExpr as TypedDictExpr, UnaryExpr as UnaryExpr, Var as Var, WithStmt as WithStmt, YieldFromExpr as YieldFromExpr
from mypy.operators import op_methods as op_methods, ops_with_inplace_method as ops_with_inplace_method, reverse_op_methods as reverse_op_methods, unary_op_methods as unary_op_methods
from mypy.options import Options as Options
from mypy.scope import Scope as Scope
from mypy.server.trigger import make_trigger as make_trigger, make_wildcard_trigger as make_wildcard_trigger
from mypy.traverser import TraverserVisitor as TraverserVisitor
from mypy.typeops import bind_self as bind_self
from mypy.types import AnyType as AnyType, CallableType as CallableType, DeletedType as DeletedType, ErasedType as ErasedType, FunctionLike as FunctionLike, Instance as Instance, LiteralType as LiteralType, NoneType as NoneType, Overloaded as Overloaded, ParamSpecType as ParamSpecType, Parameters as Parameters, PartialType as PartialType, ProperType as ProperType, TupleType as TupleType, Type as Type, TypeAliasType as TypeAliasType, TypeOfAny as TypeOfAny, TypeType as TypeType, TypeVarTupleType as TypeVarTupleType, TypeVarType as TypeVarType, TypeVisitor as TypeVisitor, TypedDictType as TypedDictType, UnboundType as UnboundType, UninhabitedType as UninhabitedType, UnionType as UnionType, UnpackType as UnpackType, get_proper_type as get_proper_type
from mypy.typestate import type_state as type_state
from mypy.util import correct_relative_import as correct_relative_import
from typing import List

def get_dependencies(target: MypyFile, type_map: dict[Expression, Type], python_version: tuple[int, int], options: Options) -> dict[str, set[str]]:
    """Get all dependencies of a node, recursively."""
def get_dependencies_of_target(module_id: str, module_tree: MypyFile, target: Node, type_map: dict[Expression, Type], python_version: tuple[int, int]) -> dict[str, set[str]]:
    """Get dependencies of a target -- don't recursive into nested targets."""

class DependencyVisitor(TraverserVisitor):
    scope: Incomplete
    type_map: Incomplete
    alias_deps: Incomplete
    map: Incomplete
    is_class: bool
    is_package_init_file: bool
    options: Incomplete
    def __init__(self, type_map: dict[Expression, Type], python_version: tuple[int, int], alias_deps: defaultdict[str, set[str]], options: Options | None = None) -> None: ...
    def visit_mypy_file(self, o: MypyFile) -> None: ...
    def visit_func_def(self, o: FuncDef) -> None: ...
    def visit_decorator(self, o: Decorator) -> None: ...
    def visit_class_def(self, o: ClassDef) -> None: ...
    def visit_newtype_expr(self, o: NewTypeExpr) -> None: ...
    def process_type_info(self, info: TypeInfo) -> None: ...
    def visit_import(self, o: Import) -> None: ...
    def visit_import_from(self, o: ImportFrom) -> None: ...
    def visit_import_all(self, o: ImportAll) -> None: ...
    def visit_block(self, o: Block) -> None: ...
    def visit_assignment_stmt(self, o: AssignmentStmt) -> None: ...
    def process_lvalue(self, lvalue: Expression) -> None:
        """Generate additional dependencies for an lvalue."""
    def is_self_member_ref(self, memberexpr: MemberExpr) -> bool:
        """Does memberexpr to refer to an attribute of self?"""
    def get_non_partial_lvalue_type(self, lvalue: RefExpr) -> Type: ...
    def visit_operator_assignment_stmt(self, o: OperatorAssignmentStmt) -> None: ...
    def visit_for_stmt(self, o: ForStmt) -> None: ...
    def visit_with_stmt(self, o: WithStmt) -> None: ...
    def visit_del_stmt(self, o: DelStmt) -> None: ...
    def process_global_ref_expr(self, o: RefExpr) -> None: ...
    def visit_name_expr(self, o: NameExpr) -> None: ...
    def visit_member_expr(self, e: MemberExpr) -> None: ...
    def get_unimported_fullname(self, e: MemberExpr, typ: AnyType) -> str | None:
        """If e refers to an unimported definition, infer the fullname of this.

        Return None if e doesn't refer to an unimported definition or if we can't
        determine the name.
        """
    def visit_super_expr(self, e: SuperExpr) -> None: ...
    def visit_call_expr(self, e: CallExpr) -> None: ...
    def process_isinstance_call(self, e: CallExpr) -> None:
        '''Process "isinstance(...)" in a way to avoid some extra dependencies.'''
    def visit_cast_expr(self, e: CastExpr) -> None: ...
    def visit_assert_type_expr(self, e: AssertTypeExpr) -> None: ...
    def visit_type_application(self, e: TypeApplication) -> None: ...
    def visit_index_expr(self, e: IndexExpr) -> None: ...
    def visit_unary_expr(self, e: UnaryExpr) -> None: ...
    def visit_op_expr(self, e: OpExpr) -> None: ...
    def visit_comparison_expr(self, e: ComparisonExpr) -> None: ...
    def process_binary_op(self, op: str, left: Expression, right: Expression) -> None: ...
    def add_operator_method_dependency(self, e: Expression, method: str) -> None: ...
    def add_operator_method_dependency_for_type(self, typ: ProperType, method: str) -> None: ...
    def visit_generator_expr(self, e: GeneratorExpr) -> None: ...
    def visit_dictionary_comprehension(self, e: DictionaryComprehension) -> None: ...
    def visit_star_expr(self, e: StarExpr) -> None: ...
    def visit_yield_from_expr(self, e: YieldFromExpr) -> None: ...
    def visit_await_expr(self, e: AwaitExpr) -> None: ...
    def add_type_alias_deps(self, target: str) -> None: ...
    def add_dependency(self, trigger: str, target: str | None = None) -> None:
        """Add dependency from trigger to a target.

        If the target is not given explicitly, use the current target.
        """
    def add_type_dependencies(self, typ: Type, target: str | None = None) -> None:
        """Add dependencies to all components of a type.

        Args:
            target: If not None, override the default (current) target of the
                generated dependency.
        """
    def add_attribute_dependency(self, typ: Type, name: str) -> None:
        """Add dependencies for accessing a named attribute of a type."""
    def attribute_triggers(self, typ: Type, name: str) -> list[str]:
        """Return all triggers associated with the attribute of a type."""
    def add_attribute_dependency_for_expr(self, e: Expression, name: str) -> None: ...
    def add_iter_dependency(self, node: Expression) -> None: ...
    def use_logical_deps(self) -> bool: ...
    def get_type_triggers(self, typ: Type) -> list[str]: ...

def get_type_triggers(typ: Type, use_logical_deps: bool, seen_aliases: set[TypeAliasType] | None = None) -> list[str]:
    """Return all triggers that correspond to a type becoming stale."""

class TypeTriggersVisitor(TypeVisitor[List[str]]):
    deps: Incomplete
    seen_aliases: Incomplete
    use_logical_deps: Incomplete
    def __init__(self, use_logical_deps: bool, seen_aliases: set[TypeAliasType] | None = None) -> None: ...
    def get_type_triggers(self, typ: Type) -> list[str]: ...
    def visit_instance(self, typ: Instance) -> list[str]: ...
    def visit_type_alias_type(self, typ: TypeAliasType) -> list[str]: ...
    def visit_any(self, typ: AnyType) -> list[str]: ...
    def visit_none_type(self, typ: None) -> list[str]: ...
    def visit_callable_type(self, typ: CallableType) -> list[str]: ...
    def visit_overloaded(self, typ: Overloaded) -> list[str]: ...
    def visit_erased_type(self, t: ErasedType) -> list[str]: ...
    def visit_deleted_type(self, typ: DeletedType) -> list[str]: ...
    def visit_partial_type(self, typ: PartialType) -> list[str]: ...
    def visit_tuple_type(self, typ: TupleType) -> list[str]: ...
    def visit_type_type(self, typ: TypeType) -> list[str]: ...
    def visit_type_var(self, typ: TypeVarType) -> list[str]: ...
    def visit_param_spec(self, typ: ParamSpecType) -> list[str]: ...
    def visit_type_var_tuple(self, typ: TypeVarTupleType) -> list[str]: ...
    def visit_unpack_type(self, typ: UnpackType) -> list[str]: ...
    def visit_parameters(self, typ: Parameters) -> list[str]: ...
    def visit_typeddict_type(self, typ: TypedDictType) -> list[str]: ...
    def visit_literal_type(self, typ: LiteralType) -> list[str]: ...
    def visit_unbound_type(self, typ: UnboundType) -> list[str]: ...
    def visit_uninhabited_type(self, typ: UninhabitedType) -> list[str]: ...
    def visit_union_type(self, typ: UnionType) -> list[str]: ...

def merge_dependencies(new_deps: dict[str, set[str]], deps: dict[str, set[str]]) -> None: ...
def non_trivial_bases(info: TypeInfo) -> list[TypeInfo]: ...
def has_user_bases(info: TypeInfo) -> bool: ...
def dump_all_dependencies(modules: dict[str, MypyFile], type_map: dict[Expression, Type], python_version: tuple[int, int], options: Options) -> None:
    """Generate dependencies for all interesting modules and print them to stdout."""
