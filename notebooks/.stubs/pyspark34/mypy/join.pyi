from _typeshed import Incomplete
from mypy.maptype import map_instance_to_supertype as map_instance_to_supertype
from mypy.nodes import CONTRAVARIANT as CONTRAVARIANT, COVARIANT as COVARIANT, INVARIANT as INVARIANT
from mypy.state import state as state
from mypy.subtypes import SubtypeContext as SubtypeContext, find_member as find_member, is_equivalent as is_equivalent, is_proper_subtype as is_proper_subtype, is_protocol_implementation as is_protocol_implementation, is_subtype as is_subtype
from mypy.types import AnyType as AnyType, CallableType as CallableType, DeletedType as DeletedType, ErasedType as ErasedType, FunctionLike as FunctionLike, Instance as Instance, LiteralType as LiteralType, NoneType as NoneType, Overloaded as Overloaded, ParamSpecType as ParamSpecType, Parameters as Parameters, PartialType as PartialType, PlaceholderType as PlaceholderType, ProperType as ProperType, TupleType as TupleType, Type as Type, TypeAliasType as TypeAliasType, TypeOfAny as TypeOfAny, TypeType as TypeType, TypeVarTupleType as TypeVarTupleType, TypeVarType as TypeVarType, TypeVisitor as TypeVisitor, TypedDictType as TypedDictType, UnboundType as UnboundType, UninhabitedType as UninhabitedType, UnionType as UnionType, UnpackType as UnpackType, get_proper_type as get_proper_type, get_proper_types as get_proper_types
from typing import overload

class InstanceJoiner:
    seen_instances: Incomplete
    def __init__(self) -> None: ...
    def join_instances(self, t: Instance, s: Instance) -> ProperType: ...
    def join_instances_via_supertype(self, t: Instance, s: Instance) -> ProperType: ...

def join_simple(declaration: Type | None, s: Type, t: Type) -> ProperType:
    """Return a simple least upper bound given the declared type.

    This function should be only used by binder, and should not recurse.
    For all other uses, use `join_types()`.
    """
def trivial_join(s: Type, t: Type) -> Type:
    """Return one of types (expanded) if it is a supertype of other, otherwise top type."""
@overload
def join_types(s: ProperType, t: ProperType, instance_joiner: InstanceJoiner | None = None) -> ProperType: ...
@overload
def join_types(s: Type, t: Type, instance_joiner: InstanceJoiner | None = None) -> Type: ...

class TypeJoinVisitor(TypeVisitor[ProperType]):
    """Implementation of the least upper bound algorithm.

    Attributes:
      s: The other (left) type operand.
    """
    s: Incomplete
    instance_joiner: Incomplete
    def __init__(self, s: ProperType, instance_joiner: InstanceJoiner | None = None) -> None: ...
    def visit_unbound_type(self, t: UnboundType) -> ProperType: ...
    def visit_union_type(self, t: UnionType) -> ProperType: ...
    def visit_any(self, t: AnyType) -> ProperType: ...
    def visit_none_type(self, t: None) -> ProperType: ...
    def visit_uninhabited_type(self, t: UninhabitedType) -> ProperType: ...
    def visit_deleted_type(self, t: DeletedType) -> ProperType: ...
    def visit_erased_type(self, t: ErasedType) -> ProperType: ...
    def visit_type_var(self, t: TypeVarType) -> ProperType: ...
    def visit_param_spec(self, t: ParamSpecType) -> ProperType: ...
    def visit_type_var_tuple(self, t: TypeVarTupleType) -> ProperType: ...
    def visit_unpack_type(self, t: UnpackType) -> UnpackType: ...
    def visit_parameters(self, t: Parameters) -> ProperType: ...
    def visit_instance(self, t: Instance) -> ProperType: ...
    def visit_callable_type(self, t: CallableType) -> ProperType: ...
    def visit_overloaded(self, t: Overloaded) -> ProperType: ...
    def visit_tuple_type(self, t: TupleType) -> ProperType: ...
    def visit_typeddict_type(self, t: TypedDictType) -> ProperType: ...
    def visit_literal_type(self, t: LiteralType) -> ProperType: ...
    def visit_partial_type(self, t: PartialType) -> ProperType: ...
    def visit_type_type(self, t: TypeType) -> ProperType: ...
    def visit_type_alias_type(self, t: TypeAliasType) -> ProperType: ...
    def default(self, typ: Type) -> ProperType: ...

def is_better(t: Type, s: Type) -> bool: ...
def normalize_callables(s: ProperType, t: ProperType) -> tuple[ProperType, ProperType]: ...
def is_similar_callables(t: CallableType, s: CallableType) -> bool:
    """Return True if t and s have identical numbers of
    arguments, default arguments and varargs.
    """
def join_similar_callables(t: CallableType, s: CallableType) -> CallableType: ...
def combine_similar_callables(t: CallableType, s: CallableType) -> CallableType: ...
def combine_arg_names(t: CallableType, s: CallableType) -> list[str | None]:
    '''Produces a list of argument names compatible with both callables.

    For example, suppose \'t\' and \'s\' have the following signatures:

    - t: (a: int, b: str, X: str) -> None
    - s: (a: int, b: str, Y: str) -> None

    This function would return ["a", "b", None]. This information
    is then used above to compute the join of t and s, which results
    in a signature of (a: int, b: str, str) -> None.

    Note that the third argument\'s name is omitted and \'t\' and \'s\'
    are both valid subtypes of this inferred signature.

    Precondition: is_similar_types(t, s) is true.
    '''
def object_from_instance(instance: Instance) -> Instance:
    """Construct the type 'builtins.object' from an instance type."""
def object_or_any_from_type(typ: ProperType) -> ProperType: ...
def join_type_list(types: list[Type]) -> Type: ...
def unpack_callback_protocol(t: Instance) -> ProperType | None: ...
