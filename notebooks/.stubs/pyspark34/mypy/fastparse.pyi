import ast as ast3
from _typeshed import Incomplete
from ast import AST, Attribute, Bytes, Call, Ellipsis as ast3_Ellipsis, Index, Name, NameConstant, Num, Starred, Str, UnaryOp
from mypy import defaults as defaults, message_registry as message_registry
from mypy.errors import Errors as Errors
from mypy.message_registry import ErrorMessage as ErrorMessage
from mypy.nodes import ARG_NAMED as ARG_NAMED, ARG_NAMED_OPT as ARG_NAMED_OPT, ARG_OPT as ARG_OPT, ARG_POS as ARG_POS, ARG_STAR as ARG_STAR, ARG_STAR2 as ARG_STAR2, ArgKind as ArgKind, Argument as Argument, AssertStmt as AssertStmt, AssignmentExpr as AssignmentExpr, AssignmentStmt as AssignmentStmt, AwaitExpr as AwaitExpr, Block as Block, BreakStmt as BreakStmt, BytesExpr as BytesExpr, CallExpr as CallExpr, ClassDef as ClassDef, ComparisonExpr as ComparisonExpr, ComplexExpr as ComplexExpr, ConditionalExpr as ConditionalExpr, ContinueStmt as ContinueStmt, Decorator as Decorator, DelStmt as DelStmt, DictExpr as DictExpr, DictionaryComprehension as DictionaryComprehension, EllipsisExpr as EllipsisExpr, Expression as Expression, ExpressionStmt as ExpressionStmt, FakeInfo as FakeInfo, FloatExpr as FloatExpr, ForStmt as ForStmt, FuncDef as FuncDef, GeneratorExpr as GeneratorExpr, GlobalDecl as GlobalDecl, IfStmt as IfStmt, Import as Import, ImportAll as ImportAll, ImportBase as ImportBase, ImportFrom as ImportFrom, IndexExpr as IndexExpr, IntExpr as IntExpr, LambdaExpr as LambdaExpr, ListComprehension as ListComprehension, ListExpr as ListExpr, MatchStmt as MatchStmt, MemberExpr as MemberExpr, MypyFile as MypyFile, NameExpr as NameExpr, Node as Node, NonlocalDecl as NonlocalDecl, OpExpr as OpExpr, OperatorAssignmentStmt as OperatorAssignmentStmt, OverloadPart as OverloadPart, OverloadedFuncDef as OverloadedFuncDef, PassStmt as PassStmt, RaiseStmt as RaiseStmt, RefExpr as RefExpr, ReturnStmt as ReturnStmt, SetComprehension as SetComprehension, SetExpr as SetExpr, SliceExpr as SliceExpr, StarExpr as StarExpr, Statement as Statement, StrExpr as StrExpr, SuperExpr as SuperExpr, TempNode as TempNode, TryStmt as TryStmt, TupleExpr as TupleExpr, UnaryExpr as UnaryExpr, Var as Var, WhileStmt as WhileStmt, WithStmt as WithStmt, YieldExpr as YieldExpr, YieldFromExpr as YieldFromExpr, check_arg_names as check_arg_names
from mypy.options import Options as Options
from mypy.patterns import AsPattern as AsPattern, ClassPattern as ClassPattern, MappingPattern as MappingPattern, OrPattern as OrPattern, SequencePattern as SequencePattern, SingletonPattern as SingletonPattern, StarredPattern as StarredPattern, ValuePattern as ValuePattern
from mypy.reachability import infer_reachability_of_if_statement as infer_reachability_of_if_statement, mark_block_unreachable as mark_block_unreachable
from mypy.sharedparse import argument_elide_name as argument_elide_name, special_function_elide_names as special_function_elide_names
from mypy.traverser import TraverserVisitor as TraverserVisitor
from mypy.types import AnyType as AnyType, CallableArgument as CallableArgument, CallableType as CallableType, EllipsisType as EllipsisType, Instance as Instance, ProperType as ProperType, RawExpressionType as RawExpressionType, TupleType as TupleType, Type as Type, TypeList as TypeList, TypeOfAny as TypeOfAny, UnboundType as UnboundType, UnionType as UnionType
from mypy.util import bytes_to_human_readable_repr as bytes_to_human_readable_repr, unnamed_function as unnamed_function
from typed_ast import ast35 as ast35
from typing import Any, Sequence, TypeVar
from typing_extensions import Final, overload

PY_MINOR_VERSION: Final[Incomplete]

def ast3_parse(source: str | bytes, filename: str, mode: str, feature_version: int = ...) -> AST: ...

NamedExpr: Incomplete
Constant: Incomplete
Match: Incomplete
MatchValue: Incomplete
MatchSingleton: Incomplete
MatchSequence: Incomplete
MatchStar: Incomplete
MatchMapping: Incomplete
MatchClass: Incomplete
MatchAs: Incomplete
MatchOr: Incomplete
AstNode: Incomplete
TryStar: Incomplete
N = TypeVar('N', bound=Node)
MISSING_FALLBACK: Final[Incomplete]
TYPE_IGNORE_PATTERN: Final[Incomplete]

def parse(source: str | bytes, fnam: str, module: str | None, errors: Errors | None = None, options: Options | None = None) -> MypyFile:
    """Parse a source file, without doing any semantic analysis.

    Return the parse tree. If errors is not provided, raise ParseError
    on failure. Otherwise, use the errors object to report parse errors.
    """
def parse_type_ignore_tag(tag: str | None) -> list[str] | None:
    '''Parse optional "[code, ...]" tag after "# type: ignore".

    Return:
     * [] if no tag was found (ignore all errors)
     * list of ignored error codes if a tag was found
     * None if the tag was invalid.
    '''
def parse_type_comment(type_comment: str, line: int, column: int, errors: Errors | None) -> tuple[list[str] | None, ProperType | None]:
    """Parse type portion of a type comment (+ optional type ignore).

    Return (ignore info, parsed type).
    """
def parse_type_string(expr_string: str, expr_fallback_name: str, line: int, column: int) -> ProperType:
    '''Parses a type that was originally present inside of an explicit string.

    For example, suppose we have the type `Foo["blah"]`. We should parse the
    string expression "blah" using this function.
    '''
def is_no_type_check_decorator(expr: ast3.expr) -> bool: ...

class ASTConverter:
    class_and_function_stack: Incomplete
    imports: Incomplete
    options: Incomplete
    is_stub: Incomplete
    errors: Incomplete
    ignore_errors: Incomplete
    strip_function_bodies: Incomplete
    type_ignores: Incomplete
    visitor_cache: Incomplete
    def __init__(self, options: Options, is_stub: bool, errors: Errors, *, ignore_errors: bool, strip_function_bodies: bool) -> None: ...
    def note(self, msg: str, line: int, column: int) -> None: ...
    def fail(self, msg: ErrorMessage, line: int, column: int, blocker: bool = True) -> None: ...
    def fail_merge_overload(self, node: IfStmt) -> None: ...
    def visit(self, node: AST | None) -> Any: ...
    def set_line(self, node: N, n: AstNode) -> N: ...
    def translate_opt_expr_list(self, l: Sequence[AST | None]) -> list[Expression | None]: ...
    def translate_expr_list(self, l: Sequence[AST]) -> list[Expression]: ...
    def get_lineno(self, node: ast3.expr | ast3.stmt) -> int: ...
    def translate_stmt_list(self, stmts: Sequence[ast3.stmt], *, ismodule: bool = False, can_strip: bool = False, is_coroutine: bool = False) -> list[Statement]: ...
    def translate_type_comment(self, n: ast3.stmt | ast3.arg, type_comment: str | None) -> ProperType | None: ...
    op_map: Final[dict[type[AST], str]]
    def from_operator(self, op: ast3.operator) -> str: ...
    comp_op_map: Final[dict[type[AST], str]]
    def from_comp_operator(self, op: ast3.cmpop) -> str: ...
    def set_block_lines(self, b: Block, stmts: Sequence[ast3.stmt]) -> None: ...
    def as_block(self, stmts: list[ast3.stmt]) -> Block | None: ...
    def as_required_block(self, stmts: list[ast3.stmt], *, can_strip: bool = False, is_coroutine: bool = False) -> Block: ...
    def fix_function_overloads(self, stmts: list[Statement]) -> list[Statement]: ...
    def translate_module_id(self, id: str) -> str:
        """Return the actual, internal module id for a source text id."""
    def visit_Module(self, mod: ast3.Module) -> MypyFile: ...
    def visit_FunctionDef(self, n: ast3.FunctionDef) -> FuncDef | Decorator: ...
    def visit_AsyncFunctionDef(self, n: ast3.AsyncFunctionDef) -> FuncDef | Decorator: ...
    def do_func_def(self, n: ast3.FunctionDef | ast3.AsyncFunctionDef, is_coroutine: bool = False) -> FuncDef | Decorator:
        """Helper shared between visit_FunctionDef and visit_AsyncFunctionDef."""
    def set_type_optional(self, type: Type | None, initializer: Expression | None) -> None: ...
    def transform_args(self, args: ast3.arguments, line: int, no_type_check: bool = False) -> list[Argument]: ...
    def make_argument(self, arg: ast3.arg, default: ast3.expr | None, kind: ArgKind, no_type_check: bool, pos_only: bool = False) -> Argument: ...
    def fail_arg(self, msg: str, arg: ast3.arg) -> None: ...
    def visit_ClassDef(self, n: ast3.ClassDef) -> ClassDef: ...
    def visit_Return(self, n: ast3.Return) -> ReturnStmt: ...
    def visit_Delete(self, n: ast3.Delete) -> DelStmt: ...
    def visit_Assign(self, n: ast3.Assign) -> AssignmentStmt: ...
    def visit_AnnAssign(self, n: ast3.AnnAssign) -> AssignmentStmt: ...
    def visit_AugAssign(self, n: ast3.AugAssign) -> OperatorAssignmentStmt: ...
    def visit_For(self, n: ast3.For) -> ForStmt: ...
    def visit_AsyncFor(self, n: ast3.AsyncFor) -> ForStmt: ...
    def visit_While(self, n: ast3.While) -> WhileStmt: ...
    def visit_If(self, n: ast3.If) -> IfStmt: ...
    def visit_With(self, n: ast3.With) -> WithStmt: ...
    def visit_AsyncWith(self, n: ast3.AsyncWith) -> WithStmt: ...
    def visit_Raise(self, n: ast3.Raise) -> RaiseStmt: ...
    def visit_Try(self, n: ast3.Try) -> TryStmt: ...
    def visit_TryStar(self, n: TryStar) -> TryStmt: ...
    def visit_Assert(self, n: ast3.Assert) -> AssertStmt: ...
    def visit_Import(self, n: ast3.Import) -> Import: ...
    def visit_ImportFrom(self, n: ast3.ImportFrom) -> ImportBase: ...
    def visit_Global(self, n: ast3.Global) -> GlobalDecl: ...
    def visit_Nonlocal(self, n: ast3.Nonlocal) -> NonlocalDecl: ...
    def visit_Expr(self, n: ast3.Expr) -> ExpressionStmt: ...
    def visit_Pass(self, n: ast3.Pass) -> PassStmt: ...
    def visit_Break(self, n: ast3.Break) -> BreakStmt: ...
    def visit_Continue(self, n: ast3.Continue) -> ContinueStmt: ...
    def visit_NamedExpr(self, n: NamedExpr) -> AssignmentExpr: ...
    def visit_BoolOp(self, n: ast3.BoolOp) -> OpExpr: ...
    def group(self, op: str, vals: list[Expression], n: ast3.expr) -> OpExpr: ...
    def visit_BinOp(self, n: ast3.BinOp) -> OpExpr: ...
    def visit_UnaryOp(self, n: ast3.UnaryOp) -> UnaryExpr: ...
    def visit_Lambda(self, n: ast3.Lambda) -> LambdaExpr: ...
    def visit_IfExp(self, n: ast3.IfExp) -> ConditionalExpr: ...
    def visit_Dict(self, n: ast3.Dict) -> DictExpr: ...
    def visit_Set(self, n: ast3.Set) -> SetExpr: ...
    def visit_ListComp(self, n: ast3.ListComp) -> ListComprehension: ...
    def visit_SetComp(self, n: ast3.SetComp) -> SetComprehension: ...
    def visit_DictComp(self, n: ast3.DictComp) -> DictionaryComprehension: ...
    def visit_GeneratorExp(self, n: ast3.GeneratorExp) -> GeneratorExpr: ...
    def visit_Await(self, n: ast3.Await) -> AwaitExpr: ...
    def visit_Yield(self, n: ast3.Yield) -> YieldExpr: ...
    def visit_YieldFrom(self, n: ast3.YieldFrom) -> YieldFromExpr: ...
    def visit_Compare(self, n: ast3.Compare) -> ComparisonExpr: ...
    def visit_Call(self, n: Call) -> CallExpr: ...
    def visit_Constant(self, n: Constant) -> Any: ...
    def visit_Num(self, n: ast3.Num) -> IntExpr | FloatExpr | ComplexExpr: ...
    def visit_Str(self, n: Str) -> StrExpr: ...
    def visit_JoinedStr(self, n: ast3.JoinedStr) -> Expression: ...
    def visit_FormattedValue(self, n: ast3.FormattedValue) -> Expression: ...
    def visit_Bytes(self, n: ast3.Bytes) -> BytesExpr | StrExpr: ...
    def visit_NameConstant(self, n: NameConstant) -> NameExpr: ...
    def visit_Ellipsis(self, n: ast3_Ellipsis) -> EllipsisExpr: ...
    def visit_Attribute(self, n: Attribute) -> MemberExpr | SuperExpr: ...
    def visit_Subscript(self, n: ast3.Subscript) -> IndexExpr: ...
    def visit_Starred(self, n: Starred) -> StarExpr: ...
    def visit_Name(self, n: Name) -> NameExpr: ...
    def visit_List(self, n: ast3.List) -> ListExpr | TupleExpr: ...
    def visit_Tuple(self, n: ast3.Tuple) -> TupleExpr: ...
    def visit_Slice(self, n: ast3.Slice) -> SliceExpr: ...
    def visit_ExtSlice(self, n: ast3.ExtSlice) -> TupleExpr: ...
    def visit_Index(self, n: Index) -> Node: ...
    def visit_Match(self, n: Match) -> MatchStmt: ...
    def visit_MatchValue(self, n: MatchValue) -> ValuePattern: ...
    def visit_MatchSingleton(self, n: MatchSingleton) -> SingletonPattern: ...
    def visit_MatchSequence(self, n: MatchSequence) -> SequencePattern: ...
    def visit_MatchStar(self, n: MatchStar) -> StarredPattern: ...
    def visit_MatchMapping(self, n: MatchMapping) -> MappingPattern: ...
    def visit_MatchClass(self, n: MatchClass) -> ClassPattern: ...
    def visit_MatchAs(self, n: MatchAs) -> AsPattern: ...
    def visit_MatchOr(self, n: MatchOr) -> OrPattern: ...

class TypeConverter:
    errors: Incomplete
    line: Incomplete
    override_column: Incomplete
    node_stack: Incomplete
    is_evaluated: Incomplete
    def __init__(self, errors: Errors | None, line: int = -1, override_column: int = -1, is_evaluated: bool = True) -> None: ...
    def convert_column(self, column: int) -> int:
        """Apply column override if defined; otherwise return column.

        Column numbers are sometimes incorrect in the AST and the column
        override can be used to work around that.
        """
    def invalid_type(self, node: AST, note: str | None = None) -> RawExpressionType:
        '''Constructs a type representing some expression that normally forms an invalid type.
        For example, if we see a type hint that says "3 + 4", we would transform that
        expression into a RawExpressionType.

        The semantic analysis layer will report an "Invalid type" error when it
        encounters this type, along with the given note if one is provided.

        See RawExpressionType\'s docstring for more details on how it\'s used.
        '''
    @overload
    def visit(self, node: ast3.expr) -> ProperType: ...
    @overload
    def visit(self, node: AST | None) -> ProperType | None: ...
    def parent(self) -> AST | None:
        """Return the AST node above the one we are processing"""
    def fail(self, msg: ErrorMessage, line: int, column: int) -> None: ...
    def note(self, msg: str, line: int, column: int) -> None: ...
    def translate_expr_list(self, l: Sequence[ast3.expr]) -> list[Type]: ...
    def visit_Call(self, e: Call) -> Type: ...
    def translate_argument_list(self, l: Sequence[ast3.expr]) -> TypeList: ...
    def visit_Name(self, n: Name) -> Type: ...
    def visit_BinOp(self, n: ast3.BinOp) -> Type: ...
    def visit_NameConstant(self, n: NameConstant) -> Type: ...
    def visit_Constant(self, n: Constant) -> Type: ...
    def visit_UnaryOp(self, n: UnaryOp) -> Type: ...
    def numeric_type(self, value: object, n: AST) -> Type: ...
    def visit_Num(self, n: Num) -> Type: ...
    def visit_Str(self, n: Str) -> Type: ...
    def visit_Bytes(self, n: Bytes) -> Type: ...
    def visit_Index(self, n: ast3.Index) -> Type: ...
    def visit_Slice(self, n: ast3.Slice) -> Type: ...
    def visit_Subscript(self, n: ast3.Subscript) -> Type: ...
    def visit_Tuple(self, n: ast3.Tuple) -> Type: ...
    def visit_Attribute(self, n: Attribute) -> Type: ...
    def visit_Ellipsis(self, n: ast3_Ellipsis) -> Type: ...
    def visit_List(self, n: ast3.List) -> Type: ...

def stringify_name(n: AST) -> str | None: ...

class FindAttributeAssign(TraverserVisitor):
    """Check if an AST contains attribute assignments (e.g. self.x = 0)."""
    lvalue: bool
    found: bool
    def __init__(self) -> None: ...
    def visit_assignment_stmt(self, s: AssignmentStmt) -> None: ...
    def visit_with_stmt(self, s: WithStmt) -> None: ...
    def visit_for_stmt(self, s: ForStmt) -> None: ...
    def visit_expression_stmt(self, s: ExpressionStmt) -> None: ...
    def visit_call_expr(self, e: CallExpr) -> None: ...
    def visit_index_expr(self, e: IndexExpr) -> None: ...
    def visit_member_expr(self, e: MemberExpr) -> None: ...

class FindYield(TraverserVisitor):
    """Check if an AST contains yields or yield froms."""
    found: bool
    def __init__(self) -> None: ...
    def visit_yield_expr(self, e: YieldExpr) -> None: ...
    def visit_yield_from_expr(self, e: YieldFromExpr) -> None: ...

def is_possible_trivial_body(s: list[Statement]) -> bool:
    '''Could the statements form a "trivial" function body, such as \'pass\'?

    This mimics mypy.semanal.is_trivial_body, but this runs before
    semantic analysis so some checks must be conservative.
    '''
