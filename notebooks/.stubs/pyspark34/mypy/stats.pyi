from _typeshed import Incomplete
from mypy import nodes as nodes
from mypy.argmap import map_formals_to_actuals as map_formals_to_actuals
from mypy.nodes import AssignmentExpr as AssignmentExpr, AssignmentStmt as AssignmentStmt, BreakStmt as BreakStmt, BytesExpr as BytesExpr, CallExpr as CallExpr, ClassDef as ClassDef, ComparisonExpr as ComparisonExpr, ComplexExpr as ComplexExpr, ContinueStmt as ContinueStmt, EllipsisExpr as EllipsisExpr, Expression as Expression, ExpressionStmt as ExpressionStmt, FloatExpr as FloatExpr, FuncDef as FuncDef, Import as Import, ImportAll as ImportAll, ImportFrom as ImportFrom, IndexExpr as IndexExpr, IntExpr as IntExpr, MemberExpr as MemberExpr, MypyFile as MypyFile, NameExpr as NameExpr, Node as Node, OpExpr as OpExpr, PassStmt as PassStmt, RefExpr as RefExpr, StrExpr as StrExpr, TypeApplication as TypeApplication, UnaryExpr as UnaryExpr, YieldFromExpr as YieldFromExpr
from mypy.traverser import TraverserVisitor as TraverserVisitor
from mypy.typeanal import collect_all_inner_types as collect_all_inner_types
from mypy.types import AnyType as AnyType, CallableType as CallableType, FunctionLike as FunctionLike, Instance as Instance, TupleType as TupleType, Type as Type, TypeOfAny as TypeOfAny, TypeQuery as TypeQuery, TypeVarType as TypeVarType, get_proper_type as get_proper_type, get_proper_types as get_proper_types
from mypy.util import correct_relative_import as correct_relative_import
from typing import Iterator
from typing_extensions import Final

TYPE_EMPTY: Final[int]
TYPE_UNANALYZED: Final[int]
TYPE_PRECISE: Final[int]
TYPE_IMPRECISE: Final[int]
TYPE_ANY: Final[int]
precision_names: Final[Incomplete]

class StatisticsVisitor(TraverserVisitor):
    inferred: Incomplete
    filename: Incomplete
    modules: Incomplete
    typemap: Incomplete
    all_nodes: Incomplete
    visit_untyped_defs: Incomplete
    num_precise_exprs: int
    num_imprecise_exprs: int
    num_any_exprs: int
    num_simple_types: int
    num_generic_types: int
    num_tuple_types: int
    num_function_types: int
    num_typevar_types: int
    num_complex_types: int
    num_any_types: int
    line: int
    line_map: Incomplete
    type_of_any_counter: Incomplete
    any_line_map: Incomplete
    checked_scopes: Incomplete
    output: Incomplete
    def __init__(self, inferred: bool, filename: str, modules: dict[str, MypyFile], typemap: dict[Expression, Type] | None = None, all_nodes: bool = False, visit_untyped_defs: bool = True) -> None: ...
    cur_mod_node: Incomplete
    cur_mod_id: Incomplete
    def visit_mypy_file(self, o: MypyFile) -> None: ...
    def visit_import_from(self, imp: ImportFrom) -> None: ...
    def visit_import_all(self, imp: ImportAll) -> None: ...
    def process_import(self, imp: ImportFrom | ImportAll) -> None: ...
    def visit_import(self, imp: Import) -> None: ...
    def visit_func_def(self, o: FuncDef) -> None: ...
    def enter_scope(self, o: FuncDef) -> Iterator[None]: ...
    def is_checked_scope(self) -> bool: ...
    def visit_class_def(self, o: ClassDef) -> None: ...
    def visit_type_application(self, o: TypeApplication) -> None: ...
    def visit_assignment_stmt(self, o: AssignmentStmt) -> None: ...
    def visit_expression_stmt(self, o: ExpressionStmt) -> None: ...
    def visit_pass_stmt(self, o: PassStmt) -> None: ...
    def visit_break_stmt(self, o: BreakStmt) -> None: ...
    def visit_continue_stmt(self, o: ContinueStmt) -> None: ...
    def visit_name_expr(self, o: NameExpr) -> None: ...
    def visit_yield_from_expr(self, o: YieldFromExpr) -> None: ...
    def visit_call_expr(self, o: CallExpr) -> None: ...
    def record_call_target_precision(self, o: CallExpr) -> None:
        """Record precision of formal argument types used in a call."""
    def record_callable_target_precision(self, o: CallExpr, callee: CallableType) -> None:
        """Record imprecision caused by callee argument types.

        This only considers arguments passed in a call expression. Arguments
        with default values that aren't provided in a call arguably don't
        contribute to typing imprecision at the *call site* (but they
        contribute at the function definition).
        """
    def visit_member_expr(self, o: MemberExpr) -> None: ...
    def visit_op_expr(self, o: OpExpr) -> None: ...
    def visit_comparison_expr(self, o: ComparisonExpr) -> None: ...
    def visit_index_expr(self, o: IndexExpr) -> None: ...
    def visit_assignment_expr(self, o: AssignmentExpr) -> None: ...
    def visit_unary_expr(self, o: UnaryExpr) -> None: ...
    def visit_str_expr(self, o: StrExpr) -> None: ...
    def visit_bytes_expr(self, o: BytesExpr) -> None: ...
    def visit_int_expr(self, o: IntExpr) -> None: ...
    def visit_float_expr(self, o: FloatExpr) -> None: ...
    def visit_complex_expr(self, o: ComplexExpr) -> None: ...
    def visit_ellipsis(self, o: EllipsisExpr) -> None: ...
    def process_node(self, node: Expression) -> None: ...
    def record_precise_if_checked_scope(self, node: Node) -> None: ...
    def type(self, t: Type | None) -> None: ...
    def log(self, string: str) -> None: ...
    def record_line(self, line: int, precision: int) -> None: ...

def dump_type_stats(tree: MypyFile, path: str, modules: dict[str, MypyFile], inferred: bool = False, typemap: dict[Expression, Type] | None = None) -> None: ...
def is_special_module(path: str) -> bool: ...
def is_imprecise(t: Type) -> bool: ...

class HasAnyQuery(TypeQuery[bool]):
    def __init__(self) -> None: ...
    def visit_any(self, t: AnyType) -> bool: ...

def is_imprecise2(t: Type) -> bool: ...

class HasAnyQuery2(HasAnyQuery):
    def visit_callable_type(self, t: CallableType) -> bool: ...

def is_generic(t: Type) -> bool: ...
def is_complex(t: Type) -> bool: ...
def ensure_dir_exists(dir: str) -> None: ...
def is_special_form_any(t: AnyType) -> bool: ...
def get_original_any(t: AnyType) -> AnyType: ...
