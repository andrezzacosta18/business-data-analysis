from _typeshed import Incomplete
from mypy.nodes import ARG_POS as ARG_POS, ARG_STAR as ARG_STAR, ArgKind as ArgKind, Var as Var
from mypy.state import state as state
from mypy.type_visitor import TypeTranslator as TypeTranslator
from mypy.types import ANY_STRATEGY as ANY_STRATEGY, AnyType as AnyType, BoolTypeQuery as BoolTypeQuery, CallableType as CallableType, DeletedType as DeletedType, ErasedType as ErasedType, FunctionLike as FunctionLike, Instance as Instance, LiteralType as LiteralType, NoneType as NoneType, Overloaded as Overloaded, ParamSpecFlavor as ParamSpecFlavor, ParamSpecType as ParamSpecType, Parameters as Parameters, PartialType as PartialType, ProperType as ProperType, TrivialSyntheticTypeTranslator as TrivialSyntheticTypeTranslator, TupleType as TupleType, Type as Type, TypeAliasType as TypeAliasType, TypeType as TypeType, TypeVarId as TypeVarId, TypeVarLikeType as TypeVarLikeType, TypeVarTupleType as TypeVarTupleType, TypeVarType as TypeVarType, TypedDictType as TypedDictType, UnboundType as UnboundType, UninhabitedType as UninhabitedType, UnionType as UnionType, UnpackType as UnpackType, flatten_nested_tuples as flatten_nested_tuples, flatten_nested_unions as flatten_nested_unions, get_proper_type as get_proper_type, split_with_prefix_and_suffix as split_with_prefix_and_suffix
from mypy.typevartuples import find_unpack_in_list as find_unpack_in_list, split_with_instance as split_with_instance
from typing import Iterable, Mapping, Sequence, TypeVar, overload
from typing_extensions import Final

@overload
def expand_type(typ: CallableType, env: Mapping[TypeVarId, Type]) -> CallableType: ...
@overload
def expand_type(typ: ProperType, env: Mapping[TypeVarId, Type]) -> ProperType: ...
@overload
def expand_type(typ: Type, env: Mapping[TypeVarId, Type]) -> Type: ...
@overload
def expand_type_by_instance(typ: CallableType, instance: Instance) -> CallableType: ...
@overload
def expand_type_by_instance(typ: ProperType, instance: Instance) -> ProperType: ...
@overload
def expand_type_by_instance(typ: Type, instance: Instance) -> Type: ...
F = TypeVar('F', bound=FunctionLike)

def freshen_function_type_vars(callee: F) -> F:
    """Substitute fresh type variables for generic function type variables."""

class HasGenericCallable(BoolTypeQuery):
    def __init__(self) -> None: ...
    def visit_callable_type(self, t: CallableType) -> bool: ...

has_generic_callable: Final[Incomplete]
T = TypeVar('T', bound=Type)

def freshen_all_functions_type_vars(t: T) -> T: ...

class FreshenCallableVisitor(TypeTranslator):
    def visit_callable_type(self, t: CallableType) -> Type: ...
    def visit_type_alias_type(self, t: TypeAliasType) -> Type: ...

class ExpandTypeVisitor(TrivialSyntheticTypeTranslator):
    """Visitor that substitutes type variables with values."""
    variables: Mapping[TypeVarId, Type]
    def __init__(self, variables: Mapping[TypeVarId, Type]) -> None: ...
    def visit_unbound_type(self, t: UnboundType) -> Type: ...
    def visit_any(self, t: AnyType) -> Type: ...
    def visit_none_type(self, t: None) -> Type: ...
    def visit_uninhabited_type(self, t: UninhabitedType) -> Type: ...
    def visit_deleted_type(self, t: DeletedType) -> Type: ...
    def visit_erased_type(self, t: ErasedType) -> Type: ...
    def visit_instance(self, t: Instance) -> Type: ...
    def visit_type_var(self, t: TypeVarType) -> Type: ...
    def visit_param_spec(self, t: ParamSpecType) -> Type: ...
    def visit_type_var_tuple(self, t: TypeVarTupleType) -> Type: ...
    def visit_unpack_type(self, t: UnpackType) -> Type: ...
    def expand_unpack(self, t: UnpackType) -> list[Type] | Instance | AnyType | None: ...
    def visit_parameters(self, t: Parameters) -> Type: ...
    def interpolate_args_for_unpack(self, t: CallableType, var_arg: UnpackType) -> tuple[list[str | None], list[ArgKind], list[Type]]: ...
    def visit_callable_type(self, t: CallableType) -> CallableType: ...
    def visit_overloaded(self, t: Overloaded) -> Type: ...
    def expand_types_with_unpack(self, typs: Sequence[Type]) -> list[Type] | AnyType | UninhabitedType | Instance:
        """Expands a list of types that has an unpack.

        In corner cases, this can return a type rather than a list, in which case this
        indicates use of Any or some error occurred earlier. In this case callers should
        simply propagate the resulting type.
        """
    def visit_tuple_type(self, t: TupleType) -> Type: ...
    def visit_typeddict_type(self, t: TypedDictType) -> Type: ...
    def visit_literal_type(self, t: LiteralType) -> Type: ...
    def visit_union_type(self, t: UnionType) -> Type: ...
    def visit_partial_type(self, t: PartialType) -> Type: ...
    def visit_type_type(self, t: TypeType) -> Type: ...
    def visit_type_alias_type(self, t: TypeAliasType) -> Type: ...
    def expand_types(self, types: Iterable[Type]) -> list[Type]: ...

def expand_unpack_with_variables(t: UnpackType, variables: Mapping[TypeVarId, Type]) -> list[Type] | Instance | AnyType | None:
    """May return either a list of types to unpack to, any, or a single
    variable length tuple. The latter may not be valid in all contexts.
    """
@overload
def expand_self_type(var: Var, typ: ProperType, replacement: ProperType) -> ProperType: ...
@overload
def expand_self_type(var: Var, typ: Type, replacement: Type) -> Type: ...
def remove_trivial(types: Iterable[Type]) -> list[Type]:
    """Make trivial simplifications on a list of types without calling is_subtype().

    This makes following simplifications:
        * Remove bottom types (taking into account strict optional setting)
        * Remove everything else if there is an `object`
        * Remove strict duplicate types
    """
