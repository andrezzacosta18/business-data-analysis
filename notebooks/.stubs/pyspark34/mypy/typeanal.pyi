from _typeshed import Incomplete
from mypy import message_registry as message_registry, nodes as nodes
from mypy.errorcodes import ErrorCode as ErrorCode
from mypy.messages import MessageBuilder as MessageBuilder, format_type_bare as format_type_bare, quote_type_string as quote_type_string, wrong_type_arg_count as wrong_type_arg_count
from mypy.nodes import ARG_NAMED as ARG_NAMED, ARG_NAMED_OPT as ARG_NAMED_OPT, ARG_OPT as ARG_OPT, ARG_POS as ARG_POS, ARG_STAR as ARG_STAR, ARG_STAR2 as ARG_STAR2, ArgKind as ArgKind, Context as Context, Decorator as Decorator, MypyFile as MypyFile, ParamSpecExpr as ParamSpecExpr, PlaceholderNode as PlaceholderNode, SYMBOL_FUNCBASE_TYPES as SYMBOL_FUNCBASE_TYPES, SymbolTableNode as SymbolTableNode, TypeAlias as TypeAlias, TypeInfo as TypeInfo, TypeVarExpr as TypeVarExpr, TypeVarLikeExpr as TypeVarLikeExpr, TypeVarTupleExpr as TypeVarTupleExpr, Var as Var, check_arg_kinds as check_arg_kinds, check_arg_names as check_arg_names, get_nongen_builtins as get_nongen_builtins
from mypy.options import Options as Options, UNPACK as UNPACK
from mypy.plugin import AnalyzeTypeContext as AnalyzeTypeContext, Plugin as Plugin, TypeAnalyzerPluginInterface as TypeAnalyzerPluginInterface
from mypy.semanal_shared import SemanticAnalyzerCoreInterface as SemanticAnalyzerCoreInterface, paramspec_args as paramspec_args, paramspec_kwargs as paramspec_kwargs
from mypy.tvar_scope import TypeVarLikeScope as TypeVarLikeScope
from mypy.types import ANNOTATED_TYPE_NAMES as ANNOTATED_TYPE_NAMES, ANY_STRATEGY as ANY_STRATEGY, AnyType as AnyType, BoolTypeQuery as BoolTypeQuery, CallableArgument as CallableArgument, CallableType as CallableType, DeletedType as DeletedType, EllipsisType as EllipsisType, ErasedType as ErasedType, FINAL_TYPE_NAMES as FINAL_TYPE_NAMES, Instance as Instance, LITERAL_TYPE_NAMES as LITERAL_TYPE_NAMES, LiteralType as LiteralType, NEVER_NAMES as NEVER_NAMES, NoneType as NoneType, Overloaded as Overloaded, ParamSpecFlavor as ParamSpecFlavor, ParamSpecType as ParamSpecType, Parameters as Parameters, PartialType as PartialType, PlaceholderType as PlaceholderType, RawExpressionType as RawExpressionType, RequiredType as RequiredType, SyntheticTypeVisitor as SyntheticTypeVisitor, TYPE_ALIAS_NAMES as TYPE_ALIAS_NAMES, TrivialSyntheticTypeTranslator as TrivialSyntheticTypeTranslator, TupleType as TupleType, Type as Type, TypeAliasType as TypeAliasType, TypeList as TypeList, TypeOfAny as TypeOfAny, TypeQuery as TypeQuery, TypeType as TypeType, TypeVarLikeType as TypeVarLikeType, TypeVarTupleType as TypeVarTupleType, TypeVarType as TypeVarType, TypedDictType as TypedDictType, UnboundType as UnboundType, UninhabitedType as UninhabitedType, UnionType as UnionType, UnpackType as UnpackType, callable_with_ellipsis as callable_with_ellipsis, flatten_nested_unions as flatten_nested_unions, get_proper_type as get_proper_type, has_type_vars as has_type_vars
from mypy.types_utils import is_bad_type_type_item as is_bad_type_type_item
from mypy.typetraverser import TypeTraverserVisitor as TypeTraverserVisitor
from mypy.typevars import fill_typevars as fill_typevars
from typing import Callable, Iterable, Iterator, List, Sequence, Tuple, TypeVar
from typing_extensions import Final, Protocol

T = TypeVar('T')
type_constructors: Final[Incomplete]
ARG_KINDS_BY_CONSTRUCTOR: Final[Incomplete]
GENERIC_STUB_NOT_AT_RUNTIME_TYPES: Final[Incomplete]
SELF_TYPE_NAMES: Final[Incomplete]

def analyze_type_alias(type: Type, api: SemanticAnalyzerCoreInterface, tvar_scope: TypeVarLikeScope, plugin: Plugin, options: Options, is_typeshed_stub: bool, allow_placeholder: bool = False, in_dynamic_func: bool = False, global_scope: bool = True, allowed_alias_tvars: list[TypeVarLikeType] | None = None) -> tuple[Type, set[str]]:
    """Analyze r.h.s. of a (potential) type alias definition.

    If `node` is valid as a type alias rvalue, return the resulting type and a set of
    full names of type aliases it depends on (directly or indirectly).
    'node' must have been semantically analyzed.
    """
def no_subscript_builtin_alias(name: str, propose_alt: bool = True) -> str: ...

class TypeAnalyser(SyntheticTypeVisitor[Type], TypeAnalyzerPluginInterface):
    """Semantic analyzer for types.

    Converts unbound types into bound types. This is a no-op for already
    bound types.

    If an incomplete reference is encountered, this does a defer. The
    caller never needs to defer.
    """
    in_dynamic_func: bool
    global_scope: bool
    api: Incomplete
    fail_func: Incomplete
    note_func: Incomplete
    tvar_scope: Incomplete
    defining_alias: Incomplete
    allow_tuple_literal: Incomplete
    nesting_level: int
    always_allow_new_syntax: Incomplete
    allow_unbound_tvars: Incomplete
    allowed_alias_tvars: Incomplete
    allow_placeholder: Incomplete
    allow_required: Incomplete
    allow_param_spec_literals: Incomplete
    report_invalid_types: Incomplete
    plugin: Incomplete
    options: Incomplete
    is_typeshed_stub: Incomplete
    aliases_used: Incomplete
    prohibit_self_type: Incomplete
    allow_type_any: Incomplete
    def __init__(self, api: SemanticAnalyzerCoreInterface, tvar_scope: TypeVarLikeScope, plugin: Plugin, options: Options, is_typeshed_stub: bool, *, defining_alias: bool = False, allow_tuple_literal: bool = False, allow_unbound_tvars: bool = False, allow_placeholder: bool = False, allow_required: bool = False, allow_param_spec_literals: bool = False, report_invalid_types: bool = True, prohibit_self_type: str | None = None, allowed_alias_tvars: list[TypeVarLikeType] | None = None, allow_type_any: bool = False) -> None: ...
    def lookup_qualified(self, name: str, ctx: Context, suppress_errors: bool = False) -> SymbolTableNode | None: ...
    def lookup_fully_qualified(self, name: str) -> SymbolTableNode: ...
    def visit_unbound_type(self, t: UnboundType, defining_literal: bool = False) -> Type: ...
    def visit_unbound_type_nonoptional(self, t: UnboundType, defining_literal: bool) -> Type: ...
    def pack_paramspec_args(self, an_args: Sequence[Type]) -> list[Type]: ...
    def cannot_resolve_type(self, t: UnboundType) -> None: ...
    def apply_concatenate_operator(self, t: UnboundType) -> Type: ...
    def try_analyze_special_unbound_type(self, t: UnboundType, fullname: str) -> Type | None:
        """Bind special type that is recognized through magic name such as 'typing.Any'.

        Return the bound type if successful, and return None if the type is a normal type.
        """
    def get_omitted_any(self, typ: Type, fullname: str | None = None) -> AnyType: ...
    def analyze_type_with_type_info(self, info: TypeInfo, args: Sequence[Type], ctx: Context) -> Type:
        """Bind unbound type when were able to find target TypeInfo.

        This handles simple cases like 'int', 'modname.UserClass[str]', etc.
        """
    def analyze_unbound_type_without_type_info(self, t: UnboundType, sym: SymbolTableNode, defining_literal: bool) -> Type:
        """Figure out what an unbound type that doesn't refer to a TypeInfo node means.

        This is something unusual. We try our best to find out what it is.
        """
    def visit_any(self, t: AnyType) -> Type: ...
    def visit_none_type(self, t: None) -> Type: ...
    def visit_uninhabited_type(self, t: UninhabitedType) -> Type: ...
    def visit_erased_type(self, t: ErasedType) -> Type: ...
    def visit_deleted_type(self, t: DeletedType) -> Type: ...
    def visit_type_list(self, t: TypeList) -> Type: ...
    def visit_callable_argument(self, t: CallableArgument) -> Type: ...
    def visit_instance(self, t: Instance) -> Type: ...
    def visit_type_alias_type(self, t: TypeAliasType) -> Type: ...
    def visit_type_var(self, t: TypeVarType) -> Type: ...
    def visit_param_spec(self, t: ParamSpecType) -> Type: ...
    def visit_type_var_tuple(self, t: TypeVarTupleType) -> Type: ...
    def visit_unpack_type(self, t: UnpackType) -> Type: ...
    def visit_parameters(self, t: Parameters) -> Type: ...
    def visit_callable_type(self, t: CallableType, nested: bool = True) -> Type: ...
    def anal_type_guard(self, t: Type) -> Type | None: ...
    def anal_type_guard_arg(self, t: UnboundType, fullname: str) -> Type | None: ...
    def anal_star_arg_type(self, t: Type, kind: ArgKind, nested: bool) -> Type:
        """Analyze signature argument type for *args and **kwargs argument."""
    def visit_overloaded(self, t: Overloaded) -> Type: ...
    def visit_tuple_type(self, t: TupleType) -> Type: ...
    def visit_typeddict_type(self, t: TypedDictType) -> Type: ...
    def visit_raw_expression_type(self, t: RawExpressionType) -> Type: ...
    def visit_literal_type(self, t: LiteralType) -> Type: ...
    def visit_union_type(self, t: UnionType) -> Type: ...
    def visit_partial_type(self, t: PartialType) -> Type: ...
    def visit_ellipsis_type(self, t: EllipsisType) -> Type: ...
    def visit_type_type(self, t: TypeType) -> Type: ...
    def visit_placeholder_type(self, t: PlaceholderType) -> Type: ...
    def analyze_callable_args_for_paramspec(self, callable_args: Type, ret_type: Type, fallback: Instance) -> CallableType | None:
        """Construct a 'Callable[P, RET]', where P is ParamSpec, return None if we cannot."""
    def analyze_callable_args_for_concatenate(self, callable_args: Type, ret_type: Type, fallback: Instance) -> CallableType | None:
        """Construct a 'Callable[C, RET]', where C is Concatenate[..., P], returning None if we
        cannot.
        """
    def analyze_callable_type(self, t: UnboundType) -> Type: ...
    def analyze_callable_args(self, arglist: TypeList) -> tuple[list[Type], list[ArgKind], list[str | None]] | None: ...
    def analyze_literal_type(self, t: UnboundType) -> Type: ...
    def analyze_literal_param(self, idx: int, arg: Type, ctx: Context) -> list[Type] | None: ...
    def analyze_type(self, t: Type) -> Type: ...
    def fail(self, msg: str, ctx: Context, *, code: ErrorCode | None = None) -> None: ...
    def note(self, msg: str, ctx: Context, *, code: ErrorCode | None = None) -> None: ...
    def tvar_scope_frame(self) -> Iterator[None]: ...
    def find_type_var_likes(self, t: Type, include_callables: bool = True) -> TypeVarLikeList: ...
    def infer_type_variables(self, type: CallableType) -> list[tuple[str, TypeVarLikeExpr]]:
        """Return list of unique type variables referred to in a callable."""
    def bind_function_type_variables(self, fun_type: CallableType, defn: Context) -> tuple[Sequence[TypeVarLikeType], bool]:
        """Find the type variables of the function type and bind them in our tvar_scope"""
    def is_defined_type_var(self, tvar: str, context: Context) -> bool: ...
    def anal_array(self, a: Iterable[Type], nested: bool = True, *, allow_param_spec: bool = False, allow_param_spec_literals: bool = False) -> list[Type]: ...
    def anal_type(self, t: Type, nested: bool = True, *, allow_param_spec: bool = False) -> Type: ...
    def anal_var_def(self, var_def: TypeVarLikeType) -> TypeVarLikeType: ...
    def anal_var_defs(self, var_defs: Sequence[TypeVarLikeType]) -> list[TypeVarLikeType]: ...
    def named_type(self, fully_qualified_name: str, args: list[Type] | None = None, line: int = -1, column: int = -1) -> Instance: ...
    def check_unpacks_in_list(self, items: list[Type]) -> list[Type]: ...
    def tuple_type(self, items: list[Type]) -> TupleType: ...
TypeVarLikeList = List[Tuple[str, TypeVarLikeExpr]]

class MsgCallback(Protocol):
    def __call__(self, __msg: str, __ctx: Context, *, code: ErrorCode | None = None) -> None: ...

def get_omitted_any(disallow_any: bool, fail: MsgCallback, note: MsgCallback, orig_type: Type, options: Options, fullname: str | None = None, unexpanded_type: Type | None = None) -> AnyType: ...
def fix_type_var_tuple_argument(any_type: Type, t: Instance) -> None: ...
def fix_instance(t: Instance, fail: MsgCallback, note: MsgCallback, disallow_any: bool, options: Options, use_generic_error: bool = False, unexpanded_type: Type | None = None) -> None:
    """Fix a malformed instance by replacing all type arguments with Any.

    Also emit a suitable error if this is not due to implicit Any's.
    """
def instantiate_type_alias(node: TypeAlias, args: list[Type], fail: MsgCallback, no_args: bool, ctx: Context, options: Options, *, unexpanded_type: Type | None = None, disallow_any: bool = False, use_standard_error: bool = False, empty_tuple_index: bool = False) -> Type:
    """Create an instance of a (generic) type alias from alias node and type arguments.

    We are following the rules outlined in TypeAlias docstring.
    Here:
        node: type alias node (definition)
        args: type arguments (types to be substituted in place of type variables
              when expanding the alias)
        fail: error reporter callback
        no_args: whether original definition used a bare generic `A = List`
        ctx: context where expansion happens
        unexpanded_type, disallow_any, use_standard_error: used to customize error messages
    """
def set_any_tvars(node: TypeAlias, newline: int, newcolumn: int, options: Options, *, from_error: bool = False, disallow_any: bool = False, fail: MsgCallback | None = None, unexpanded_type: Type | None = None) -> TypeAliasType: ...
def remove_dups(tvars: list[T]) -> list[T]: ...
def flatten_tvars(lists: list[list[T]]) -> list[T]: ...

class TypeVarLikeQuery(TypeQuery[TypeVarLikeList]):
    """Find TypeVar and ParamSpec references in an unbound type."""
    api: Incomplete
    scope: Incomplete
    include_callables: Incomplete
    skip_alias_target: bool
    def __init__(self, api: SemanticAnalyzerCoreInterface, scope: TypeVarLikeScope, *, include_callables: bool = True) -> None: ...
    def visit_unbound_type(self, t: UnboundType) -> TypeVarLikeList: ...
    def visit_callable_type(self, t: CallableType) -> TypeVarLikeList: ...

class DivergingAliasDetector(TrivialSyntheticTypeTranslator):
    """See docstring of detect_diverging_alias() for details."""
    seen_nodes: Incomplete
    lookup: Incomplete
    scope: Incomplete
    diverging: bool
    def __init__(self, seen_nodes: set[TypeAlias], lookup: Callable[[str, Context], SymbolTableNode | None], scope: TypeVarLikeScope) -> None: ...
    def visit_type_alias_type(self, t: TypeAliasType) -> Type: ...

def detect_diverging_alias(node: TypeAlias, target: Type, lookup: Callable[[str, Context], SymbolTableNode | None], scope: TypeVarLikeScope) -> bool:
    """This detects type aliases that will diverge during type checking.

    For example F = Something[..., F[List[T]]]. At each expansion step this will produce
    *new* type aliases: e.g. F[List[int]], F[List[List[int]]], etc. So we can't detect
    recursion. It is a known problem in the literature, recursive aliases and generic types
    don't always go well together. It looks like there is no known systematic solution yet.

    # TODO: should we handle such aliases using type_recursion counter and some large limit?
    They may be handy in rare cases, e.g. to express a union of non-mixed nested lists:
    Nested = Union[T, Nested[List[T]]] ~> Union[T, List[T], List[List[T]], ...]
    """
def check_for_explicit_any(typ: Type | None, options: Options, is_typeshed_stub: bool, msg: MessageBuilder, context: Context) -> None: ...
def has_explicit_any(t: Type) -> bool:
    """
    Whether this type is or type it contains is an Any coming from explicit type annotation
    """

class HasExplicitAny(TypeQuery[bool]):
    def __init__(self) -> None: ...
    def visit_any(self, t: AnyType) -> bool: ...
    def visit_typeddict_type(self, t: TypedDictType) -> bool: ...

def has_any_from_unimported_type(t: Type) -> bool:
    """Return true if this type is Any because an import was not followed.

    If type t is such Any type or has type arguments that contain such Any type
    this function will return true.
    """

class HasAnyFromUnimportedType(BoolTypeQuery):
    def __init__(self) -> None: ...
    def visit_any(self, t: AnyType) -> bool: ...
    def visit_typeddict_type(self, t: TypedDictType) -> bool: ...

def collect_all_inner_types(t: Type) -> list[Type]:
    """
    Return all types that `t` contains
    """

class CollectAllInnerTypesQuery(TypeQuery[List[Type]]):
    def __init__(self) -> None: ...
    def query_types(self, types: Iterable[Type]) -> list[Type]: ...
    @classmethod
    def combine_lists_strategy(cls, it: Iterable[list[Type]]) -> list[Type]: ...

def make_optional_type(t: Type) -> Type:
    """Return the type corresponding to Optional[t].

    Note that we can't use normal union simplification, since this function
    is called during semantic analysis and simplification only works during
    type checking.
    """
def fix_instance_types(t: Type, fail: MsgCallback, note: MsgCallback, options: Options) -> None:
    """Recursively fix all instance types (type argument count) in a given type.

    For example 'Union[Dict, List[str, int]]' will be transformed into
    'Union[Dict[Any, Any], List[Any]]' in place.
    """

class InstanceFixer(TypeTraverserVisitor):
    fail: Incomplete
    note: Incomplete
    options: Incomplete
    def __init__(self, fail: MsgCallback, note: MsgCallback, options: Options) -> None: ...
    def visit_instance(self, typ: Instance) -> None: ...

def find_self_type(typ: Type, lookup: Callable[[str], SymbolTableNode | None]) -> bool: ...

class HasSelfType(BoolTypeQuery):
    lookup: Incomplete
    def __init__(self, lookup: Callable[[str], SymbolTableNode | None]) -> None: ...
    def visit_unbound_type(self, t: UnboundType) -> bool: ...
