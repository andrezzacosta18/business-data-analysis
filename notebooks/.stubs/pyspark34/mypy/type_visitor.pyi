import abc
from _typeshed import Incomplete
from abc import abstractmethod
from mypy.types import AnyType as AnyType, CallableArgument as CallableArgument, CallableType as CallableType, DeletedType as DeletedType, EllipsisType as EllipsisType, ErasedType as ErasedType, Instance as Instance, LiteralType as LiteralType, NoneType as NoneType, Overloaded as Overloaded, ParamSpecType as ParamSpecType, Parameters as Parameters, PartialType as PartialType, PlaceholderType as PlaceholderType, RawExpressionType as RawExpressionType, TupleType as TupleType, Type as Type, TypeAliasType as TypeAliasType, TypeList as TypeList, TypeType as TypeType, TypeVarLikeType as TypeVarLikeType, TypeVarTupleType as TypeVarTupleType, TypeVarType as TypeVarType, TypedDictType as TypedDictType, UnboundType as UnboundType, UninhabitedType as UninhabitedType, UnionType as UnionType, UnpackType as UnpackType, get_proper_type as get_proper_type
from typing import Callable, Generic, Iterable, Sequence, TypeVar
from typing_extensions import Final

T = TypeVar('T')

class TypeVisitor(Generic[T], metaclass=abc.ABCMeta):
    """Visitor class for types (Type subclasses).

    The parameter T is the return type of the visit methods.
    """
    @abstractmethod
    def visit_unbound_type(self, t: UnboundType) -> T: ...
    @abstractmethod
    def visit_any(self, t: AnyType) -> T: ...
    @abstractmethod
    def visit_none_type(self, t: None) -> T: ...
    @abstractmethod
    def visit_uninhabited_type(self, t: UninhabitedType) -> T: ...
    @abstractmethod
    def visit_erased_type(self, t: ErasedType) -> T: ...
    @abstractmethod
    def visit_deleted_type(self, t: DeletedType) -> T: ...
    @abstractmethod
    def visit_type_var(self, t: TypeVarType) -> T: ...
    @abstractmethod
    def visit_param_spec(self, t: ParamSpecType) -> T: ...
    @abstractmethod
    def visit_parameters(self, t: Parameters) -> T: ...
    @abstractmethod
    def visit_type_var_tuple(self, t: TypeVarTupleType) -> T: ...
    @abstractmethod
    def visit_instance(self, t: Instance) -> T: ...
    @abstractmethod
    def visit_callable_type(self, t: CallableType) -> T: ...
    @abstractmethod
    def visit_overloaded(self, t: Overloaded) -> T: ...
    @abstractmethod
    def visit_tuple_type(self, t: TupleType) -> T: ...
    @abstractmethod
    def visit_typeddict_type(self, t: TypedDictType) -> T: ...
    @abstractmethod
    def visit_literal_type(self, t: LiteralType) -> T: ...
    @abstractmethod
    def visit_union_type(self, t: UnionType) -> T: ...
    @abstractmethod
    def visit_partial_type(self, t: PartialType) -> T: ...
    @abstractmethod
    def visit_type_type(self, t: TypeType) -> T: ...
    @abstractmethod
    def visit_type_alias_type(self, t: TypeAliasType) -> T: ...
    @abstractmethod
    def visit_unpack_type(self, t: UnpackType) -> T: ...

class SyntheticTypeVisitor(TypeVisitor[T], metaclass=abc.ABCMeta):
    """A TypeVisitor that also knows how to visit synthetic AST constructs.

    Not just real types.
    """
    @abstractmethod
    def visit_type_list(self, t: TypeList) -> T: ...
    @abstractmethod
    def visit_callable_argument(self, t: CallableArgument) -> T: ...
    @abstractmethod
    def visit_ellipsis_type(self, t: EllipsisType) -> T: ...
    @abstractmethod
    def visit_raw_expression_type(self, t: RawExpressionType) -> T: ...
    @abstractmethod
    def visit_placeholder_type(self, t: PlaceholderType) -> T: ...

class TypeTranslator(TypeVisitor[Type], metaclass=abc.ABCMeta):
    """Identity type transformation.

    Subclass this and override some methods to implement a non-trivial
    transformation.
    """
    def visit_unbound_type(self, t: UnboundType) -> Type: ...
    def visit_any(self, t: AnyType) -> Type: ...
    def visit_none_type(self, t: None) -> Type: ...
    def visit_uninhabited_type(self, t: UninhabitedType) -> Type: ...
    def visit_erased_type(self, t: ErasedType) -> Type: ...
    def visit_deleted_type(self, t: DeletedType) -> Type: ...
    def visit_instance(self, t: Instance) -> Type: ...
    def visit_type_var(self, t: TypeVarType) -> Type: ...
    def visit_param_spec(self, t: ParamSpecType) -> Type: ...
    def visit_parameters(self, t: Parameters) -> Type: ...
    def visit_type_var_tuple(self, t: TypeVarTupleType) -> Type: ...
    def visit_partial_type(self, t: PartialType) -> Type: ...
    def visit_unpack_type(self, t: UnpackType) -> Type: ...
    def visit_callable_type(self, t: CallableType) -> Type: ...
    def visit_tuple_type(self, t: TupleType) -> Type: ...
    def visit_typeddict_type(self, t: TypedDictType) -> Type: ...
    def visit_literal_type(self, t: LiteralType) -> Type: ...
    def visit_union_type(self, t: UnionType) -> Type: ...
    def translate_types(self, types: Iterable[Type]) -> list[Type]: ...
    def translate_variables(self, variables: Sequence[TypeVarLikeType]) -> Sequence[TypeVarLikeType]: ...
    def visit_overloaded(self, t: Overloaded) -> Type: ...
    def visit_type_type(self, t: TypeType) -> Type: ...
    @abstractmethod
    def visit_type_alias_type(self, t: TypeAliasType) -> Type: ...

class TypeQuery(SyntheticTypeVisitor[T]):
    """Visitor for performing queries of types.

    strategy is used to combine results for a series of types,
    common use cases involve a boolean query using `any` or `all`.

    Note: this visitor keeps an internal state (tracks type aliases to avoid
    recursion), so it should *never* be re-used for querying different types,
    create a new visitor instance instead.

    # TODO: check that we don't have existing violations of this rule.
    """
    strategy: Incomplete
    seen_aliases: Incomplete
    skip_alias_target: bool
    def __init__(self, strategy: Callable[[list[T]], T]) -> None: ...
    def visit_unbound_type(self, t: UnboundType) -> T: ...
    def visit_type_list(self, t: TypeList) -> T: ...
    def visit_callable_argument(self, t: CallableArgument) -> T: ...
    def visit_any(self, t: AnyType) -> T: ...
    def visit_uninhabited_type(self, t: UninhabitedType) -> T: ...
    def visit_none_type(self, t: None) -> T: ...
    def visit_erased_type(self, t: ErasedType) -> T: ...
    def visit_deleted_type(self, t: DeletedType) -> T: ...
    def visit_type_var(self, t: TypeVarType) -> T: ...
    def visit_param_spec(self, t: ParamSpecType) -> T: ...
    def visit_type_var_tuple(self, t: TypeVarTupleType) -> T: ...
    def visit_unpack_type(self, t: UnpackType) -> T: ...
    def visit_parameters(self, t: Parameters) -> T: ...
    def visit_partial_type(self, t: PartialType) -> T: ...
    def visit_instance(self, t: Instance) -> T: ...
    def visit_callable_type(self, t: CallableType) -> T: ...
    def visit_tuple_type(self, t: TupleType) -> T: ...
    def visit_typeddict_type(self, t: TypedDictType) -> T: ...
    def visit_raw_expression_type(self, t: RawExpressionType) -> T: ...
    def visit_literal_type(self, t: LiteralType) -> T: ...
    def visit_union_type(self, t: UnionType) -> T: ...
    def visit_overloaded(self, t: Overloaded) -> T: ...
    def visit_type_type(self, t: TypeType) -> T: ...
    def visit_ellipsis_type(self, t: EllipsisType) -> T: ...
    def visit_placeholder_type(self, t: PlaceholderType) -> T: ...
    def visit_type_alias_type(self, t: TypeAliasType) -> T: ...
    def query_types(self, types: Iterable[Type]) -> T:
        """Perform a query for a list of types using the strategy to combine the results."""

ANY_STRATEGY: Final[int]
ALL_STRATEGY: Final[int]

class BoolTypeQuery(SyntheticTypeVisitor[bool]):
    """Visitor for performing recursive queries of types with a bool result.

    Use TypeQuery if you need non-bool results.

    'strategy' is used to combine results for a series of types. It must
    be ANY_STRATEGY or ALL_STRATEGY.

    Note: This visitor keeps an internal state (tracks type aliases to avoid
    recursion), so it should *never* be re-used for querying different types
    unless you call reset() first.
    """
    strategy: Incomplete
    default: bool
    seen_aliases: Incomplete
    skip_alias_target: bool
    def __init__(self, strategy: int) -> None: ...
    def reset(self) -> None:
        """Clear mutable state (but preserve strategy).

        This *must* be called if you want to reuse the visitor.
        """
    def visit_unbound_type(self, t: UnboundType) -> bool: ...
    def visit_type_list(self, t: TypeList) -> bool: ...
    def visit_callable_argument(self, t: CallableArgument) -> bool: ...
    def visit_any(self, t: AnyType) -> bool: ...
    def visit_uninhabited_type(self, t: UninhabitedType) -> bool: ...
    def visit_none_type(self, t: None) -> bool: ...
    def visit_erased_type(self, t: ErasedType) -> bool: ...
    def visit_deleted_type(self, t: DeletedType) -> bool: ...
    def visit_type_var(self, t: TypeVarType) -> bool: ...
    def visit_param_spec(self, t: ParamSpecType) -> bool: ...
    def visit_type_var_tuple(self, t: TypeVarTupleType) -> bool: ...
    def visit_unpack_type(self, t: UnpackType) -> bool: ...
    def visit_parameters(self, t: Parameters) -> bool: ...
    def visit_partial_type(self, t: PartialType) -> bool: ...
    def visit_instance(self, t: Instance) -> bool: ...
    def visit_callable_type(self, t: CallableType) -> bool: ...
    def visit_tuple_type(self, t: TupleType) -> bool: ...
    def visit_typeddict_type(self, t: TypedDictType) -> bool: ...
    def visit_raw_expression_type(self, t: RawExpressionType) -> bool: ...
    def visit_literal_type(self, t: LiteralType) -> bool: ...
    def visit_union_type(self, t: UnionType) -> bool: ...
    def visit_overloaded(self, t: Overloaded) -> bool: ...
    def visit_type_type(self, t: TypeType) -> bool: ...
    def visit_ellipsis_type(self, t: EllipsisType) -> bool: ...
    def visit_placeholder_type(self, t: PlaceholderType) -> bool: ...
    def visit_type_alias_type(self, t: TypeAliasType) -> bool: ...
    def query_types(self, types: list[Type] | tuple[Type, ...]) -> bool:
        """Perform a query for a sequence of types using the strategy to combine the results."""
