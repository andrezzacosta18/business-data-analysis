from _typeshed import Incomplete
from pypika.enums import Arithmetic as Arithmetic, Boolean as Boolean, Comparator as Comparator, Dialects as Dialects, Equality as Equality, JSONOperators as JSONOperators, Matching as Matching, Order as Order
from pypika.queries import QueryBuilder as QueryBuilder, Selectable as Selectable, Table as Table
from pypika.utils import CaseException as CaseException, FunctionException as FunctionException, builder as builder, format_alias_sql as format_alias_sql, format_quotes as format_quotes, ignore_copy as ignore_copy, resolve_is_aggregate as resolve_is_aggregate
from typing import Any, Iterable, Iterator, List, Sequence, Set, Type, TypeVar

NodeT = TypeVar('NodeT', bound='Node')

class Node:
    is_aggregate: Incomplete
    def nodes_(self) -> Iterator[NodeT]: ...
    def find_(self, type: Type[NodeT]) -> List[NodeT]: ...

class Term(Node):
    is_aggregate: bool
    alias: Incomplete
    def __init__(self, alias: str | None = None) -> None: ...
    def as_(self, alias: str) -> Term: ...
    @property
    def tables_(self) -> Set['Table']: ...
    def fields_(self) -> Set['Field']: ...
    @staticmethod
    def wrap_constant(val, wrapper_cls: Type['Term'] | None = None) -> ValueError | NodeT | LiteralValue | Array | Tuple | ValueWrapper:
        """
        Used for wrapping raw inputs such as numbers in Criterions and Operator.

        For example, the expression F('abc')+1 stores the integer part in a ValueWrapper object.

        :param val:
            Any value.
        :param wrapper_cls:
            A pypika class which wraps a constant value so it can be handled as a component of the query.
        :return:
            Raw string, number, or decimal values will be returned in a ValueWrapper.  Fields and other parts of the
            querybuilder will be returned as inputted.

        """
    @staticmethod
    def wrap_json(val: Term | QueryBuilder | Interval | None | str | int | bool, wrapper_cls: Incomplete | None = None) -> Term | QueryBuilder | Interval | NullValue | ValueWrapper | JSON: ...
    def replace_table(self, current_table: Table | None, new_table: Table | None) -> Term:
        """
        Replaces all occurrences of the specified table with the new table. Useful when reusing fields across queries.
        The base implementation returns self because not all terms have a table property.

        :param current_table:
            The table to be replaced.
        :param new_table:
            The table to replace with.
        :return:
            Self.
        """
    def eq(self, other: Any) -> BasicCriterion: ...
    def isnull(self) -> NullCriterion: ...
    def notnull(self) -> Not: ...
    def isnotnull(self) -> NotNullCriterion: ...
    def bitwiseand(self, value: int) -> BitwiseAndCriterion: ...
    def gt(self, other: Any) -> BasicCriterion: ...
    def gte(self, other: Any) -> BasicCriterion: ...
    def lt(self, other: Any) -> BasicCriterion: ...
    def lte(self, other: Any) -> BasicCriterion: ...
    def ne(self, other: Any) -> BasicCriterion: ...
    def glob(self, expr: str) -> BasicCriterion: ...
    def like(self, expr: str) -> BasicCriterion: ...
    def not_like(self, expr: str) -> BasicCriterion: ...
    def ilike(self, expr: str) -> BasicCriterion: ...
    def not_ilike(self, expr: str) -> BasicCriterion: ...
    def rlike(self, expr: str) -> BasicCriterion: ...
    def regex(self, pattern: str) -> BasicCriterion: ...
    def regexp(self, pattern: str) -> BasicCriterion: ...
    def between(self, lower: Any, upper: Any) -> BetweenCriterion: ...
    def from_to(self, start: Any, end: Any) -> PeriodCriterion: ...
    def as_of(self, expr: str) -> BasicCriterion: ...
    def all_(self) -> All: ...
    def isin(self, arg: list | tuple | set | Term) -> ContainsCriterion: ...
    def notin(self, arg: list | tuple | set | Term) -> ContainsCriterion: ...
    def bin_regex(self, pattern: str) -> BasicCriterion: ...
    def negate(self) -> Not: ...
    def lshift(self, other: Any) -> ArithmeticExpression: ...
    def rshift(self, other: Any) -> ArithmeticExpression: ...
    def __invert__(self) -> Not: ...
    def __pos__(self) -> Term: ...
    def __neg__(self) -> Negative: ...
    def __add__(self, other: Any) -> ArithmeticExpression: ...
    def __sub__(self, other: Any) -> ArithmeticExpression: ...
    def __mul__(self, other: Any) -> ArithmeticExpression: ...
    def __truediv__(self, other: Any) -> ArithmeticExpression: ...
    def __pow__(self, other: Any) -> Pow: ...
    def __mod__(self, other: Any) -> Mod: ...
    def __radd__(self, other: Any) -> ArithmeticExpression: ...
    def __rsub__(self, other: Any) -> ArithmeticExpression: ...
    def __rmul__(self, other: Any) -> ArithmeticExpression: ...
    def __rtruediv__(self, other: Any) -> ArithmeticExpression: ...
    def __lshift__(self, other: Any) -> ArithmeticExpression: ...
    def __rshift__(self, other: Any) -> ArithmeticExpression: ...
    def __rlshift__(self, other: Any) -> ArithmeticExpression: ...
    def __rrshift__(self, other: Any) -> ArithmeticExpression: ...
    def __eq__(self, other: Any) -> BasicCriterion: ...
    def __ne__(self, other: Any) -> BasicCriterion: ...
    def __gt__(self, other: Any) -> BasicCriterion: ...
    def __ge__(self, other: Any) -> BasicCriterion: ...
    def __lt__(self, other: Any) -> BasicCriterion: ...
    def __le__(self, other: Any) -> BasicCriterion: ...
    def __getitem__(self, item: slice) -> BetweenCriterion: ...
    def __hash__(self) -> int: ...
    def get_sql(self, **kwargs: Any) -> str: ...

class Parameter(Term):
    is_aggregate: Incomplete
    placeholder: Incomplete
    def __init__(self, placeholder: str | int) -> None: ...
    def get_sql(self, **kwargs: Any) -> str: ...

class QmarkParameter(Parameter):
    """Question mark style, e.g. ...WHERE name=?"""
    def __init__(self) -> None: ...
    def get_sql(self, **kwargs: Any) -> str: ...

class NumericParameter(Parameter):
    """Numeric, positional style, e.g. ...WHERE name=:1"""
    def get_sql(self, **kwargs: Any) -> str: ...

class NamedParameter(Parameter):
    """Named style, e.g. ...WHERE name=:name"""
    def get_sql(self, **kwargs: Any) -> str: ...

class FormatParameter(Parameter):
    """ANSI C printf format codes, e.g. ...WHERE name=%s"""
    def __init__(self) -> None: ...
    def get_sql(self, **kwargs: Any) -> str: ...

class PyformatParameter(Parameter):
    """Python extended format codes, e.g. ...WHERE name=%(name)s"""
    def get_sql(self, **kwargs: Any) -> str: ...

class Negative(Term):
    term: Incomplete
    def __init__(self, term: Term) -> None: ...
    @property
    def is_aggregate(self) -> bool | None: ...
    def get_sql(self, **kwargs: Any) -> str: ...

class ValueWrapper(Term):
    is_aggregate: Incomplete
    value: Incomplete
    def __init__(self, value: Any, alias: str | None = None) -> None: ...
    def get_value_sql(self, **kwargs: Any) -> str: ...
    @classmethod
    def get_formatted_value(cls, value: Any, **kwargs): ...
    def get_sql(self, quote_char: str | None = None, secondary_quote_char: str = "'", **kwargs: Any) -> str: ...

class JSON(Term):
    table: Incomplete
    value: Incomplete
    def __init__(self, value: Any = None, alias: str | None = None) -> None: ...
    def get_sql(self, secondary_quote_char: str = "'", **kwargs: Any) -> str: ...
    def get_json_value(self, key_or_index: str | int) -> BasicCriterion: ...
    def get_text_value(self, key_or_index: str | int) -> BasicCriterion: ...
    def get_path_json_value(self, path_json: str) -> BasicCriterion: ...
    def get_path_text_value(self, path_json: str) -> BasicCriterion: ...
    def has_key(self, other: Any) -> BasicCriterion: ...
    def contains(self, other: Any) -> BasicCriterion: ...
    def contained_by(self, other: Any) -> BasicCriterion: ...
    def has_keys(self, other: Iterable) -> BasicCriterion: ...
    def has_any_keys(self, other: Iterable) -> BasicCriterion: ...

class Values(Term):
    field: Incomplete
    def __init__(self, field: str | Field) -> None: ...
    def get_sql(self, quote_char: str | None = None, **kwargs: Any) -> str: ...

class LiteralValue(Term):
    def __init__(self, value, alias: str | None = None) -> None: ...
    def get_sql(self, **kwargs: Any) -> str: ...

class NullValue(LiteralValue):
    def __init__(self, alias: str | None = None) -> None: ...

class SystemTimeValue(LiteralValue):
    def __init__(self, alias: str | None = None) -> None: ...

class Criterion(Term):
    def __and__(self, other: Any) -> ComplexCriterion: ...
    def __or__(self, other: Any) -> ComplexCriterion: ...
    def __xor__(self, other: Any) -> ComplexCriterion: ...
    @staticmethod
    def any(terms: Iterable[Term] = ()) -> EmptyCriterion: ...
    @staticmethod
    def all(terms: Iterable[Any] = ()) -> EmptyCriterion: ...
    def get_sql(self) -> str: ...

class EmptyCriterion(Criterion):
    is_aggregate: Incomplete
    tables_: Incomplete
    def fields_(self) -> Set['Field']: ...
    def __and__(self, other: Any) -> Any: ...
    def __or__(self, other: Any) -> Any: ...
    def __xor__(self, other: Any) -> Any: ...

class Field(Criterion, JSON):
    name: Incomplete
    table: Incomplete
    def __init__(self, name: str, alias: str | None = None, table: str | Selectable | None = None) -> None: ...
    def nodes_(self) -> Iterator[NodeT]: ...
    def replace_table(self, current_table: Table | None, new_table: Table | None) -> Field:
        """
        Replaces all occurrences of the specified table with the new table. Useful when reusing fields across queries.

        :param current_table:
            The table to be replaced.
        :param new_table:
            The table to replace with.
        :return:
            A copy of the field with the tables replaced.
        """
    def get_sql(self, **kwargs: Any) -> str: ...

class Index(Term):
    name: Incomplete
    def __init__(self, name: str, alias: str | None = None) -> None: ...
    def get_sql(self, quote_char: str | None = None, **kwargs: Any) -> str: ...

class Star(Field):
    def __init__(self, table: str | Selectable | None = None) -> None: ...
    def nodes_(self) -> Iterator[NodeT]: ...
    def get_sql(self, with_alias: bool = False, with_namespace: bool = False, quote_char: str | None = None, **kwargs: Any) -> str: ...

class Tuple(Criterion):
    values: Incomplete
    def __init__(self, *values: Any) -> None: ...
    def nodes_(self) -> Iterator[NodeT]: ...
    def get_sql(self, **kwargs: Any) -> str: ...
    @property
    def is_aggregate(self) -> bool: ...
    def replace_table(self, current_table: Table | None, new_table: Table | None) -> Tuple:
        """
        Replaces all occurrences of the specified table with the new table. Useful when reusing fields across queries.

        :param current_table:
            The table to be replaced.
        :param new_table:
            The table to replace with.
        :return:
            A copy of the field with the tables replaced.
        """

class Array(Tuple):
    def get_sql(self, **kwargs: Any) -> str: ...

class Bracket(Tuple):
    def __init__(self, term: Any) -> None: ...

class NestedCriterion(Criterion):
    left: Incomplete
    comparator: Incomplete
    nested_comparator: Incomplete
    right: Incomplete
    nested: Incomplete
    def __init__(self, comparator: Comparator, nested_comparator: ComplexCriterion, left: Any, right: Any, nested: Any, alias: str | None = None) -> None: ...
    def nodes_(self) -> Iterator[NodeT]: ...
    @property
    def is_aggregate(self) -> bool | None: ...
    def replace_table(self, current_table: Table | None, new_table: Table | None) -> NestedCriterion:
        """
        Replaces all occurrences of the specified table with the new table. Useful when reusing fields across queries.

        :param current_table:
            The table to be replaced.
        :param new_table:
            The table to replace with.
        :return:
            A copy of the criterion with the tables replaced.
        """
    def get_sql(self, with_alias: bool = False, **kwargs: Any) -> str: ...

class BasicCriterion(Criterion):
    comparator: Incomplete
    left: Incomplete
    right: Incomplete
    def __init__(self, comparator: Comparator, left: Term, right: Term, alias: str | None = None) -> None:
        """
        A wrapper for a basic criterion such as equality or inequality. This wraps three parts, a left and right term
        and a comparator which defines the type of comparison.


        :param comparator:
            Type: Comparator
            This defines the type of comparison, such as {quote}={quote} or {quote}>{quote}.
        :param left:
            The term on the left side of the expression.
        :param right:
            The term on the right side of the expression.
        """
    def nodes_(self) -> Iterator[NodeT]: ...
    @property
    def is_aggregate(self) -> bool | None: ...
    def replace_table(self, current_table: Table | None, new_table: Table | None) -> BasicCriterion:
        """
        Replaces all occurrences of the specified table with the new table. Useful when reusing fields across queries.

        :param current_table:
            The table to be replaced.
        :param new_table:
            The table to replace with.
        :return:
            A copy of the criterion with the tables replaced.
        """
    def get_sql(self, quote_char: str = '"', with_alias: bool = False, **kwargs: Any) -> str: ...

class ContainsCriterion(Criterion):
    term: Incomplete
    container: Incomplete
    def __init__(self, term: Any, container: Term, alias: str | None = None) -> None:
        '''
        A wrapper for a "IN" criterion.  This wraps two parts, a term and a container.  The term is the part of the
        expression that is checked for membership in the container.  The container can either be a list or a subquery.


        :param term:
            The term to assert membership for within the container.
        :param container:
            A list or subquery.
        '''
    def nodes_(self) -> Iterator[NodeT]: ...
    @property
    def is_aggregate(self) -> bool | None: ...
    def replace_table(self, current_table: Table | None, new_table: Table | None) -> ContainsCriterion:
        """
        Replaces all occurrences of the specified table with the new table. Useful when reusing fields across queries.

        :param current_table:
            The table to be replaced.
        :param new_table:
            The table to replace with.
        :return:
            A copy of the criterion with the tables replaced.
        """
    def get_sql(self, subquery: Any = None, **kwargs: Any) -> str: ...
    def negate(self) -> ContainsCriterion: ...

class ExistsCriterion(Criterion):
    container: Incomplete
    def __init__(self, container, alias: Incomplete | None = None) -> None: ...
    def get_sql(self, **kwargs): ...
    def negate(self): ...

class RangeCriterion(Criterion):
    term: Incomplete
    start: Incomplete
    end: Incomplete
    def __init__(self, term: Term, start: Any, end: Any, alias: str | None = None) -> None: ...
    def nodes_(self) -> Iterator[NodeT]: ...
    @property
    def is_aggregate(self) -> bool | None: ...

class BetweenCriterion(RangeCriterion):
    term: Incomplete
    def replace_table(self, current_table: Table | None, new_table: Table | None) -> BetweenCriterion:
        """
        Replaces all occurrences of the specified table with the new table. Useful when reusing fields across queries.

        :param current_table:
            The table to be replaced.
        :param new_table:
            The table to replace with.
        :return:
            A copy of the criterion with the tables replaced.
        """
    def get_sql(self, **kwargs: Any) -> str: ...

class PeriodCriterion(RangeCriterion):
    def get_sql(self, **kwargs: Any) -> str: ...

class BitwiseAndCriterion(Criterion):
    term: Incomplete
    value: Incomplete
    def __init__(self, term: Term, value: Any, alias: str | None = None) -> None: ...
    def nodes_(self) -> Iterator[NodeT]: ...
    def replace_table(self, current_table: Table | None, new_table: Table | None) -> BitwiseAndCriterion:
        """
        Replaces all occurrences of the specified table with the new table. Useful when reusing fields across queries.

        :param current_table:
            The table to be replaced.
        :param new_table:
            The table to replace with.
        :return:
            A copy of the criterion with the tables replaced.
        """
    def get_sql(self, **kwargs: Any) -> str: ...

class NullCriterion(Criterion):
    term: Incomplete
    def __init__(self, term: Term, alias: str | None = None) -> None: ...
    def nodes_(self) -> Iterator[NodeT]: ...
    def replace_table(self, current_table: Table | None, new_table: Table | None) -> NullCriterion:
        """
        Replaces all occurrences of the specified table with the new table. Useful when reusing fields across queries.

        :param current_table:
            The table to be replaced.
        :param new_table:
            The table to replace with.
        :return:
            A copy of the criterion with the tables replaced.
        """
    def get_sql(self, with_alias: bool = False, **kwargs: Any) -> str: ...

class NotNullCriterion(NullCriterion):
    def get_sql(self, with_alias: bool = False, **kwargs: Any) -> str: ...

class ComplexCriterion(BasicCriterion):
    def get_sql(self, subcriterion: bool = False, **kwargs: Any) -> str: ...
    def needs_brackets(self, term: Term) -> bool: ...

class ArithmeticExpression(Term):
    """
    Wrapper for an arithmetic function.  Can be simple with two terms or complex with nested terms. Order of operations
    are also preserved.
    """
    add_order: Incomplete
    operator: Incomplete
    left: Incomplete
    right: Incomplete
    def __init__(self, operator: Arithmetic, left: Any, right: Any, alias: str | None = None) -> None:
        """
        Wrapper for an arithmetic expression.

        :param operator:
            Type: Arithmetic
            An operator for the expression such as {quote}+{quote} or {quote}/{quote}

        :param left:
            The term on the left side of the expression.
        :param right:
            The term on the right side of the expression.
        :param alias:
            (Optional) an alias for the term which can be used inside a select statement.
        :return:
        """
    def nodes_(self) -> Iterator[NodeT]: ...
    @property
    def is_aggregate(self) -> bool | None: ...
    def replace_table(self, current_table: Table | None, new_table: Table | None) -> ArithmeticExpression:
        """
        Replaces all occurrences of the specified table with the new table. Useful when reusing fields across queries.

        :param current_table:
            The table to be replaced.
        :param new_table:
            The table to replace with.
        :return:
            A copy of the term with the tables replaced.
        """
    def left_needs_parens(self, curr_op, left_op) -> bool:
        """
        Returns true if the expression on the left of the current operator needs to be enclosed in parentheses.

        :param current_op:
            The current operator.
        :param left_op:
            The highest level operator of the left expression.
        """
    def right_needs_parens(self, curr_op, right_op) -> bool:
        """
        Returns true if the expression on the right of the current operator needs to be enclosed in parentheses.

        :param current_op:
            The current operator.
        :param right_op:
            The highest level operator of the right expression.
        """
    def get_sql(self, with_alias: bool = False, **kwargs: Any) -> str: ...

class Case(Criterion):
    def __init__(self, alias: str | None = None) -> None: ...
    def nodes_(self) -> Iterator[NodeT]: ...
    @property
    def is_aggregate(self) -> bool | None: ...
    def when(self, criterion: Any, term: Any) -> Case: ...
    def replace_table(self, current_table: Table | None, new_table: Table | None) -> Case:
        """
        Replaces all occurrences of the specified table with the new table. Useful when reusing fields across queries.

        :param current_table:
            The table to be replaced.
        :param new_table:
            The table to replace with.
        :return:
            A copy of the term with the tables replaced.
        """
    def else_(self, term: Any) -> Case: ...
    def get_sql(self, with_alias: bool = False, **kwargs: Any) -> str: ...

class Not(Criterion):
    term: Incomplete
    def __init__(self, term: Any, alias: str | None = None) -> None: ...
    def nodes_(self) -> Iterator[NodeT]: ...
    def get_sql(self, **kwargs: Any) -> str: ...
    def __getattr__(self, name: str) -> Any:
        """
        Delegate method calls to the class wrapped by Not().
        Re-wrap methods on child classes of Term (e.g. isin, eg...) to retain 'NOT <term>' output.
        """
    def replace_table(self, current_table: Table | None, new_table: Table | None) -> Not:
        """
        Replaces all occurrences of the specified table with the new table. Useful when reusing fields across queries.

        :param current_table:
            The table to be replaced.
        :param new_table:
            The table to replace with.
        :return:
            A copy of the criterion with the tables replaced.
        """

class All(Criterion):
    term: Incomplete
    def __init__(self, term: Any, alias: str | None = None) -> None: ...
    def nodes_(self) -> Iterator[NodeT]: ...
    def get_sql(self, **kwargs: Any) -> str: ...

class CustomFunction:
    name: Incomplete
    params: Incomplete
    def __init__(self, name: str, params: Sequence | None = None) -> None: ...
    def __call__(self, *args: Any, **kwargs: Any) -> Function: ...

class Function(Criterion):
    name: Incomplete
    args: Incomplete
    schema: Incomplete
    def __init__(self, name: str, *args: Any, **kwargs: Any) -> None: ...
    def nodes_(self) -> Iterator[NodeT]: ...
    @property
    def is_aggregate(self) -> bool | None:
        """
        This is a shortcut that assumes if a function has a single argument and that argument is aggregated, then this
        function is also aggregated. A more sophisticated approach is needed, however it is unclear how that might work.
        :returns:
            True if the function accepts one argument and that argument is aggregate.
        """
    def replace_table(self, current_table: Table | None, new_table: Table | None) -> Function:
        """
        Replaces all occurrences of the specified table with the new table. Useful when reusing fields across queries.

        :param current_table:
            The table to be replaced.
        :param new_table:
            The table to replace with.
        :return:
            A copy of the criterion with the tables replaced.
        """
    def get_special_params_sql(self, **kwargs: Any) -> Any: ...
    @staticmethod
    def get_arg_sql(arg, **kwargs): ...
    def get_function_sql(self, **kwargs: Any) -> str: ...
    def get_sql(self, **kwargs: Any) -> str: ...

class AggregateFunction(Function):
    is_aggregate: bool
    def __init__(self, name, *args, **kwargs) -> None: ...
    def filter(self, *filters: Any) -> AnalyticFunction: ...
    def get_filter_sql(self, **kwargs: Any) -> str: ...
    def get_function_sql(self, **kwargs: Any): ...

class AnalyticFunction(AggregateFunction):
    is_aggregate: bool
    is_analytic: bool
    def __init__(self, name: str, *args: Any, **kwargs: Any) -> None: ...
    def over(self, *terms: Any) -> AnalyticFunction: ...
    def orderby(self, *terms: Any, **kwargs: Any) -> AnalyticFunction: ...
    def get_partition_sql(self, **kwargs: Any) -> str: ...
    def get_function_sql(self, **kwargs: Any) -> str: ...
EdgeT = TypeVar('EdgeT', bound='WindowFrameAnalyticFunction.Edge')

class WindowFrameAnalyticFunction(AnalyticFunction):
    class Edge:
        value: Incomplete
        def __init__(self, value: str | int | None = None) -> None: ...
    frame: Incomplete
    bound: Incomplete
    def __init__(self, name: str, *args: Any, **kwargs: Any) -> None: ...
    def rows(self, bound: str | EdgeT, and_bound: EdgeT | None = None) -> WindowFrameAnalyticFunction: ...
    def range(self, bound: str | EdgeT, and_bound: EdgeT | None = None) -> WindowFrameAnalyticFunction: ...
    def get_frame_sql(self) -> str: ...
    def get_partition_sql(self, **kwargs: Any) -> str: ...

class IgnoreNullsAnalyticFunction(AnalyticFunction):
    def __init__(self, name: str, *args: Any, **kwargs: Any) -> None: ...
    def ignore_nulls(self) -> IgnoreNullsAnalyticFunction: ...
    def get_special_params_sql(self, **kwargs: Any) -> str | None: ...

class Interval(Node):
    templates: Incomplete
    units: Incomplete
    labels: Incomplete
    trim_pattern: Incomplete
    dialect: Incomplete
    largest: Incomplete
    smallest: Incomplete
    is_negative: bool
    quarters: Incomplete
    weeks: Incomplete
    def __init__(self, years: int = 0, months: int = 0, days: int = 0, hours: int = 0, minutes: int = 0, seconds: int = 0, microseconds: int = 0, quarters: int = 0, weeks: int = 0, dialect: Dialects | None = None) -> None: ...
    def get_sql(self, **kwargs: Any) -> str: ...

class Pow(Function):
    def __init__(self, term: Term, exponent: float, alias: str | None = None) -> None: ...

class Mod(Function):
    def __init__(self, term: Term, modulus: float, alias: str | None = None) -> None: ...

class Rollup(Function):
    def __init__(self, *terms: Any) -> None: ...

class PseudoColumn(Term):
    '''
    Represents a pseudo column (a "column" which yields a value when selected
    but is not actually a real table column).
    '''
    name: Incomplete
    def __init__(self, name: str) -> None: ...
    def get_sql(self, **kwargs: Any) -> str: ...

class AtTimezone(Term):
    """
    Generates AT TIME ZONE SQL.
    Examples:
        AT TIME ZONE 'US/Eastern'
        AT TIME ZONE INTERVAL '-06:00'
    """
    is_aggregate: Incomplete
    field: Incomplete
    zone: Incomplete
    interval: Incomplete
    def __init__(self, field, zone, interval: bool = False, alias: Incomplete | None = None) -> None: ...
    def get_sql(self, **kwargs): ...
