import asyncio
import socket
from .. import CapacityLimiterStatistics as CapacityLimiterStatistics, EventStatistics as EventStatistics, TaskInfo as TaskInfo, abc as abc
from .._core._compat import DeprecatedAsyncContextManager as DeprecatedAsyncContextManager, DeprecatedAwaitable as DeprecatedAwaitable
from .._core._eventloop import claim_worker_thread as claim_worker_thread, threadlocals as threadlocals
from .._core._exceptions import BrokenResourceError as BrokenResourceError, BusyResourceError as BusyResourceError, ClosedResourceError as ClosedResourceError, EndOfStream as EndOfStream, ExceptionGroup as BaseExceptionGroup, WouldBlock as WouldBlock
from .._core._sockets import GetAddrInfoReturnType as GetAddrInfoReturnType, convert_ipv6_sockaddr as convert_ipv6_sockaddr
from .._core._synchronization import CapacityLimiter as BaseCapacityLimiter, Event as BaseEvent, ResourceGuard as ResourceGuard
from .._core._tasks import CancelScope as BaseCancelScope
from ..abc import IPSockAddrType as IPSockAddrType, UDPPacketType as UDPPacketType
from ..lowlevel import RunVar as RunVar
from _typeshed import Incomplete
from asyncio import get_running_loop
from collections import deque
from dataclasses import dataclass
from io import IOBase
from os import PathLike
from socket import AddressFamily, SocketKind
from threading import Thread
from types import TracebackType
from typing import Any, AsyncGenerator, Awaitable, Callable, Collection, Coroutine, Generator, IO, Iterable, Mapping, Sequence, TypeVar

def get_coro(task: asyncio.Task) -> Generator | Awaitable[Any]: ...
T_Retval = TypeVar('T_Retval')
T_contra = TypeVar('T_contra', contravariant=True)

def find_root_task() -> asyncio.Task: ...
def get_callable_name(func: Callable) -> str: ...
current_token = get_running_loop

def run(func: Callable[..., Awaitable[T_Retval]], *args: object, debug: bool = False, use_uvloop: bool = False, policy: asyncio.AbstractEventLoopPolicy | None = None) -> T_Retval: ...

sleep: Incomplete
CancelledError = asyncio.CancelledError

class CancelScope(BaseCancelScope):
    def __new__(cls, *, deadline: float = ..., shield: bool = False) -> CancelScope: ...
    def __init__(self, deadline: float = ..., shield: bool = False) -> None: ...
    def __enter__(self) -> CancelScope: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None) -> bool | None: ...
    def cancel(self) -> DeprecatedAwaitable: ...
    @property
    def deadline(self) -> float: ...
    @deadline.setter
    def deadline(self, value: float) -> None: ...
    @property
    def cancel_called(self) -> bool: ...
    @property
    def shield(self) -> bool: ...
    @shield.setter
    def shield(self, value: bool) -> None: ...

async def checkpoint() -> None: ...
async def checkpoint_if_cancelled() -> None: ...
async def cancel_shielded_checkpoint() -> None: ...
def current_effective_deadline() -> float: ...
def current_time() -> float: ...

class TaskState:
    """
    Encapsulates auxiliary task information that cannot be added to the Task instance itself
    because there are no guarantees about its implementation.
    """
    parent_id: Incomplete
    name: Incomplete
    cancel_scope: Incomplete
    def __init__(self, parent_id: int | None, name: str | None, cancel_scope: CancelScope | None) -> None: ...

class ExceptionGroup(BaseExceptionGroup):
    exceptions: Incomplete
    def __init__(self, exceptions: list[BaseException]) -> None: ...

class _AsyncioTaskStatus(abc.TaskStatus):
    def __init__(self, future: asyncio.Future, parent_id: int) -> None: ...
    def started(self, value: T_contra | None = None) -> None: ...

class TaskGroup(abc.TaskGroup):
    cancel_scope: Incomplete
    def __init__(self) -> None: ...
    async def __aenter__(self) -> TaskGroup: ...
    async def __aexit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None) -> bool | None: ...
    def start_soon(self, func: Callable[..., Awaitable[Any]], *args: object, name: object = None) -> None: ...
    async def start(self, func: Callable[..., Awaitable[Any]], *args: object, name: object = None) -> None: ...

class WorkerThread(Thread):
    MAX_IDLE_TIME: int
    root_task: Incomplete
    workers: Incomplete
    idle_workers: Incomplete
    loop: Incomplete
    queue: Incomplete
    idle_since: Incomplete
    stopping: bool
    def __init__(self, root_task: asyncio.Task, workers: set[WorkerThread], idle_workers: deque[WorkerThread]) -> None: ...
    def run(self) -> None: ...
    def stop(self, f: asyncio.Task | None = None) -> None: ...

async def run_sync_in_worker_thread(func: Callable[..., T_Retval], *args: object, cancellable: bool = False, limiter: CapacityLimiter | None = None) -> T_Retval: ...
def run_sync_from_thread(func: Callable[..., T_Retval], *args: object, loop: asyncio.AbstractEventLoop | None = None) -> T_Retval: ...
def run_async_from_thread(func: Callable[..., Awaitable[T_Retval]], *args: object) -> T_Retval: ...

class BlockingPortal(abc.BlockingPortal):
    def __new__(cls) -> BlockingPortal: ...
    def __init__(self) -> None: ...

@dataclass(eq=False)
class StreamReaderWrapper(abc.ByteReceiveStream):
    async def receive(self, max_bytes: int = 65536) -> bytes: ...
    async def aclose(self) -> None: ...
    def __init__(self, _stream) -> None: ...

@dataclass(eq=False)
class StreamWriterWrapper(abc.ByteSendStream):
    async def send(self, item: bytes) -> None: ...
    async def aclose(self) -> None: ...
    def __init__(self, _stream) -> None: ...

@dataclass(eq=False)
class Process(abc.Process):
    async def aclose(self) -> None: ...
    async def wait(self) -> int: ...
    def terminate(self) -> None: ...
    def kill(self) -> None: ...
    def send_signal(self, signal: int) -> None: ...
    @property
    def pid(self) -> int: ...
    @property
    def returncode(self) -> int | None: ...
    @property
    def stdin(self) -> abc.ByteSendStream | None: ...
    @property
    def stdout(self) -> abc.ByteReceiveStream | None: ...
    @property
    def stderr(self) -> abc.ByteReceiveStream | None: ...
    def __init__(self, _process, _stdin, _stdout, _stderr) -> None: ...

async def open_process(command: str | bytes | Sequence[str | bytes], *, shell: bool, stdin: int | IO[Any] | None, stdout: int | IO[Any] | None, stderr: int | IO[Any] | None, cwd: str | bytes | PathLike | None = None, env: Mapping[str, str] | None = None, start_new_session: bool = False) -> Process: ...
def setup_process_pool_exit_at_shutdown(workers: set[Process]) -> None: ...

class StreamProtocol(asyncio.Protocol):
    read_queue: deque[bytes]
    read_event: asyncio.Event
    write_event: asyncio.Event
    exception: Exception | None
    def connection_made(self, transport: asyncio.BaseTransport) -> None: ...
    def connection_lost(self, exc: Exception | None) -> None: ...
    def data_received(self, data: bytes) -> None: ...
    def eof_received(self) -> bool | None: ...
    def pause_writing(self) -> None: ...
    def resume_writing(self) -> None: ...

class DatagramProtocol(asyncio.DatagramProtocol):
    read_queue: deque[tuple[bytes, IPSockAddrType]]
    read_event: asyncio.Event
    write_event: asyncio.Event
    exception: Exception | None
    def connection_made(self, transport: asyncio.BaseTransport) -> None: ...
    def connection_lost(self, exc: Exception | None) -> None: ...
    def datagram_received(self, data: bytes, addr: IPSockAddrType) -> None: ...
    def error_received(self, exc: Exception) -> None: ...
    def pause_writing(self) -> None: ...
    def resume_writing(self) -> None: ...

class SocketStream(abc.SocketStream):
    def __init__(self, transport: asyncio.Transport, protocol: StreamProtocol) -> None: ...
    async def receive(self, max_bytes: int = 65536) -> bytes: ...
    async def send(self, item: bytes) -> None: ...
    async def send_eof(self) -> None: ...
    async def aclose(self) -> None: ...

class UNIXSocketStream(abc.SocketStream):
    def __init__(self, raw_socket: socket.socket) -> None: ...
    async def send_eof(self) -> None: ...
    async def receive(self, max_bytes: int = 65536) -> bytes: ...
    async def send(self, item: bytes) -> None: ...
    async def receive_fds(self, msglen: int, maxfds: int) -> tuple[bytes, list[int]]: ...
    async def send_fds(self, message: bytes, fds: Collection[int | IOBase]) -> None: ...
    async def aclose(self) -> None: ...

class TCPSocketListener(abc.SocketListener):
    def __init__(self, raw_socket: socket.socket) -> None: ...
    async def accept(self) -> abc.SocketStream: ...
    async def aclose(self) -> None: ...

class UNIXSocketListener(abc.SocketListener):
    def __init__(self, raw_socket: socket.socket) -> None: ...
    async def accept(self) -> abc.SocketStream: ...
    async def aclose(self) -> None: ...

class UDPSocket(abc.UDPSocket):
    def __init__(self, transport: asyncio.DatagramTransport, protocol: DatagramProtocol) -> None: ...
    async def aclose(self) -> None: ...
    async def receive(self) -> tuple[bytes, IPSockAddrType]: ...
    async def send(self, item: UDPPacketType) -> None: ...

class ConnectedUDPSocket(abc.ConnectedUDPSocket):
    def __init__(self, transport: asyncio.DatagramTransport, protocol: DatagramProtocol) -> None: ...
    async def aclose(self) -> None: ...
    async def receive(self) -> bytes: ...
    async def send(self, item: bytes) -> None: ...

async def connect_tcp(host: str, port: int, local_addr: tuple[str, int] | None = None) -> SocketStream: ...
async def connect_unix(path: str) -> UNIXSocketStream: ...
async def create_udp_socket(family: socket.AddressFamily, local_address: IPSockAddrType | None, remote_address: IPSockAddrType | None, reuse_port: bool) -> UDPSocket | ConnectedUDPSocket: ...
async def getaddrinfo(host: bytes | str, port: str | int | None, *, family: int | AddressFamily = 0, type: int | SocketKind = 0, proto: int = 0, flags: int = 0) -> GetAddrInfoReturnType: ...
async def getnameinfo(sockaddr: IPSockAddrType, flags: int = 0) -> tuple[str, str]: ...
async def wait_socket_readable(sock: socket.socket) -> None: ...
async def wait_socket_writable(sock: socket.socket) -> None: ...

class Event(BaseEvent):
    def __new__(cls) -> Event: ...
    def __init__(self) -> None: ...
    def set(self) -> DeprecatedAwaitable: ...
    def is_set(self) -> bool: ...
    async def wait(self) -> None: ...
    def statistics(self) -> EventStatistics: ...

class CapacityLimiter(BaseCapacityLimiter):
    def __new__(cls, total_tokens: float) -> CapacityLimiter: ...
    def __init__(self, total_tokens: float) -> None: ...
    async def __aenter__(self) -> None: ...
    async def __aexit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None) -> None: ...
    @property
    def total_tokens(self) -> float: ...
    @total_tokens.setter
    def total_tokens(self, value: float) -> None: ...
    @property
    def borrowed_tokens(self) -> int: ...
    @property
    def available_tokens(self) -> float: ...
    def acquire_nowait(self) -> DeprecatedAwaitable: ...
    def acquire_on_behalf_of_nowait(self, borrower: object) -> DeprecatedAwaitable: ...
    async def acquire(self) -> None: ...
    async def acquire_on_behalf_of(self, borrower: object) -> None: ...
    def release(self) -> None: ...
    def release_on_behalf_of(self, borrower: object) -> None: ...
    def statistics(self) -> CapacityLimiterStatistics: ...

def current_default_thread_limiter() -> CapacityLimiter: ...

class _SignalReceiver(DeprecatedAsyncContextManager['_SignalReceiver']):
    def __init__(self, signals: tuple[int, ...]) -> None: ...
    def __enter__(self) -> _SignalReceiver: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None) -> bool | None: ...
    def __aiter__(self) -> _SignalReceiver: ...
    async def __anext__(self) -> int: ...

def open_signal_receiver(*signals: int) -> _SignalReceiver: ...
def get_current_task() -> TaskInfo: ...
def get_running_tasks() -> list[TaskInfo]: ...
async def wait_all_tasks_blocked() -> None: ...

class TestRunner(abc.TestRunner):
    def __init__(self, debug: bool = False, use_uvloop: bool = False, policy: asyncio.AbstractEventLoopPolicy | None = None) -> None: ...
    def close(self) -> None: ...
    def run_asyncgen_fixture(self, fixture_func: Callable[..., AsyncGenerator[T_Retval, Any]], kwargs: dict[str, Any]) -> Iterable[T_Retval]: ...
    def run_fixture(self, fixture_func: Callable[..., Coroutine[Any, Any, T_Retval]], kwargs: dict[str, Any]) -> T_Retval: ...
    def run_test(self, test_func: Callable[..., Coroutine[Any, Any, Any]], kwargs: dict[str, Any]) -> None: ...
