import socket
import trio
from .. import CapacityLimiterStatistics as CapacityLimiterStatistics, EventStatistics as EventStatistics, TaskInfo as TaskInfo, abc as abc
from .._core._compat import DeprecatedAsyncContextManager as DeprecatedAsyncContextManager, DeprecatedAwaitable as DeprecatedAwaitable
from .._core._eventloop import claim_worker_thread as claim_worker_thread
from .._core._exceptions import BrokenResourceError as BrokenResourceError, BusyResourceError as BusyResourceError, ClosedResourceError as ClosedResourceError, EndOfStream as EndOfStream, ExceptionGroup as BaseExceptionGroup
from .._core._sockets import convert_ipv6_sockaddr as convert_ipv6_sockaddr
from .._core._synchronization import CapacityLimiter as BaseCapacityLimiter, Event as BaseEvent, ResourceGuard as ResourceGuard
from .._core._tasks import CancelScope as BaseCancelScope
from ..abc import IPSockAddrType as IPSockAddrType, UDPPacketType as UDPPacketType
from _typeshed import Incomplete
from dataclasses import dataclass
from io import IOBase
from os import PathLike
from outcome import Outcome as Outcome
from signal import Signals
from trio.socket import SocketType as TrioSocketType
from trio_typing import TaskStatus as TaskStatus
from types import TracebackType
from typing import Any, AsyncGenerator, Awaitable, Callable, Collection, Coroutine, Generic, IO, Iterable, Mapping, Sequence, TypeVar

trio_open_process: Incomplete
T_Retval = TypeVar('T_Retval')
T_SockAddr = TypeVar('T_SockAddr', str, IPSockAddrType)
run: Incomplete
current_token: Incomplete
RunVar: Incomplete
sleep: Incomplete

class CancelScope(BaseCancelScope):
    def __new__(cls, original: trio.CancelScope | None = None, **kwargs: object) -> CancelScope: ...
    def __init__(self, original: trio.CancelScope | None = None, **kwargs: Any) -> None: ...
    def __enter__(self) -> CancelScope: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None) -> bool | None: ...
    def cancel(self) -> DeprecatedAwaitable: ...
    @property
    def deadline(self) -> float: ...
    @deadline.setter
    def deadline(self, value: float) -> None: ...
    @property
    def cancel_called(self) -> bool: ...
    @property
    def shield(self) -> bool: ...
    @shield.setter
    def shield(self, value: bool) -> None: ...

CancelledError: Incomplete
checkpoint: Incomplete
checkpoint_if_cancelled: Incomplete
cancel_shielded_checkpoint: Incomplete
current_effective_deadline: Incomplete
current_time: Incomplete

class ExceptionGroup(BaseExceptionGroup, trio.MultiError): ...

class TaskGroup(abc.TaskGroup):
    cancel_scope: Incomplete
    def __init__(self) -> None: ...
    async def __aenter__(self) -> TaskGroup: ...
    async def __aexit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None) -> bool | None: ...
    def start_soon(self, func: Callable[..., Awaitable[Any]], *args: object, name: object = None) -> None: ...
    async def start(self, func: Callable[..., Awaitable[Any]], *args: object, name: object = None) -> object: ...

async def run_sync_in_worker_thread(func: Callable[..., T_Retval], *args: object, cancellable: bool = False, limiter: trio.CapacityLimiter | None = None) -> T_Retval: ...
def run_async_from_thread(fn: Callable[..., Awaitable[T_Retval]], *args: Any) -> T_Retval: ...
def run_sync_from_thread(fn: Callable[..., T_Retval], *args: Any) -> T_Retval: ...

class BlockingPortal(abc.BlockingPortal):
    def __new__(cls) -> BlockingPortal: ...
    def __init__(self) -> None: ...

@dataclass(eq=False)
class ReceiveStreamWrapper(abc.ByteReceiveStream):
    async def receive(self, max_bytes: int | None = None) -> bytes: ...
    async def aclose(self) -> None: ...
    def __init__(self, _stream) -> None: ...

@dataclass(eq=False)
class SendStreamWrapper(abc.ByteSendStream):
    async def send(self, item: bytes) -> None: ...
    async def aclose(self) -> None: ...
    def __init__(self, _stream) -> None: ...

@dataclass(eq=False)
class Process(abc.Process):
    async def aclose(self) -> None: ...
    async def wait(self) -> int: ...
    def terminate(self) -> None: ...
    def kill(self) -> None: ...
    def send_signal(self, signal: Signals) -> None: ...
    @property
    def pid(self) -> int: ...
    @property
    def returncode(self) -> int | None: ...
    @property
    def stdin(self) -> abc.ByteSendStream | None: ...
    @property
    def stdout(self) -> abc.ByteReceiveStream | None: ...
    @property
    def stderr(self) -> abc.ByteReceiveStream | None: ...
    def __init__(self, _process, _stdin, _stdout, _stderr) -> None: ...

async def open_process(command: str | bytes | Sequence[str | bytes], *, shell: bool, stdin: int | IO[Any] | None, stdout: int | IO[Any] | None, stderr: int | IO[Any] | None, cwd: str | bytes | PathLike | None = None, env: Mapping[str, str] | None = None, start_new_session: bool = False) -> Process: ...

class _ProcessPoolShutdownInstrument(trio.abc.Instrument):
    def after_run(self) -> None: ...

current_default_worker_process_limiter: RunVar

def setup_process_pool_exit_at_shutdown(workers: set[Process]) -> None: ...

class _TrioSocketMixin(Generic[T_SockAddr]):
    def __init__(self, trio_socket: TrioSocketType) -> None: ...
    async def aclose(self) -> None: ...

class SocketStream(_TrioSocketMixin, abc.SocketStream):
    def __init__(self, trio_socket: TrioSocketType) -> None: ...
    async def receive(self, max_bytes: int = 65536) -> bytes: ...
    async def send(self, item: bytes) -> None: ...
    async def send_eof(self) -> None: ...

class UNIXSocketStream(SocketStream, abc.UNIXSocketStream):
    async def receive_fds(self, msglen: int, maxfds: int) -> tuple[bytes, list[int]]: ...
    async def send_fds(self, message: bytes, fds: Collection[int | IOBase]) -> None: ...

class TCPSocketListener(_TrioSocketMixin, abc.SocketListener):
    def __init__(self, raw_socket: socket.socket) -> None: ...
    async def accept(self) -> SocketStream: ...

class UNIXSocketListener(_TrioSocketMixin, abc.SocketListener):
    def __init__(self, raw_socket: socket.socket) -> None: ...
    async def accept(self) -> UNIXSocketStream: ...

class UDPSocket(_TrioSocketMixin[IPSockAddrType], abc.UDPSocket):
    def __init__(self, trio_socket: TrioSocketType) -> None: ...
    async def receive(self) -> tuple[bytes, IPSockAddrType]: ...
    async def send(self, item: UDPPacketType) -> None: ...

class ConnectedUDPSocket(_TrioSocketMixin[IPSockAddrType], abc.ConnectedUDPSocket):
    def __init__(self, trio_socket: TrioSocketType) -> None: ...
    async def receive(self) -> bytes: ...
    async def send(self, item: bytes) -> None: ...

async def connect_tcp(host: str, port: int, local_address: IPSockAddrType | None = None) -> SocketStream: ...
async def connect_unix(path: str) -> UNIXSocketStream: ...
async def create_udp_socket(family: socket.AddressFamily, local_address: IPSockAddrType | None, remote_address: IPSockAddrType | None, reuse_port: bool) -> UDPSocket | ConnectedUDPSocket: ...

getaddrinfo: Incomplete
getnameinfo: Incomplete

async def wait_socket_readable(sock: socket.socket) -> None: ...
async def wait_socket_writable(sock: socket.socket) -> None: ...

class Event(BaseEvent):
    def __new__(cls) -> Event: ...
    def __init__(self) -> None: ...
    def is_set(self) -> bool: ...
    async def wait(self) -> None: ...
    def statistics(self) -> EventStatistics: ...
    def set(self) -> DeprecatedAwaitable: ...

class CapacityLimiter(BaseCapacityLimiter):
    def __new__(cls, *args: object, **kwargs: object) -> CapacityLimiter: ...
    def __init__(self, *args: Any, original: trio.CapacityLimiter | None = None) -> None: ...
    async def __aenter__(self) -> None: ...
    async def __aexit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None) -> None: ...
    @property
    def total_tokens(self) -> float: ...
    @total_tokens.setter
    def total_tokens(self, value: float) -> None: ...
    @property
    def borrowed_tokens(self) -> int: ...
    @property
    def available_tokens(self) -> float: ...
    def acquire_nowait(self) -> DeprecatedAwaitable: ...
    def acquire_on_behalf_of_nowait(self, borrower: object) -> DeprecatedAwaitable: ...
    async def acquire(self) -> None: ...
    async def acquire_on_behalf_of(self, borrower: object) -> None: ...
    def release(self) -> None: ...
    def release_on_behalf_of(self, borrower: object) -> None: ...
    def statistics(self) -> CapacityLimiterStatistics: ...

def current_default_thread_limiter() -> CapacityLimiter: ...

class _SignalReceiver(DeprecatedAsyncContextManager['_SignalReceiver']):
    def __init__(self, signals: tuple[Signals, ...]) -> None: ...
    def __enter__(self) -> _SignalReceiver: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None) -> bool | None: ...
    def __aiter__(self) -> _SignalReceiver: ...
    async def __anext__(self) -> Signals: ...

def open_signal_receiver(*signals: Signals) -> _SignalReceiver: ...
def get_current_task() -> TaskInfo: ...
def get_running_tasks() -> list[TaskInfo]: ...
def wait_all_tasks_blocked() -> Awaitable[None]: ...

class TestRunner(abc.TestRunner):
    def __init__(self, **options: Any) -> None: ...
    def close(self) -> None: ...
    def run_asyncgen_fixture(self, fixture_func: Callable[..., AsyncGenerator[T_Retval, Any]], kwargs: dict[str, Any]) -> Iterable[T_Retval]: ...
    def run_fixture(self, fixture_func: Callable[..., Coroutine[Any, Any, T_Retval]], kwargs: dict[str, Any]) -> T_Retval: ...
    def run_test(self, test_func: Callable[..., Coroutine[Any, Any, Any]], kwargs: dict[str, Any]) -> None: ...
