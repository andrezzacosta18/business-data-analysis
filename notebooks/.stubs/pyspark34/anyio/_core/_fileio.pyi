import os
import pathlib
from .. import to_thread as to_thread
from ..abc import AsyncResource as AsyncResource
from _typeshed import OpenBinaryMode as OpenBinaryMode, OpenTextMode as OpenTextMode, ReadableBuffer as ReadableBuffer, WriteableBuffer as WriteableBuffer
from dataclasses import dataclass
from os import PathLike
from typing import Any, AnyStr, AsyncIterator, Callable, Generic, IO, Iterable, Iterator, Sequence, overload

class AsyncFile(AsyncResource, Generic[AnyStr]):
    """
    An asynchronous file object.

    This class wraps a standard file object and provides async friendly versions of the following
    blocking methods (where available on the original file object):

    * read
    * read1
    * readline
    * readlines
    * readinto
    * readinto1
    * write
    * writelines
    * truncate
    * seek
    * tell
    * flush

    All other methods are directly passed through.

    This class supports the asynchronous context manager protocol which closes the underlying file
    at the end of the context block.

    This class also supports asynchronous iteration::

        async with await open_file(...) as f:
            async for line in f:
                print(line)
    """
    def __init__(self, fp: IO[AnyStr]) -> None: ...
    def __getattr__(self, name: str) -> object: ...
    @property
    def wrapped(self) -> IO[AnyStr]:
        """The wrapped file object."""
    async def __aiter__(self) -> AsyncIterator[AnyStr]: ...
    async def aclose(self) -> None: ...
    async def read(self, size: int = -1) -> AnyStr: ...
    async def read1(self, size: int = -1) -> bytes: ...
    async def readline(self) -> AnyStr: ...
    async def readlines(self) -> list[AnyStr]: ...
    async def readinto(self, b: WriteableBuffer) -> bytes: ...
    async def readinto1(self, b: WriteableBuffer) -> bytes: ...
    @overload
    async def write(self, b: ReadableBuffer) -> int: ...
    @overload
    async def write(self, b: str) -> int: ...
    @overload
    async def writelines(self, lines: Iterable[ReadableBuffer]) -> None: ...
    @overload
    async def writelines(self, lines: Iterable[str]) -> None: ...
    async def truncate(self, size: int | None = None) -> int: ...
    async def seek(self, offset: int, whence: int | None = ...) -> int: ...
    async def tell(self) -> int: ...
    async def flush(self) -> None: ...

@overload
async def open_file(file: str | PathLike[str] | int, mode: OpenBinaryMode, buffering: int = ..., encoding: str | None = ..., errors: str | None = ..., newline: str | None = ..., closefd: bool = ..., opener: Callable[[str, int], int] | None = ...) -> AsyncFile[bytes]: ...
@overload
async def open_file(file: str | PathLike[str] | int, mode: OpenTextMode = ..., buffering: int = ..., encoding: str | None = ..., errors: str | None = ..., newline: str | None = ..., closefd: bool = ..., opener: Callable[[str, int], int] | None = ...) -> AsyncFile[str]: ...
def wrap_file(file: IO[AnyStr]) -> AsyncFile[AnyStr]:
    """
    Wrap an existing file as an asynchronous file.

    :param file: an existing file-like object
    :return: an asynchronous file object

    """

@dataclass(eq=False)
class _PathIterator(AsyncIterator['Path']):
    iterator: Iterator[PathLike[str]]
    async def __anext__(self) -> Path: ...
    def __init__(self, iterator) -> None: ...

class Path:
    """
    An asynchronous version of :class:`pathlib.Path`.

    This class cannot be substituted for :class:`pathlib.Path` or :class:`pathlib.PurePath`, but
    it is compatible with the :class:`os.PathLike` interface.

    It implements the Python 3.10 version of :class:`pathlib.Path` interface, except for the
    deprecated :meth:`~pathlib.Path.link_to` method.

    Any methods that do disk I/O need to be awaited on. These methods are:

    * :meth:`~pathlib.Path.absolute`
    * :meth:`~pathlib.Path.chmod`
    * :meth:`~pathlib.Path.cwd`
    * :meth:`~pathlib.Path.exists`
    * :meth:`~pathlib.Path.expanduser`
    * :meth:`~pathlib.Path.group`
    * :meth:`~pathlib.Path.hardlink_to`
    * :meth:`~pathlib.Path.home`
    * :meth:`~pathlib.Path.is_block_device`
    * :meth:`~pathlib.Path.is_char_device`
    * :meth:`~pathlib.Path.is_dir`
    * :meth:`~pathlib.Path.is_fifo`
    * :meth:`~pathlib.Path.is_file`
    * :meth:`~pathlib.Path.is_mount`
    * :meth:`~pathlib.Path.lchmod`
    * :meth:`~pathlib.Path.lstat`
    * :meth:`~pathlib.Path.mkdir`
    * :meth:`~pathlib.Path.open`
    * :meth:`~pathlib.Path.owner`
    * :meth:`~pathlib.Path.read_bytes`
    * :meth:`~pathlib.Path.read_text`
    * :meth:`~pathlib.Path.readlink`
    * :meth:`~pathlib.Path.rename`
    * :meth:`~pathlib.Path.replace`
    * :meth:`~pathlib.Path.rmdir`
    * :meth:`~pathlib.Path.samefile`
    * :meth:`~pathlib.Path.stat`
    * :meth:`~pathlib.Path.touch`
    * :meth:`~pathlib.Path.unlink`
    * :meth:`~pathlib.Path.write_bytes`
    * :meth:`~pathlib.Path.write_text`

    Additionally, the following methods return an async iterator yielding :class:`~.Path` objects:

    * :meth:`~pathlib.Path.glob`
    * :meth:`~pathlib.Path.iterdir`
    * :meth:`~pathlib.Path.rglob`
    """
    __weakref__: Any
    def __init__(self, *args: str | PathLike[str]) -> None: ...
    def __fspath__(self) -> str: ...
    def __bytes__(self) -> bytes: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __lt__(self, other: Path) -> bool: ...
    def __le__(self, other: Path) -> bool: ...
    def __gt__(self, other: Path) -> bool: ...
    def __ge__(self, other: Path) -> bool: ...
    def __truediv__(self, other: Any) -> Path: ...
    def __rtruediv__(self, other: Any) -> Path: ...
    @property
    def parts(self) -> tuple[str, ...]: ...
    @property
    def drive(self) -> str: ...
    @property
    def root(self) -> str: ...
    @property
    def anchor(self) -> str: ...
    @property
    def parents(self) -> Sequence[Path]: ...
    @property
    def parent(self) -> Path: ...
    @property
    def name(self) -> str: ...
    @property
    def suffix(self) -> str: ...
    @property
    def suffixes(self) -> list[str]: ...
    @property
    def stem(self) -> str: ...
    async def absolute(self) -> Path: ...
    def as_posix(self) -> str: ...
    def as_uri(self) -> str: ...
    def match(self, path_pattern: str) -> bool: ...
    def is_relative_to(self, *other: str | PathLike[str]) -> bool: ...
    async def chmod(self, mode: int, *, follow_symlinks: bool = True) -> None: ...
    @classmethod
    async def cwd(cls) -> Path: ...
    async def exists(self) -> bool: ...
    async def expanduser(self) -> Path: ...
    def glob(self, pattern: str) -> AsyncIterator[Path]: ...
    async def group(self) -> str: ...
    async def hardlink_to(self, target: str | pathlib.Path | Path) -> None: ...
    @classmethod
    async def home(cls) -> Path: ...
    def is_absolute(self) -> bool: ...
    async def is_block_device(self) -> bool: ...
    async def is_char_device(self) -> bool: ...
    async def is_dir(self) -> bool: ...
    async def is_fifo(self) -> bool: ...
    async def is_file(self) -> bool: ...
    async def is_mount(self) -> bool: ...
    def is_reserved(self) -> bool: ...
    async def is_socket(self) -> bool: ...
    async def is_symlink(self) -> bool: ...
    def iterdir(self) -> AsyncIterator[Path]: ...
    def joinpath(self, *args: str | PathLike[str]) -> Path: ...
    async def lchmod(self, mode: int) -> None: ...
    async def lstat(self) -> os.stat_result: ...
    async def mkdir(self, mode: int = 511, parents: bool = False, exist_ok: bool = False) -> None: ...
    @overload
    async def open(self, mode: OpenBinaryMode, buffering: int = ..., encoding: str | None = ..., errors: str | None = ..., newline: str | None = ...) -> AsyncFile[bytes]: ...
    @overload
    async def open(self, mode: OpenTextMode = ..., buffering: int = ..., encoding: str | None = ..., errors: str | None = ..., newline: str | None = ...) -> AsyncFile[str]: ...
    async def owner(self) -> str: ...
    async def read_bytes(self) -> bytes: ...
    async def read_text(self, encoding: str | None = None, errors: str | None = None) -> str: ...
    def relative_to(self, *other: str | PathLike[str]) -> Path: ...
    async def readlink(self) -> Path: ...
    async def rename(self, target: str | pathlib.PurePath | Path) -> Path: ...
    async def replace(self, target: str | pathlib.PurePath | Path) -> Path: ...
    async def resolve(self, strict: bool = False) -> Path: ...
    def rglob(self, pattern: str) -> AsyncIterator[Path]: ...
    async def rmdir(self) -> None: ...
    async def samefile(self, other_path: str | bytes | int | pathlib.Path | Path) -> bool: ...
    async def stat(self, *, follow_symlinks: bool = True) -> os.stat_result: ...
    async def symlink_to(self, target: str | pathlib.Path | Path, target_is_directory: bool = False) -> None: ...
    async def touch(self, mode: int = 438, exist_ok: bool = True) -> None: ...
    async def unlink(self, missing_ok: bool = False) -> None: ...
    def with_name(self, name: str) -> Path: ...
    def with_stem(self, stem: str) -> Path: ...
    def with_suffix(self, suffix: str) -> Path: ...
    async def write_bytes(self, data: bytes) -> int: ...
    async def write_text(self, data: str, encoding: str | None = None, errors: str | None = None, newline: str | None = None) -> int: ...
