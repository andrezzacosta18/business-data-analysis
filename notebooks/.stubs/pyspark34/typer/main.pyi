import click
from .completion import get_completion_inspect_parameters as get_completion_inspect_parameters
from .core import MarkupMode as MarkupMode, TyperArgument as TyperArgument, TyperCommand as TyperCommand, TyperGroup as TyperGroup, TyperOption as TyperOption
from .models import AnyType as AnyType, ArgumentInfo as ArgumentInfo, CommandFunctionType as CommandFunctionType, CommandInfo as CommandInfo, Default as Default, DefaultPlaceholder as DefaultPlaceholder, DeveloperExceptionConfig as DeveloperExceptionConfig, FileBinaryRead as FileBinaryRead, FileBinaryWrite as FileBinaryWrite, FileText as FileText, FileTextWrite as FileTextWrite, NoneType as NoneType, OptionInfo as OptionInfo, ParamMeta as ParamMeta, ParameterInfo as ParameterInfo, Required as Required, TyperInfo as TyperInfo
from .utils import get_params_from_function as get_params_from_function
from _typeshed import Incomplete
from enum import Enum
from pathlib import Path
from types import TracebackType
from typing import Any, Callable, Dict, List, Sequence, Tuple, Type

console_stderr: Incomplete

def except_hook(exc_type: Type[BaseException], exc_value: BaseException, tb: TracebackType) -> None: ...
def get_install_completion_arguments() -> Tuple[click.Parameter, click.Parameter]: ...

class Typer:
    rich_markup_mode: Incomplete
    rich_help_panel: Incomplete
    pretty_exceptions_enable: Incomplete
    pretty_exceptions_show_locals: Incomplete
    pretty_exceptions_short: Incomplete
    info: Incomplete
    registered_groups: Incomplete
    registered_commands: Incomplete
    registered_callback: Incomplete
    def __init__(self, *, name: str | None = ..., cls: Type[TyperGroup] | None = ..., invoke_without_command: bool = ..., no_args_is_help: bool = ..., subcommand_metavar: str | None = ..., chain: bool = ..., result_callback: Callable[..., Any] | None = ..., context_settings: Dict[Any, Any] | None = ..., callback: Callable[..., Any] | None = ..., help: str | None = ..., epilog: str | None = ..., short_help: str | None = ..., options_metavar: str = ..., add_help_option: bool = ..., hidden: bool = ..., deprecated: bool = ..., add_completion: bool = True, rich_markup_mode: MarkupMode = None, rich_help_panel: str | None = ..., pretty_exceptions_enable: bool = True, pretty_exceptions_show_locals: bool = True, pretty_exceptions_short: bool = True) -> None: ...
    def callback(self, name: str | None = ..., *, cls: Type[TyperGroup] | None = ..., invoke_without_command: bool = ..., no_args_is_help: bool = ..., subcommand_metavar: str | None = ..., chain: bool = ..., result_callback: Callable[..., Any] | None = ..., context_settings: Dict[Any, Any] | None = ..., help: str | None = ..., epilog: str | None = ..., short_help: str | None = ..., options_metavar: str = ..., add_help_option: bool = ..., hidden: bool = ..., deprecated: bool = ..., rich_help_panel: str | None = ...) -> Callable[[CommandFunctionType], CommandFunctionType]: ...
    def command(self, name: str | None = None, *, cls: Type[TyperCommand] | None = None, context_settings: Dict[Any, Any] | None = None, help: str | None = None, epilog: str | None = None, short_help: str | None = None, options_metavar: str = '[OPTIONS]', add_help_option: bool = True, no_args_is_help: bool = False, hidden: bool = False, deprecated: bool = False, rich_help_panel: str | None = ...) -> Callable[[CommandFunctionType], CommandFunctionType]: ...
    def add_typer(self, typer_instance: Typer, *, name: str | None = ..., cls: Type[TyperGroup] | None = ..., invoke_without_command: bool = ..., no_args_is_help: bool = ..., subcommand_metavar: str | None = ..., chain: bool = ..., result_callback: Callable[..., Any] | None = ..., context_settings: Dict[Any, Any] | None = ..., callback: Callable[..., Any] | None = ..., help: str | None = ..., epilog: str | None = ..., short_help: str | None = ..., options_metavar: str = ..., add_help_option: bool = ..., hidden: bool = ..., deprecated: bool = ..., rich_help_panel: str | None = ...) -> None: ...
    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...

def get_group(typer_instance: Typer) -> TyperGroup: ...
def get_command(typer_instance: Typer) -> click.Command: ...
def get_group_name(typer_info: TyperInfo) -> str | None: ...
def solve_typer_info_help(typer_info: TyperInfo) -> str: ...
def solve_typer_info_defaults(typer_info: TyperInfo) -> TyperInfo: ...
def get_group_from_info(group_info: TyperInfo, *, pretty_exceptions_short: bool, rich_markup_mode: MarkupMode) -> TyperGroup: ...
def get_command_name(name: str) -> str: ...
def get_params_convertors_ctx_param_name_from_function(callback: Callable[..., Any] | None) -> Tuple[List[click.Argument | click.Option], Dict[str, Any], str | None]: ...
def get_command_from_info(command_info: CommandInfo, *, pretty_exceptions_short: bool, rich_markup_mode: MarkupMode) -> click.Command: ...
def determine_type_convertor(type_: Any) -> Callable[[Any], Any] | None: ...
def param_path_convertor(value: str | None = None) -> Path | None: ...
def generate_enum_convertor(enum: Type[Enum]) -> Callable[[Any], Any]: ...
def generate_list_convertor(convertor: Callable[[Any], Any] | None) -> Callable[[Sequence[Any]], List[Any]]: ...
def generate_tuple_convertor(types: Sequence[Any]) -> Callable[[Tuple[Any, ...]], Tuple[Any, ...]]: ...
def get_callback(*, callback: Callable[..., Any] | None = None, params: Sequence[click.Parameter] = [], convertors: Dict[str, Callable[[str], Any]] = {}, context_param_name: str | None = None, pretty_exceptions_short: bool) -> Callable[..., Any] | None: ...
def get_click_type(*, annotation: Any, parameter_info: ParameterInfo) -> click.ParamType: ...
def lenient_issubclass(cls, class_or_tuple: AnyType | Tuple[AnyType, ...]) -> bool: ...
def get_click_param(param: ParamMeta) -> Tuple[click.Argument | click.Option, Any]: ...
def get_param_callback(*, callback: Callable[..., Any] | None = None, convertor: Callable[..., Any] | None = None) -> Callable[..., Any] | None: ...
def get_param_completion(callback: Callable[..., Any] | None = None) -> Callable[..., Any] | None: ...
def run(function: Callable[..., Any]) -> None: ...
