from .base import BaseDistribution, BaseEntryPoint, BaseEnvironment, DistributionVersion, InfoPath, Wheel
from pip._vendor import pkg_resources
from pip._vendor.packaging.requirements import Requirement
from pip._vendor.packaging.utils import NormalizedName
from typing import Collection, Iterable, Iterator, List, Mapping, NamedTuple

__all__ = ['NAME', 'Distribution', 'Environment']

NAME: str

class EntryPoint(NamedTuple):
    name: str
    value: str
    group: str

class InMemoryMetadata:
    """IMetadataProvider that reads metadata files from a dictionary.

    This also maps metadata decoding exceptions to our internal exception type.
    """
    def __init__(self, metadata: Mapping[str, bytes], wheel_name: str) -> None: ...
    def has_metadata(self, name: str) -> bool: ...
    def get_metadata(self, name: str) -> str: ...
    def get_metadata_lines(self, name: str) -> Iterable[str]: ...
    def metadata_isdir(self, name: str) -> bool: ...
    def metadata_listdir(self, name: str) -> List[str]: ...
    def run_script(self, script_name: str, namespace: str) -> None: ...

class Distribution(BaseDistribution):
    def __init__(self, dist: pkg_resources.Distribution) -> None: ...
    @classmethod
    def from_directory(cls, directory: str) -> BaseDistribution: ...
    @classmethod
    def from_metadata_file_contents(cls, metadata_contents: bytes, filename: str, project_name: str) -> BaseDistribution: ...
    @classmethod
    def from_wheel(cls, wheel: Wheel, name: str) -> BaseDistribution: ...
    @property
    def location(self) -> str | None: ...
    @property
    def installed_location(self) -> str | None: ...
    @property
    def info_location(self) -> str | None: ...
    @property
    def installed_by_distutils(self) -> bool: ...
    @property
    def canonical_name(self) -> NormalizedName: ...
    @property
    def version(self) -> DistributionVersion: ...
    def is_file(self, path: InfoPath) -> bool: ...
    def iter_distutils_script_names(self) -> Iterator[str]: ...
    def read_text(self, path: InfoPath) -> str: ...
    def iter_entry_points(self) -> Iterable[BaseEntryPoint]: ...
    def iter_dependencies(self, extras: Collection[str] = ()) -> Iterable[Requirement]: ...
    def iter_provided_extras(self) -> Iterable[str]: ...
    def is_extra_provided(self, extra: str) -> bool: ...

class Environment(BaseEnvironment):
    def __init__(self, ws: pkg_resources.WorkingSet) -> None: ...
    @classmethod
    def default(cls) -> BaseEnvironment: ...
    @classmethod
    def from_paths(cls, paths: List[str] | None) -> BaseEnvironment: ...
    def get_distribution(self, name: str) -> BaseDistribution | None: ...
