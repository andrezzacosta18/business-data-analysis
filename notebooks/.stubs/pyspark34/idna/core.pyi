from . import idnadata as idnadata
from .intranges import intranges_contain as intranges_contain

class IDNAError(UnicodeError):
    """ Base exception for all IDNA-encoding related problems """
class IDNABidiError(IDNAError):
    """ Exception when bidirectional requirements are not satisfied """
class InvalidCodepoint(IDNAError):
    """ Exception when a disallowed or unallocated codepoint is used """
class InvalidCodepointContext(IDNAError):
    """ Exception when the codepoint is not valid in the context it is used """

def valid_label_length(label: bytes | str) -> bool: ...
def valid_string_length(label: bytes | str, trailing_dot: bool) -> bool: ...
def check_bidi(label: str, check_ltr: bool = False) -> bool: ...
def check_initial_combiner(label: str) -> bool: ...
def check_hyphen_ok(label: str) -> bool: ...
def check_nfc(label: str) -> None: ...
def valid_contextj(label: str, pos: int) -> bool: ...
def valid_contexto(label: str, pos: int, exception: bool = False) -> bool: ...
def check_label(label: str | bytes | bytearray) -> None: ...
def alabel(label: str) -> bytes: ...
def ulabel(label: str | bytes | bytearray) -> str: ...
def uts46_remap(domain: str, std3_rules: bool = True, transitional: bool = False) -> str:
    """Re-map the characters in the string according to UTS46 processing."""
def encode(s: str | bytes | bytearray, strict: bool = False, uts46: bool = False, std3_rules: bool = False, transitional: bool = False) -> bytes: ...
def decode(s: str | bytes | bytearray, strict: bool = False, uts46: bool = False, std3_rules: bool = False) -> str: ...
