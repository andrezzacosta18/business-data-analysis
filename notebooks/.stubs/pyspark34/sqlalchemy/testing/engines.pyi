import typing
from . import config as config
from .. import event as event, pool as pool
from ..engine import Engine as Engine
from ..engine.url import URL as URL
from ..ext.asyncio import AsyncEngine as AsyncEngine
from ..util import await_only as await_only
from ..util.typing import Literal as Literal
from .util import decorator as decorator, gc_collect as gc_collect
from _typeshed import Incomplete
from collections.abc import Generator
from typing import Any, Dict

class ConnectionKiller:
    proxy_refs: Incomplete
    testing_engines: Incomplete
    dbapi_connections: Incomplete
    def __init__(self) -> None: ...
    def add_pool(self, pool) -> None: ...
    def add_engine(self, engine, scope) -> None: ...
    def rollback_all(self) -> None: ...
    def checkin_all(self) -> None: ...
    def close_all(self) -> None: ...
    def prepare_for_drop_tables(self, connection) -> None: ...
    def after_test(self) -> None: ...
    def after_test_outside_fixtures(self, test) -> None: ...
    def stop_test_class_inside_fixtures(self) -> None: ...
    def stop_test_class_outside_fixtures(self) -> None: ...
    def final_cleanup(self) -> None: ...
    def assert_all_closed(self) -> None: ...

testing_reaper: Incomplete

def assert_conns_closed(fn, *args, **kw) -> None: ...
def rollback_open_connections(fn, *args, **kw) -> None:
    """Decorator that rolls back all open connections after fn execution."""
def close_first(fn, *args, **kw) -> None:
    """Decorator that closes all connections before fn execution."""
def close_open_connections(fn, *args, **kw) -> None:
    """Decorator that closes all connections after fn execution."""
def all_dialects(exclude: Incomplete | None = None) -> Generator[Incomplete, None, None]: ...

class ReconnectFixture:
    dbapi: Incomplete
    connections: Incomplete
    is_stopped: bool
    def __init__(self, dbapi) -> None: ...
    def __getattr__(self, key): ...
    def connect(self, *args, **kwargs): ...
    def shutdown(self, stop: bool = False) -> None: ...
    def restart(self) -> None: ...

def reconnecting_engine(url: Incomplete | None = None, options: Incomplete | None = None): ...
@typing.overload
def testing_engine(url: URL | None = None, options: Dict[str, Any] | None = None, asyncio: Literal[False] = False, transfer_staticpool: bool = False) -> Engine: ...
@typing.overload
def testing_engine(url: URL | None = None, options: Dict[str, Any] | None = None, asyncio: Literal[True] = True, transfer_staticpool: bool = False) -> AsyncEngine: ...
def mock_engine(dialect_name: Incomplete | None = None):
    """Provides a mocking engine based on the current testing.db.

    This is normally used to test DDL generation flow as emitted
    by an Engine.

    It should not be used in other cases, as assert_compile() and
    assert_sql_execution() are much better choices with fewer
    moving parts.

    """

class DBAPIProxyCursor:
    """Proxy a DBAPI cursor.

    Tests can provide subclasses of this to intercept
    DBAPI-level cursor operations.

    """
    engine: Incomplete
    connection: Incomplete
    cursor: Incomplete
    def __init__(self, engine, conn, *args, **kwargs) -> None: ...
    def execute(self, stmt, parameters: Incomplete | None = None, **kw): ...
    def executemany(self, stmt, params, **kw): ...
    def __iter__(self): ...
    def __getattr__(self, key): ...

class DBAPIProxyConnection:
    """Proxy a DBAPI connection.

    Tests can provide subclasses of this to intercept
    DBAPI-level connection operations.

    """
    conn: Incomplete
    engine: Incomplete
    cursor_cls: Incomplete
    def __init__(self, engine, conn, cursor_cls) -> None: ...
    def cursor(self, *args, **kwargs): ...
    def close(self) -> None: ...
    def __getattr__(self, key): ...
