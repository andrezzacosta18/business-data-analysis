from . import attributes as attributes, path_registry as path_registry
from .. import util as util
from ..engine import result_tuple as result_tuple
from ..engine.cursor import CursorResult as CursorResult
from ..engine.interfaces import _ExecuteOptions
from ..engine.result import ChunkedIteratorResult as ChunkedIteratorResult, FrozenResult as FrozenResult, Result as Result, SimpleResultMetaData as SimpleResultMetaData
from ..sql import Select as Select, select as select
from ..sql.selectable import ForUpdateArg as ForUpdateArg, LABEL_STYLE_TABLENAME_PLUS_COL as LABEL_STYLE_TABLENAME_PLUS_COL, SelectState as SelectState
from ..util import EMPTY_DICT as EMPTY_DICT
from ._typing import _IdentityKeyType
from .base import LoaderCallableStatus as LoaderCallableStatus, PassiveFlag as PassiveFlag
from .context import FromStatement as FromStatement, ORMCompileState as ORMCompileState, QueryContext as QueryContext
from .interfaces import ORMOption as ORMOption
from .mapper import Mapper as Mapper
from .query import Query as Query
from .session import Session as Session
from .state import InstanceState as InstanceState
from .util import state_str as state_str
from _typeshed import Incomplete
from typing import Any, Iterable, Mapping, Sequence, Tuple

def instances(cursor: CursorResult[Any], context: QueryContext) -> Result[Any]:
    """Return a :class:`.Result` given an ORM query context.

    :param cursor: a :class:`.CursorResult`, generated by a statement
     which came from :class:`.ORMCompileState`

    :param context: a :class:`.QueryContext` object

    :return: a :class:`.Result` object representing ORM results

    .. versionchanged:: 1.4 The instances() function now uses
       :class:`.Result` objects and has an all new interface.

    """
def merge_frozen_result(session, statement, frozen_result, load: bool = True):
    """Merge a :class:`_engine.FrozenResult` back into a :class:`_orm.Session`,
    returning a new :class:`_engine.Result` object with :term:`persistent`
    objects.

    See the section :ref:`do_orm_execute_re_executing` for an example.

    .. seealso::

        :ref:`do_orm_execute_re_executing`

        :meth:`_engine.Result.freeze`

        :class:`_engine.FrozenResult`

    """
def merge_result(query: Query[Any], iterator: FrozenResult | Iterable[Sequence[Any]] | Iterable[object], load: bool = True) -> FrozenResult | Iterable[Any]:
    """Merge a result into the given :class:`.Query` object's Session.

    See :meth:`_orm.Query.merge_result` for top-level documentation on this
    function.

    """
def get_from_identity(session: Session, mapper: Mapper[_O], key: _IdentityKeyType[_O], passive: PassiveFlag) -> LoaderCallableStatus | _O | None:
    """Look up the given key in the given session's identity map,
    check the object for expired state if found.

    """
def load_on_ident(session: Session, statement: Select | FromStatement, key: _IdentityKeyType | None, *, load_options: Sequence[ORMOption] | None = None, refresh_state: InstanceState[Any] | None = None, with_for_update: ForUpdateArg | None = None, only_load_props: Iterable[str] | None = None, no_autoflush: bool = False, bind_arguments: Mapping[str, Any] = ..., execution_options: _ExecuteOptions = ..., require_pk_cols: bool = False, is_user_refresh: bool = False):
    """Load the given identity key from the database."""
def load_on_pk_identity(session: Session, statement: Select | FromStatement, primary_key_identity: Tuple[Any, ...] | None, *, load_options: Sequence[ORMOption] | None = None, refresh_state: InstanceState[Any] | None = None, with_for_update: ForUpdateArg | None = None, only_load_props: Iterable[str] | None = None, identity_token: Any | None = None, no_autoflush: bool = False, bind_arguments: Mapping[str, Any] = ..., execution_options: _ExecuteOptions = ..., require_pk_cols: bool = False, is_user_refresh: bool = False):
    """Load the given primary key identity from the database."""

class PostLoad:
    '''Track loaders and states for "post load" operations.'''
    loaders: Incomplete
    states: Incomplete
    load_keys: Incomplete
    def __init__(self) -> None: ...
    def add_state(self, state, overwrite) -> None: ...
    def invoke(self, context, path) -> None: ...
    @classmethod
    def for_context(cls, context, path, only_load_props): ...
    @classmethod
    def path_exists(self, context, path, key): ...
    @classmethod
    def callable_for_path(cls, context, path, limit_to_mapper, token, loader_callable, *arg, **kw) -> None: ...

def load_scalar_attributes(mapper, state, attribute_names, passive):
    """initiate a column-based attribute refresh operation."""
