from _typeshed import Incomplete
from mypy.nodes import CallExpr, ClassDef as ClassDef, Context as Context, Expression as Expression, JsonDict as JsonDict, NameExpr, Statement as Statement, TypeInfo
from mypy.options import Options as Options
from mypy.plugin import ClassDefContext as ClassDefContext, DynamicClassDefContext as DynamicClassDefContext, SemanticAnalyzerPluginInterface as SemanticAnalyzerPluginInterface
from mypy.types import Instance, Type as Type
from typing import Iterable, Iterator, List, Tuple, Type as TypingType, overload

mypy_14: Incomplete

class SQLAlchemyAttribute:
    name: Incomplete
    line: Incomplete
    column: Incomplete
    type: Incomplete
    info: Incomplete
    def __init__(self, name: str, line: int, column: int, typ: Type | None, info: TypeInfo) -> None: ...
    def serialize(self) -> JsonDict: ...
    def expand_typevar_from_subtype(self, sub_type: TypeInfo) -> None:
        """Expands type vars in the context of a subtype when an attribute is
        inherited from a generic super type.
        """
    @classmethod
    def deserialize(cls, info: TypeInfo, data: JsonDict, api: SemanticAnalyzerPluginInterface) -> SQLAlchemyAttribute: ...

def name_is_dunder(name: str) -> bool: ...
def establish_as_sqlalchemy(info: TypeInfo) -> None: ...
def set_is_base(info: TypeInfo) -> None: ...
def get_is_base(info: TypeInfo) -> bool: ...
def has_declarative_base(info: TypeInfo) -> bool: ...
def set_has_table(info: TypeInfo) -> None: ...
def get_has_table(info: TypeInfo) -> bool: ...
def get_mapped_attributes(info: TypeInfo, api: SemanticAnalyzerPluginInterface) -> List[SQLAlchemyAttribute] | None: ...
def format_type(typ_: Type, options: Options) -> str: ...
def set_mapped_attributes(info: TypeInfo, attributes: List[SQLAlchemyAttribute]) -> None: ...
def fail(api: SemanticAnalyzerPluginInterface, msg: str, ctx: Context) -> None: ...
def add_global(ctx: ClassDefContext | DynamicClassDefContext, module: str, symbol_name: str, asname: str) -> None: ...
@overload
def get_callexpr_kwarg(callexpr: CallExpr, name: str, *, expr_types: None = ...) -> CallExpr | NameExpr | None: ...
@overload
def get_callexpr_kwarg(callexpr: CallExpr, name: str, *, expr_types: Tuple[TypingType[_TArgType], ...]) -> _TArgType | None: ...
def flatten_typechecking(stmts: Iterable[Statement]) -> Iterator[Statement]: ...
def type_for_callee(callee: Expression) -> Instance | TypeInfo | None: ...
def unbound_to_instance(api: SemanticAnalyzerPluginInterface, typ: Type) -> Type:
    """Take the UnboundType that we seem to get as the ret_type from a FuncDef
    and convert it into an Instance/TypeInfo kind of structure that seems
    to work as the left-hand type of an AssignmentStatement.

    """
def info_for_cls(cls, api: SemanticAnalyzerPluginInterface) -> TypeInfo | None: ...
