from .. import ColumnElement as ColumnElement, exc as exc, inspect as inspect, orm as orm, util as util
from ..orm import InspectionAttrExtensionType as InspectionAttrExtensionType, ORMDescriptor as ORMDescriptor, collections as collections, interfaces as interfaces
from ..orm.base import SQLORMOperations as SQLORMOperations
from ..orm.interfaces import MapperProperty as MapperProperty, PropComparator as PropComparator, _AttributeOptions, _DCAttributeOptions
from ..orm.mapper import Mapper as Mapper
from ..sql import operators as operators, or_ as or_
from ..sql._typing import _ColumnExpressionArgument, _InfoType
from ..sql.base import _NoArg
from ..util.typing import Literal as Literal, Protocol as Protocol, Self as Self, SupportsIndex as SupportsIndex, SupportsKeysAndGetItem as SupportsKeysAndGetItem
from _typeshed import Incomplete
from typing import AbstractSet, Any, Callable, Collection, Dict, Generic, ItemsView, Iterable, Iterator, KeysView, List, MutableMapping, MutableSequence, MutableSet, NoReturn, Tuple, Type, ValuesView, overload

def association_proxy(target_collection: str, attr: str, *, creator: _CreatorProtocol | None = None, getset_factory: _GetSetFactoryProtocol | None = None, proxy_factory: _ProxyFactoryProtocol | None = None, proxy_bulk_set: _ProxyBulkSetProtocol | None = None, info: _InfoType | None = None, cascade_scalar_deletes: bool = False, create_on_none_assignment: bool = False, init: _NoArg | bool = ..., repr: _NoArg | bool = ..., default: Any | None = ..., default_factory: _NoArg | Callable[[], _T] = ..., compare: _NoArg | bool = ..., kw_only: _NoArg | bool = ...) -> AssociationProxy[Any]:
    """Return a Python property implementing a view of a target
    attribute which references an attribute on members of the
    target.

    The returned value is an instance of :class:`.AssociationProxy`.

    Implements a Python property representing a relationship as a collection
    of simpler values, or a scalar value.  The proxied property will mimic
    the collection type of the target (list, dict or set), or, in the case of
    a one to one relationship, a simple scalar value.

    :param target_collection: Name of the attribute that is the immediate
      target.  This attribute is typically mapped by
      :func:`~sqlalchemy.orm.relationship` to link to a target collection, but
      can also be a many-to-one or non-scalar relationship.

    :param attr: Attribute on the associated instance or instances that
      are available on instances of the target object.

    :param creator: optional.

      Defines custom behavior when new items are added to the proxied
      collection.

      By default, adding new items to the collection will trigger a
      construction of an instance of the target object, passing the given
      item as a positional argument to the target constructor.  For cases
      where this isn't sufficient, :paramref:`.association_proxy.creator`
      can supply a callable that will construct the object in the
      appropriate way, given the item that was passed.

      For list- and set- oriented collections, a single argument is
      passed to the callable. For dictionary oriented collections, two
      arguments are passed, corresponding to the key and value.

      The :paramref:`.association_proxy.creator` callable is also invoked
      for scalar (i.e. many-to-one, one-to-one) relationships. If the
      current value of the target relationship attribute is ``None``, the
      callable is used to construct a new object.  If an object value already
      exists, the given attribute value is populated onto that object.

      .. seealso::

        :ref:`associationproxy_creator`

    :param cascade_scalar_deletes: when True, indicates that setting
        the proxied value to ``None``, or deleting it via ``del``, should
        also remove the source object.  Only applies to scalar attributes.
        Normally, removing the proxied target will not remove the proxy
        source, as this object may have other state that is still to be
        kept.

        .. versionadded:: 1.3

        .. seealso::

            :ref:`cascade_scalar_deletes` - complete usage example

    :param create_on_none_assignment: when True, indicates that setting
      the proxied value to ``None`` should **create** the source object
      if it does not exist, using the creator.  Only applies to scalar
      attributes.  This is mutually exclusive
      vs. the :paramref:`.assocation_proxy.cascade_scalar_deletes`.

      .. versionadded:: 2.0.18

    :param init: Specific to :ref:`orm_declarative_native_dataclasses`,
     specifies if the mapped attribute should be part of the ``__init__()``
     method as generated by the dataclass process.

     .. versionadded:: 2.0.0b4

    :param repr: Specific to :ref:`orm_declarative_native_dataclasses`,
     specifies if the attribute established by this :class:`.AssociationProxy`
     should be part of the ``__repr__()`` method as generated by the dataclass
     process.

     .. versionadded:: 2.0.0b4

    :param default_factory: Specific to
     :ref:`orm_declarative_native_dataclasses`, specifies a default-value
     generation function that will take place as part of the ``__init__()``
     method as generated by the dataclass process.

     .. versionadded:: 2.0.0b4

    :param compare: Specific to
     :ref:`orm_declarative_native_dataclasses`, indicates if this field
     should be included in comparison operations when generating the
     ``__eq__()`` and ``__ne__()`` methods for the mapped class.

     .. versionadded:: 2.0.0b4

    :param kw_only: Specific to :ref:`orm_declarative_native_dataclasses`,
     indicates if this field should be marked as keyword-only when generating
     the ``__init__()`` method as generated by the dataclass process.

     .. versionadded:: 2.0.0b4

    :param info: optional, will be assigned to
     :attr:`.AssociationProxy.info` if present.


    The following additional parameters involve injection of custom behaviors
    within the :class:`.AssociationProxy` object and are for advanced use
    only:

    :param getset_factory: Optional.  Proxied attribute access is
        automatically handled by routines that get and set values based on
        the `attr` argument for this proxy.

        If you would like to customize this behavior, you may supply a
        `getset_factory` callable that produces a tuple of `getter` and
        `setter` functions.  The factory is called with two arguments, the
        abstract type of the underlying collection and this proxy instance.

    :param proxy_factory: Optional.  The type of collection to emulate is
        determined by sniffing the target collection.  If your collection
        type can't be determined by duck typing or you'd like to use a
        different collection implementation, you may supply a factory
        function to produce those collections.  Only applicable to
        non-scalar relationships.

    :param proxy_bulk_set: Optional, use with proxy_factory.


    """

class AssociationProxyExtensionType(InspectionAttrExtensionType):
    ASSOCIATION_PROXY: str

class _GetterProtocol(Protocol[_T_co]):
    def __call__(self, instance: Any) -> _T_co: ...

class _SetterProtocol(Protocol): ...

class _PlainSetterProtocol(_SetterProtocol, Protocol[_T_con]):
    def __call__(self, instance: Any, value: _T_con) -> None: ...

class _DictSetterProtocol(_SetterProtocol, Protocol[_T_con]):
    def __call__(self, instance: Any, key: Any, value: _T_con) -> None: ...

class _CreatorProtocol(Protocol): ...

class _PlainCreatorProtocol(_CreatorProtocol, Protocol[_T_con]):
    def __call__(self, value: _T_con) -> Any: ...

class _KeyCreatorProtocol(_CreatorProtocol, Protocol[_T_con]):
    def __call__(self, key: Any, value: _T_con | None) -> Any: ...

class _LazyCollectionProtocol(Protocol[_T]):
    def __call__(self) -> MutableSet[_T] | MutableMapping[Any, _T] | MutableSequence[_T]: ...

class _GetSetFactoryProtocol(Protocol):
    def __call__(self, collection_class: Type[Any] | None, assoc_instance: AssociationProxyInstance[Any]) -> Tuple[_GetterProtocol[Any], _SetterProtocol]: ...

class _ProxyFactoryProtocol(Protocol):
    def __call__(self, lazy_collection: _LazyCollectionProtocol[Any], creator: _CreatorProtocol, value_attr: str, parent: AssociationProxyInstance[Any]) -> Any: ...

class _ProxyBulkSetProtocol(Protocol):
    def __call__(self, proxy: _AssociationCollection[Any], collection: Iterable[Any]) -> None: ...

class _AssociationProxyProtocol(Protocol[_T]):
    """describes the interface of :class:`.AssociationProxy`
    without including descriptor methods in the interface."""
    creator: _CreatorProtocol | None
    key: str
    target_collection: str
    value_attr: str
    cascade_scalar_deletes: bool
    create_on_none_assignment: bool
    getset_factory: _GetSetFactoryProtocol | None
    proxy_factory: _ProxyFactoryProtocol | None
    proxy_bulk_set: _ProxyBulkSetProtocol | None
    def info(self) -> _InfoType: ...
    def for_class(self, class_: Type[Any], obj: object | None = None) -> AssociationProxyInstance[_T]: ...

class AssociationProxy(interfaces.InspectionAttrInfo, ORMDescriptor[_T], _DCAttributeOptions, _AssociationProxyProtocol[_T]):
    """A descriptor that presents a read/write view of an object attribute."""
    is_attribute: bool
    extension_type: Incomplete
    target_collection: Incomplete
    value_attr: Incomplete
    creator: Incomplete
    getset_factory: Incomplete
    proxy_factory: Incomplete
    proxy_bulk_set: Incomplete
    cascade_scalar_deletes: Incomplete
    create_on_none_assignment: Incomplete
    key: Incomplete
    info: Incomplete
    def __init__(self, target_collection: str, attr: str, *, creator: _CreatorProtocol | None = None, getset_factory: _GetSetFactoryProtocol | None = None, proxy_factory: _ProxyFactoryProtocol | None = None, proxy_bulk_set: _ProxyBulkSetProtocol | None = None, info: _InfoType | None = None, cascade_scalar_deletes: bool = False, create_on_none_assignment: bool = False, attribute_options: _AttributeOptions | None = None) -> None:
        """Construct a new :class:`.AssociationProxy`.

        The :class:`.AssociationProxy` object is typically constructed using
        the :func:`.association_proxy` constructor function. See the
        description of :func:`.association_proxy` for a description of all
        parameters.


        """
    @overload
    def __get__(self, instance: Literal[None], owner: Literal[None]) -> Self: ...
    @overload
    def __get__(self, instance: Literal[None], owner: Any) -> AssociationProxyInstance[_T]: ...
    @overload
    def __get__(self, instance: object, owner: Any) -> _T: ...
    def __set__(self, instance: object, values: _T) -> None: ...
    def __delete__(self, instance: object) -> None: ...
    def for_class(self, class_: Type[Any], obj: object | None = None) -> AssociationProxyInstance[_T]:
        '''Return the internal state local to a specific mapped class.

        E.g., given a class ``User``::

            class User(Base):
                # ...

                keywords = association_proxy(\'kws\', \'keyword\')

        If we access this :class:`.AssociationProxy` from
        :attr:`_orm.Mapper.all_orm_descriptors`, and we want to view the
        target class for this proxy as mapped by ``User``::

            inspect(User).all_orm_descriptors["keywords"].for_class(User).target_class

        This returns an instance of :class:`.AssociationProxyInstance` that
        is specific to the ``User`` class.   The :class:`.AssociationProxy`
        object remains agnostic of its parent class.

        :param class\\_: the class that we are returning state for.

        :param obj: optional, an instance of the class that is required
         if the attribute refers to a polymorphic target, e.g. where we have
         to look at the type of the actual destination object to get the
         complete path.

        .. versionadded:: 1.3 - :class:`.AssociationProxy` no longer stores
           any state specific to a particular parent class; the state is now
           stored in per-class :class:`.AssociationProxyInstance` objects.


        '''

class AssociationProxyInstance(SQLORMOperations[_T]):
    '''A per-class object that serves class- and object-specific results.

    This is used by :class:`.AssociationProxy` when it is invoked
    in terms of a specific class or instance of a class, i.e. when it is
    used as a regular Python descriptor.

    When referring to the :class:`.AssociationProxy` as a normal Python
    descriptor, the :class:`.AssociationProxyInstance` is the object that
    actually serves the information.   Under normal circumstances, its presence
    is transparent::

        >>> User.keywords.scalar
        False

    In the special case that the :class:`.AssociationProxy` object is being
    accessed directly, in order to get an explicit handle to the
    :class:`.AssociationProxyInstance`, use the
    :meth:`.AssociationProxy.for_class` method::

        proxy_state = inspect(User).all_orm_descriptors["keywords"].for_class(User)

        # view if proxy object is scalar or not
        >>> proxy_state.scalar
        False

    .. versionadded:: 1.3

    '''
    collection_class: Type[Any] | None
    parent: _AssociationProxyProtocol[_T]
    key: Incomplete
    owning_class: Incomplete
    target_collection: Incomplete
    target_class: Incomplete
    value_attr: Incomplete
    def __init__(self, parent: _AssociationProxyProtocol[_T], owning_class: Type[Any], target_class: Type[Any], value_attr: str) -> None: ...
    @classmethod
    def for_proxy(cls, parent: AssociationProxy[_T], owning_class: Type[Any], parent_instance: Any) -> AssociationProxyInstance[_T]: ...
    def __clause_element__(self) -> NoReturn: ...
    @property
    def remote_attr(self) -> SQLORMOperations[_T]:
        """The 'remote' class attribute referenced by this
        :class:`.AssociationProxyInstance`.

        .. seealso::

            :attr:`.AssociationProxyInstance.attr`

            :attr:`.AssociationProxyInstance.local_attr`

        """
    @property
    def local_attr(self) -> SQLORMOperations[Any]:
        """The 'local' class attribute referenced by this
        :class:`.AssociationProxyInstance`.

        .. seealso::

            :attr:`.AssociationProxyInstance.attr`

            :attr:`.AssociationProxyInstance.remote_attr`

        """
    @property
    def attr(self) -> Tuple[SQLORMOperations[Any], SQLORMOperations[_T]]:
        """Return a tuple of ``(local_attr, remote_attr)``.

        This attribute was originally intended to facilitate using the
        :meth:`_query.Query.join` method to join across the two relationships
        at once, however this makes use of a deprecated calling style.

        To use :meth:`_sql.select.join` or :meth:`_orm.Query.join` with
        an association proxy, the current method is to make use of the
        :attr:`.AssociationProxyInstance.local_attr` and
        :attr:`.AssociationProxyInstance.remote_attr` attributes separately::

            stmt = (
                select(Parent).
                join(Parent.proxied.local_attr).
                join(Parent.proxied.remote_attr)
            )

        A future release may seek to provide a more succinct join pattern
        for association proxy attributes.

        .. seealso::

            :attr:`.AssociationProxyInstance.local_attr`

            :attr:`.AssociationProxyInstance.remote_attr`

        """
    def scalar(self) -> bool:
        """Return ``True`` if this :class:`.AssociationProxyInstance`
        proxies a scalar relationship on the local side."""
    def info(self) -> _InfoType: ...
    @overload
    def get(self, obj: Literal[None]) -> _Self: ...
    @overload
    def get(self, obj: Any) -> _T: ...
    def set(self, obj: Any, values: _T) -> None: ...
    def delete(self, obj: Any) -> None: ...
    def any(self, criterion: _ColumnExpressionArgument[bool] | None = None, **kwargs: Any) -> ColumnElement[bool]:
        """Produce a proxied 'any' expression using EXISTS.

        This expression will be a composed product
        using the :meth:`.Relationship.Comparator.any`
        and/or :meth:`.Relationship.Comparator.has`
        operators of the underlying proxied attributes.

        """
    def has(self, criterion: _ColumnExpressionArgument[bool] | None = None, **kwargs: Any) -> ColumnElement[bool]:
        """Produce a proxied 'has' expression using EXISTS.

        This expression will be a composed product
        using the :meth:`.Relationship.Comparator.any`
        and/or :meth:`.Relationship.Comparator.has`
        operators of the underlying proxied attributes.

        """

class AmbiguousAssociationProxyInstance(AssociationProxyInstance[_T]):
    """an :class:`.AssociationProxyInstance` where we cannot determine
    the type of target object.
    """
    def get(self, obj: Any) -> Any: ...
    def __eq__(self, obj: object) -> NoReturn: ...
    def __ne__(self, obj: object) -> NoReturn: ...
    def any(self, criterion: _ColumnExpressionArgument[bool] | None = None, **kwargs: Any) -> NoReturn: ...
    def has(self, criterion: _ColumnExpressionArgument[bool] | None = None, **kwargs: Any) -> NoReturn: ...

class ObjectAssociationProxyInstance(AssociationProxyInstance[_T]):
    """an :class:`.AssociationProxyInstance` that has an object as a target."""
    def contains(self, other: Any, **kw: Any) -> ColumnElement[bool]:
        """Produce a proxied 'contains' expression using EXISTS.

        This expression will be a composed product
        using the :meth:`.Relationship.Comparator.any`,
        :meth:`.Relationship.Comparator.has`,
        and/or :meth:`.Relationship.Comparator.contains`
        operators of the underlying proxied attributes.
        """
    def __eq__(self, obj: Any) -> ColumnElement[bool]: ...
    def __ne__(self, obj: Any) -> ColumnElement[bool]: ...

class ColumnAssociationProxyInstance(AssociationProxyInstance[_T]):
    """an :class:`.AssociationProxyInstance` that has a database column as a
    target.
    """
    def __eq__(self, other: Any) -> ColumnElement[bool]: ...
    def operate(self, op: operators.OperatorType, *other: Any, **kwargs: Any) -> ColumnElement[Any]: ...

class _lazy_collection(_LazyCollectionProtocol[_T]):
    parent: Incomplete
    target: Incomplete
    def __init__(self, obj: Any, target: str) -> None: ...
    def __call__(self) -> MutableSet[_T] | MutableMapping[Any, _T] | MutableSequence[_T]: ...

class _AssociationCollection(Generic[_IT]):
    getter: _GetterProtocol[_IT]
    creator: _CreatorProtocol
    parent: AssociationProxyInstance[_IT]
    setter: _SetterProtocol
    lazy_collection: _LazyCollectionProtocol[_IT]
    def __init__(self, lazy_collection: _LazyCollectionProtocol[_IT], creator: _CreatorProtocol, getter: _GetterProtocol[_IT], setter: _SetterProtocol, parent: AssociationProxyInstance[_IT]) -> None:
        """Constructs an _AssociationCollection.

        This will always be a subclass of either _AssociationList,
        _AssociationSet, or _AssociationDict.

        """
    col: Collection[_IT]
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def clear(self) -> None: ...

class _AssociationSingleItem(_AssociationCollection[_T]):
    setter: _PlainSetterProtocol[_T]
    creator: _PlainCreatorProtocol[_T]

class _AssociationList(_AssociationSingleItem[_T], MutableSequence[_T]):
    """Generic, converting, list-to-list proxy."""
    col: MutableSequence[_T]
    @overload
    def __getitem__(self, index: int) -> _T: ...
    @overload
    def __getitem__(self, index: slice) -> MutableSequence[_T]: ...
    @overload
    def __setitem__(self, index: int, value: _T) -> None: ...
    @overload
    def __setitem__(self, index: slice, value: Iterable[_T]) -> None: ...
    @overload
    def __delitem__(self, index: int) -> None: ...
    @overload
    def __delitem__(self, index: slice) -> None: ...
    def __contains__(self, value: object) -> bool: ...
    def __iter__(self) -> Iterator[_T]:
        """Iterate over proxied values.

        For the actual domain objects, iterate over .col instead or
        just use the underlying collection directly from its property
        on the parent.
        """
    def append(self, value: _T) -> None: ...
    def count(self, value: Any) -> int: ...
    def extend(self, values: Iterable[_T]) -> None: ...
    def insert(self, index: int, value: _T) -> None: ...
    def pop(self, index: int = -1) -> _T: ...
    def remove(self, value: _T) -> None: ...
    def reverse(self) -> NoReturn:
        """Not supported, use reversed(mylist)"""
    def sort(self) -> NoReturn:
        """Not supported, use sorted(mylist)"""
    def clear(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: List[_T]) -> bool: ...
    def __le__(self, other: List[_T]) -> bool: ...
    def __gt__(self, other: List[_T]) -> bool: ...
    def __ge__(self, other: List[_T]) -> bool: ...
    def __add__(self, other: List[_T]) -> List[_T]: ...
    def __radd__(self, other: List[_T]) -> List[_T]: ...
    def __mul__(self, n: SupportsIndex) -> List[_T]: ...
    def __rmul__(self, n: SupportsIndex) -> List[_T]: ...
    def __iadd__(self, iterable: Iterable[_T]) -> Self: ...
    def __imul__(self, n: SupportsIndex) -> Self: ...
    def index(self, value: Any, start: int = ..., stop: int = ...) -> int: ...
    def copy(self) -> List[_T]: ...
    def __hash__(self) -> NoReturn: ...

class _AssociationDict(_AssociationCollection[_VT], MutableMapping[_KT, _VT]):
    """Generic, converting, dict-to-dict proxy."""
    setter: _DictSetterProtocol[_VT]
    creator: _KeyCreatorProtocol[_VT]
    col: MutableMapping[_KT, _VT | None]
    def __getitem__(self, key: _KT) -> _VT: ...
    def __setitem__(self, key: _KT, value: _VT) -> None: ...
    def __delitem__(self, key: _KT) -> None: ...
    def __contains__(self, key: object) -> bool: ...
    def __iter__(self) -> Iterator[_KT]: ...
    def clear(self) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    @overload
    def get(self, __key: _KT) -> _VT | None: ...
    @overload
    def get(self, __key: _KT, default: _VT | _T) -> _VT | _T: ...
    def setdefault(self, key: _KT, default: _VT | None = None) -> _VT: ...
    def keys(self) -> KeysView[_KT]: ...
    def items(self) -> ItemsView[_KT, _VT]: ...
    def values(self) -> ValuesView[_VT]: ...
    @overload
    def pop(self, __key: _KT) -> _VT: ...
    @overload
    def pop(self, __key: _KT, default: _VT | _T = ...) -> _VT | _T: ...
    def popitem(self) -> Tuple[_KT, _VT]: ...
    @overload
    def update(self, __m: SupportsKeysAndGetItem[_KT, _VT], **kwargs: _VT) -> None: ...
    @overload
    def update(self, __m: Iterable[tuple[_KT, _VT]], **kwargs: _VT) -> None: ...
    @overload
    def update(self, **kwargs: _VT) -> None: ...
    def copy(self) -> Dict[_KT, _VT]: ...
    def __hash__(self) -> NoReturn: ...

class _AssociationSet(_AssociationSingleItem[_T], MutableSet[_T]):
    """Generic, converting, set-to-set proxy."""
    col: MutableSet[_T]
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, __o: object) -> bool: ...
    def __iter__(self) -> Iterator[_T]:
        """Iterate over proxied values.

        For the actual domain objects, iterate over .col instead or just use
        the underlying collection directly from its property on the parent.

        """
    def add(self, __element: _T) -> None: ...
    def discard(self, __element: _T) -> None: ...
    def remove(self, __element: _T) -> None: ...
    def pop(self) -> _T: ...
    def update(self, *s: Iterable[_T]) -> None: ...
    def __ior__(self, other: AbstractSet[_S]) -> MutableSet[_T | _S]: ...
    def union(self, *s: Iterable[_S]) -> MutableSet[_T | _S]: ...
    def __or__(self, __s: AbstractSet[_S]) -> MutableSet[_T | _S]: ...
    def difference(self, *s: Iterable[Any]) -> MutableSet[_T]: ...
    def __sub__(self, s: AbstractSet[Any]) -> MutableSet[_T]: ...
    def difference_update(self, *s: Iterable[Any]) -> None: ...
    def __isub__(self, s: AbstractSet[Any]) -> Self: ...
    def intersection(self, *s: Iterable[Any]) -> MutableSet[_T]: ...
    def __and__(self, s: AbstractSet[Any]) -> MutableSet[_T]: ...
    def intersection_update(self, *s: Iterable[Any]) -> None: ...
    def __iand__(self, s: AbstractSet[Any]) -> Self: ...
    def symmetric_difference(self, __s: Iterable[_T]) -> MutableSet[_T]: ...
    def __xor__(self, s: AbstractSet[_S]) -> MutableSet[_T | _S]: ...
    def symmetric_difference_update(self, other: Iterable[Any]) -> None: ...
    def __ixor__(self, other: AbstractSet[_S]) -> MutableSet[_T | _S]: ...
    def issubset(self, __s: Iterable[Any]) -> bool: ...
    def issuperset(self, __s: Iterable[Any]) -> bool: ...
    def clear(self) -> None: ...
    def copy(self) -> AbstractSet[_T]: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: AbstractSet[Any]) -> bool: ...
    def __le__(self, other: AbstractSet[Any]) -> bool: ...
    def __gt__(self, other: AbstractSet[Any]) -> bool: ...
    def __ge__(self, other: AbstractSet[Any]) -> bool: ...
    def __hash__(self) -> NoReturn: ...
