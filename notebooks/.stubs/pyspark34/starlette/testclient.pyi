import anyio
import httpx
import typing
from _typeshed import Incomplete
from concurrent.futures import Future
from starlette._utils import is_async_callable as is_async_callable
from starlette.types import ASGIApp as ASGIApp, Message as Message, Receive as Receive, Scope as Scope, Send as Send
from starlette.websockets import WebSocketDisconnect as WebSocketDisconnect
from typing import TypedDict

ASGIInstance: Incomplete
ASGI2App: Incomplete
ASGI3App: Incomplete

class _WrapASGI2:
    """
    Provide an ASGI3 interface onto an ASGI2 app.
    """
    app: Incomplete
    def __init__(self, app: ASGI2App) -> None: ...
    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None: ...

class _AsyncBackend(TypedDict):
    backend: str
    backend_options: typing.Dict[str, typing.Any]

class _Upgrade(Exception):
    session: Incomplete
    def __init__(self, session: WebSocketTestSession) -> None: ...

class WebSocketTestSession:
    app: Incomplete
    scope: Incomplete
    accepted_subprotocol: Incomplete
    portal_factory: Incomplete
    extra_headers: Incomplete
    def __init__(self, app: ASGI3App, scope: Scope, portal_factory: _PortalFactoryType) -> None: ...
    exit_stack: Incomplete
    portal: Incomplete
    def __enter__(self) -> WebSocketTestSession: ...
    def __exit__(self, *args: typing.Any) -> None: ...
    def send(self, message: Message) -> None: ...
    def send_text(self, data: str) -> None: ...
    def send_bytes(self, data: bytes) -> None: ...
    def send_json(self, data: typing.Any, mode: str = 'text') -> None: ...
    def close(self, code: int = 1000) -> None: ...
    def receive(self) -> Message: ...
    def receive_text(self) -> str: ...
    def receive_bytes(self) -> bytes: ...
    def receive_json(self, mode: str = 'text') -> typing.Any: ...

class _TestClientTransport(httpx.BaseTransport):
    app: Incomplete
    raise_server_exceptions: Incomplete
    root_path: Incomplete
    portal_factory: Incomplete
    app_state: Incomplete
    def __init__(self, app: ASGI3App, portal_factory: _PortalFactoryType, raise_server_exceptions: bool = True, root_path: str = '', *, app_state: typing.Dict[str, typing.Any]) -> None: ...
    def handle_request(self, request: httpx.Request) -> httpx.Response: ...

class TestClient(httpx.Client):
    __test__: bool
    task: Future[None]
    portal: anyio.abc.BlockingPortal | None
    async_backend: Incomplete
    app: Incomplete
    app_state: Incomplete
    def __init__(self, app: ASGIApp, base_url: str = 'http://testserver', raise_server_exceptions: bool = True, root_path: str = '', backend: str = 'asyncio', backend_options: typing.Dict[str, typing.Any] | None = None, cookies: httpx._client.CookieTypes = None, headers: typing.Dict[str, str] = None) -> None: ...
    def request(self, method: str, url: httpx._types.URLTypes, *, content: httpx._types.RequestContent | None = None, data: _RequestData | None = None, files: httpx._types.RequestFiles | None = None, json: typing.Any = None, params: httpx._types.QueryParamTypes | None = None, headers: httpx._types.HeaderTypes | None = None, cookies: httpx._types.CookieTypes | None = None, auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = ..., follow_redirects: bool | None = None, allow_redirects: bool | None = None, timeout: httpx._client.TimeoutTypes | httpx._client.UseClientDefault = ..., extensions: typing.Dict[str, typing.Any] | None = None) -> httpx.Response: ...
    def get(self, url: httpx._types.URLTypes, *, params: httpx._types.QueryParamTypes | None = None, headers: httpx._types.HeaderTypes | None = None, cookies: httpx._types.CookieTypes | None = None, auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = ..., follow_redirects: bool | None = None, allow_redirects: bool | None = None, timeout: httpx._client.TimeoutTypes | httpx._client.UseClientDefault = ..., extensions: typing.Dict[str, typing.Any] | None = None) -> httpx.Response: ...
    def options(self, url: httpx._types.URLTypes, *, params: httpx._types.QueryParamTypes | None = None, headers: httpx._types.HeaderTypes | None = None, cookies: httpx._types.CookieTypes | None = None, auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = ..., follow_redirects: bool | None = None, allow_redirects: bool | None = None, timeout: httpx._client.TimeoutTypes | httpx._client.UseClientDefault = ..., extensions: typing.Dict[str, typing.Any] | None = None) -> httpx.Response: ...
    def head(self, url: httpx._types.URLTypes, *, params: httpx._types.QueryParamTypes | None = None, headers: httpx._types.HeaderTypes | None = None, cookies: httpx._types.CookieTypes | None = None, auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = ..., follow_redirects: bool | None = None, allow_redirects: bool | None = None, timeout: httpx._client.TimeoutTypes | httpx._client.UseClientDefault = ..., extensions: typing.Dict[str, typing.Any] | None = None) -> httpx.Response: ...
    def post(self, url: httpx._types.URLTypes, *, content: httpx._types.RequestContent | None = None, data: _RequestData | None = None, files: httpx._types.RequestFiles | None = None, json: typing.Any = None, params: httpx._types.QueryParamTypes | None = None, headers: httpx._types.HeaderTypes | None = None, cookies: httpx._types.CookieTypes | None = None, auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = ..., follow_redirects: bool | None = None, allow_redirects: bool | None = None, timeout: httpx._client.TimeoutTypes | httpx._client.UseClientDefault = ..., extensions: typing.Dict[str, typing.Any] | None = None) -> httpx.Response: ...
    def put(self, url: httpx._types.URLTypes, *, content: httpx._types.RequestContent | None = None, data: _RequestData | None = None, files: httpx._types.RequestFiles | None = None, json: typing.Any = None, params: httpx._types.QueryParamTypes | None = None, headers: httpx._types.HeaderTypes | None = None, cookies: httpx._types.CookieTypes | None = None, auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = ..., follow_redirects: bool | None = None, allow_redirects: bool | None = None, timeout: httpx._client.TimeoutTypes | httpx._client.UseClientDefault = ..., extensions: typing.Dict[str, typing.Any] | None = None) -> httpx.Response: ...
    def patch(self, url: httpx._types.URLTypes, *, content: httpx._types.RequestContent | None = None, data: _RequestData | None = None, files: httpx._types.RequestFiles | None = None, json: typing.Any = None, params: httpx._types.QueryParamTypes | None = None, headers: httpx._types.HeaderTypes | None = None, cookies: httpx._types.CookieTypes | None = None, auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = ..., follow_redirects: bool | None = None, allow_redirects: bool | None = None, timeout: httpx._client.TimeoutTypes | httpx._client.UseClientDefault = ..., extensions: typing.Dict[str, typing.Any] | None = None) -> httpx.Response: ...
    def delete(self, url: httpx._types.URLTypes, *, params: httpx._types.QueryParamTypes | None = None, headers: httpx._types.HeaderTypes | None = None, cookies: httpx._types.CookieTypes | None = None, auth: httpx._types.AuthTypes | httpx._client.UseClientDefault = ..., follow_redirects: bool | None = None, allow_redirects: bool | None = None, timeout: httpx._client.TimeoutTypes | httpx._client.UseClientDefault = ..., extensions: typing.Dict[str, typing.Any] | None = None) -> httpx.Response: ...
    def websocket_connect(self, url: str, subprotocols: typing.Sequence[str] = None, **kwargs: typing.Any) -> typing.Any: ...
    stream_send: Incomplete
    stream_receive: Incomplete
    exit_stack: Incomplete
    def __enter__(self) -> TestClient: ...
    def __exit__(self, *args: typing.Any) -> None: ...
    async def lifespan(self) -> None: ...
    async def wait_startup(self) -> None: ...
    async def wait_shutdown(self) -> None: ...
