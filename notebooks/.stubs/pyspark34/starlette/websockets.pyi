import enum
import typing
from _typeshed import Incomplete
from starlette.requests import HTTPConnection as HTTPConnection
from starlette.types import Message as Message, Receive as Receive, Scope as Scope, Send as Send

class WebSocketState(enum.Enum):
    CONNECTING: int
    CONNECTED: int
    DISCONNECTED: int

class WebSocketDisconnect(Exception):
    code: Incomplete
    reason: Incomplete
    def __init__(self, code: int = 1000, reason: str | None = None) -> None: ...

class WebSocket(HTTPConnection):
    client_state: Incomplete
    application_state: Incomplete
    def __init__(self, scope: Scope, receive: Receive, send: Send) -> None: ...
    async def receive(self) -> Message:
        """
        Receive ASGI websocket messages, ensuring valid state transitions.
        """
    async def send(self, message: Message) -> None:
        """
        Send ASGI websocket messages, ensuring valid state transitions.
        """
    async def accept(self, subprotocol: str | None = None, headers: typing.Iterable[typing.Tuple[bytes, bytes]] | None = None) -> None: ...
    async def receive_text(self) -> str: ...
    async def receive_bytes(self) -> bytes: ...
    async def receive_json(self, mode: str = 'text') -> typing.Any: ...
    async def iter_text(self) -> typing.AsyncIterator[str]: ...
    async def iter_bytes(self) -> typing.AsyncIterator[bytes]: ...
    async def iter_json(self) -> typing.AsyncIterator[typing.Any]: ...
    async def send_text(self, data: str) -> None: ...
    async def send_bytes(self, data: bytes) -> None: ...
    async def send_json(self, data: typing.Any, mode: str = 'text') -> None: ...
    async def close(self, code: int = 1000, reason: str | None = None) -> None: ...

class WebSocketClose:
    code: Incomplete
    reason: Incomplete
    def __init__(self, code: int = 1000, reason: str | None = None) -> None: ...
    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None: ...
