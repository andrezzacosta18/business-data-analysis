import typing
from _typeshed import Incomplete
from collections.abc import Sequence
from starlette.concurrency import run_in_threadpool as run_in_threadpool
from starlette.types import Scope as Scope
from urllib.parse import SplitResult as SplitResult

class Address(typing.NamedTuple):
    host: str
    port: int

class URL:
    def __init__(self, url: str = '', scope: Scope | None = None, **components: typing.Any) -> None: ...
    @property
    def components(self) -> SplitResult: ...
    @property
    def scheme(self) -> str: ...
    @property
    def netloc(self) -> str: ...
    @property
    def path(self) -> str: ...
    @property
    def query(self) -> str: ...
    @property
    def fragment(self) -> str: ...
    @property
    def username(self) -> None | str: ...
    @property
    def password(self) -> None | str: ...
    @property
    def hostname(self) -> None | str: ...
    @property
    def port(self) -> int | None: ...
    @property
    def is_secure(self) -> bool: ...
    def replace(self, **kwargs: typing.Any) -> URL: ...
    def include_query_params(self, **kwargs: typing.Any) -> URL: ...
    def replace_query_params(self, **kwargs: typing.Any) -> URL: ...
    def remove_query_params(self, keys: str | typing.Sequence[str]) -> URL: ...
    def __eq__(self, other: typing.Any) -> bool: ...

class URLPath(str):
    """
    A URL path string that may also hold an associated protocol and/or host.
    Used by the routing to return `url_path_for` matches.
    """
    def __new__(cls, path: str, protocol: str = '', host: str = '') -> URLPath: ...
    protocol: Incomplete
    host: Incomplete
    def __init__(self, path: str, protocol: str = '', host: str = '') -> None: ...
    def make_absolute_url(self, base_url: str | URL) -> URL: ...

class Secret:
    """
    Holds a string value that should not be revealed in tracebacks etc.
    You should cast the value to `str` at the point it is required.
    """
    def __init__(self, value: str) -> None: ...
    def __bool__(self) -> bool: ...

class CommaSeparatedStrings(Sequence):
    def __init__(self, value: str | typing.Sequence[str]) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: int | slice) -> typing.Any: ...
    def __iter__(self) -> typing.Iterator[str]: ...

class ImmutableMultiDict(typing.Mapping[_KeyType, _CovariantValueType]):
    def __init__(self, *args: ImmutableMultiDict[_KeyType, _CovariantValueType] | typing.Mapping[_KeyType, _CovariantValueType] | typing.Iterable[typing.Tuple[_KeyType, _CovariantValueType]], **kwargs: typing.Any) -> None: ...
    def getlist(self, key: typing.Any) -> typing.List[_CovariantValueType]: ...
    def keys(self) -> typing.KeysView[_KeyType]: ...
    def values(self) -> typing.ValuesView[_CovariantValueType]: ...
    def items(self) -> typing.ItemsView[_KeyType, _CovariantValueType]: ...
    def multi_items(self) -> typing.List[typing.Tuple[_KeyType, _CovariantValueType]]: ...
    def __getitem__(self, key: _KeyType) -> _CovariantValueType: ...
    def __contains__(self, key: typing.Any) -> bool: ...
    def __iter__(self) -> typing.Iterator[_KeyType]: ...
    def __len__(self) -> int: ...
    def __eq__(self, other: typing.Any) -> bool: ...

class MultiDict(ImmutableMultiDict[typing.Any, typing.Any]):
    def __setitem__(self, key: typing.Any, value: typing.Any) -> None: ...
    def __delitem__(self, key: typing.Any) -> None: ...
    def pop(self, key: typing.Any, default: typing.Any = None) -> typing.Any: ...
    def popitem(self) -> typing.Tuple: ...
    def poplist(self, key: typing.Any) -> typing.List: ...
    def clear(self) -> None: ...
    def setdefault(self, key: typing.Any, default: typing.Any = None) -> typing.Any: ...
    def setlist(self, key: typing.Any, values: typing.List) -> None: ...
    def append(self, key: typing.Any, value: typing.Any) -> None: ...
    def update(self, *args: MultiDict | typing.Mapping | typing.List[typing.Tuple[typing.Any, typing.Any]], **kwargs: typing.Any) -> None: ...

class QueryParams(ImmutableMultiDict[str, str]):
    """
    An immutable multidict.
    """
    def __init__(self, *args: ImmutableMultiDict | typing.Mapping | typing.List[typing.Tuple[typing.Any, typing.Any]] | str | bytes, **kwargs: typing.Any) -> None: ...

class UploadFile:
    """
    An uploaded file included as part of the request data.
    """
    filename: Incomplete
    file: Incomplete
    size: Incomplete
    headers: Incomplete
    def __init__(self, file: typing.BinaryIO, *, size: int | None = None, filename: str | None = None, headers: Headers | None = None) -> None: ...
    @property
    def content_type(self) -> str | None: ...
    async def write(self, data: bytes) -> None: ...
    async def read(self, size: int = -1) -> bytes: ...
    async def seek(self, offset: int) -> None: ...
    async def close(self) -> None: ...

class FormData(ImmutableMultiDict[str, UploadFile | str]):
    """
    An immutable multidict, containing both file uploads and text input.
    """
    def __init__(self, *args: FormData | typing.Mapping[str, str | UploadFile] | typing.List[typing.Tuple[str, str | UploadFile]], **kwargs: str | UploadFile) -> None: ...
    async def close(self) -> None: ...

class Headers(typing.Mapping[str, str]):
    """
    An immutable, case-insensitive multidict.
    """
    def __init__(self, headers: typing.Mapping[str, str] | None = None, raw: typing.List[typing.Tuple[bytes, bytes]] | None = None, scope: typing.MutableMapping[str, typing.Any] | None = None) -> None: ...
    @property
    def raw(self) -> typing.List[typing.Tuple[bytes, bytes]]: ...
    def keys(self) -> typing.List[str]: ...
    def values(self) -> typing.List[str]: ...
    def items(self) -> typing.List[typing.Tuple[str, str]]: ...
    def getlist(self, key: str) -> typing.List[str]: ...
    def mutablecopy(self) -> MutableHeaders: ...
    def __getitem__(self, key: str) -> str: ...
    def __contains__(self, key: typing.Any) -> bool: ...
    def __iter__(self) -> typing.Iterator[typing.Any]: ...
    def __len__(self) -> int: ...
    def __eq__(self, other: typing.Any) -> bool: ...

class MutableHeaders(Headers):
    def __setitem__(self, key: str, value: str) -> None:
        """
        Set the header `key` to `value`, removing any duplicate entries.
        Retains insertion order.
        """
    def __delitem__(self, key: str) -> None:
        """
        Remove the header `key`.
        """
    def __ior__(self, other: typing.Mapping[str, str]) -> MutableHeaders: ...
    def __or__(self, other: typing.Mapping[str, str]) -> MutableHeaders: ...
    @property
    def raw(self) -> typing.List[typing.Tuple[bytes, bytes]]: ...
    def setdefault(self, key: str, value: str) -> str:
        """
        If the header `key` does not exist, then set it to `value`.
        Returns the header value.
        """
    def update(self, other: typing.Mapping[str, str]) -> None: ...
    def append(self, key: str, value: str) -> None:
        """
        Append a header, preserving any duplicate entries.
        """
    def add_vary_header(self, vary: str) -> None: ...

class State:
    """
    An object that can be used to store arbitrary state.

    Used for `request.state` and `app.state`.
    """
    def __init__(self, state: typing.Dict[str, typing.Any] | None = None) -> None: ...
    def __setattr__(self, key: typing.Any, value: typing.Any) -> None: ...
    def __getattr__(self, key: typing.Any) -> typing.Any: ...
    def __delattr__(self, key: typing.Any) -> None: ...
