import pbr
import setuptools
from _typeshed import Incomplete
from collections.abc import Generator
from nose import commands
from pbr import builddoc as builddoc, extra_files as extra_files, git as git, options as options, testr_command as testr_command, version as version
from setuptools.command import develop, egg_info, install, install_scripts, sdist

REQUIREMENTS_FILES: Incomplete
PY_REQUIREMENTS_FILES: Incomplete
TEST_REQUIREMENTS_FILES: Incomplete

def get_requirements_files(): ...
def append_text_list(config, key, text_list) -> None:
    """Append a 
 separated list to possibly existing value."""
def get_reqs_from_files(requirements_files): ...
def egg_fragment(match): ...
def parse_requirements(requirements_files: Incomplete | None = None, strip_markers: bool = False): ...
def parse_dependency_links(requirements_files: Incomplete | None = None): ...

class InstallWithGit(install.install):
    """Extracts ChangeLog and AUTHORS from git then installs.

    This is useful for e.g. readthedocs where the package is
    installed and then docs built.
    """
    command_name: str
    def run(self): ...

class LocalInstall(install.install):
    """Runs python setup.py install in a sensible manner.

    Force a non-egg installed in the manner of
    single-version-externally-managed, which allows us to install manpages
    and config files.
    """
    command_name: str
    def run(self): ...

class TestrTest(testr_command.Testr):
    """Make setup.py test do the right thing."""
    command_name: str
    description: str
    def run(self) -> None: ...

class LocalRPMVersion(setuptools.Command):
    __doc__: str
    description = __doc__
    user_options: Incomplete
    command_name: str
    def run(self) -> None: ...
    def initialize_options(self) -> None: ...
    def finalize_options(self) -> None: ...

class LocalDebVersion(setuptools.Command):
    __doc__: str
    description = __doc__
    user_options: Incomplete
    command_name: str
    def run(self) -> None: ...
    def initialize_options(self) -> None: ...
    def finalize_options(self) -> None: ...

def have_testr(): ...

class NoseTest(commands.nosetests):
    """Fallback test runner if testr is a no-go."""
    command_name: str
    description: str
    def run(self) -> None: ...

def have_nose(): ...

ENTRY_POINTS_MAP: Incomplete

def generate_script(group, entry_point, header, template):
    '''Generate the script based on the template.

    :param str group:
        The entry-point group name, e.g., "console_scripts".
    :param str header:
        The first line of the script, e.g., "!#/usr/bin/env python".
    :param str template:
        The script template.
    :returns:
        The templated script content
    :rtype:
        str
    '''
def override_get_script_args(dist, executable=...) -> Generator[Incomplete, None, None]:
    """Override entrypoints console_script."""

class LocalDevelop(develop.develop):
    command_name: str
    def install_wrapper_scripts(self, dist): ...

class LocalInstallScripts(install_scripts.install_scripts):
    """Intercepts console scripts entry_points."""
    command_name: str
    outfiles: Incomplete
    def run(self) -> None: ...

class LocalManifestMaker(egg_info.manifest_maker):
    """Add any files that are in git and some standard sensible files."""
    def add_defaults(self) -> None:
        """Add all the default files to self.filelist:

        Extends the functionality provided by distutils to also included
        additional sane defaults, such as the ``AUTHORS`` and ``ChangeLog``
        files generated by *pbr*.

        Warns if (``README`` or ``README.txt``) or ``setup.py`` are missing;
        everything else is optional.
        """

class LocalEggInfo(egg_info.egg_info):
    """Override the egg_info command to regenerate SOURCES.txt sensibly."""
    command_name: str
    filelist: Incomplete
    def find_sources(self) -> None:
        """Generate SOURCES.txt only if there isn't one already.

        If we are in an sdist command, then we always want to update
        SOURCES.txt. If we are not in an sdist command, then it doesn't
        matter one flip, and is actually destructive.
        However, if we're in a git context, it's always the right thing to do
        to recreate SOURCES.txt
        """

class LocalSDist(sdist.sdist):
    """Builds the ChangeLog and Authors files from VC first."""
    command_name: str
    def checking_reno(self):
        """Ensure reno is installed and configured.

        We can't run reno-based commands if reno isn't installed/available, and
        don't want to if the user isn't using it.
        """
    sub_commands: Incomplete
    def run(self) -> None: ...
    def make_distribution(self) -> None: ...
LocalBuildDoc = builddoc.LocalBuildDoc

def have_sphinx(): ...
def get_version(package_name, pre_version: Incomplete | None = None):
    """Get the version of the project.

    First, try getting it from PKG-INFO or METADATA, if it exists. If it does,
    that means we're in a distribution tarball or that install has happened.
    Otherwise, if there is no PKG-INFO or METADATA file, pull the version
    from git.

    We do not support setup.py version sanity in git archive tarballs, nor do
    we support packagers directly sucking our git repo into theirs. We expect
    that a source tarball be made from our git repo - or that if someone wants
    to make a source tarball from a fork of our repo with additional tags in it
    that they understand and desire the results of doing that.

    :param pre_version: The version field from setup.cfg - if set then this
        version will be the next release.
    """
write_pbr_json = pbr.pbr_json.write_pbr_json
