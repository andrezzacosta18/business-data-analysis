from _typeshed import Incomplete
from gevent import getcurrent as getcurrent
from gevent._ffi.loop import AbstractCallbacks as AbstractCallbacks, AbstractLoop as AbstractLoop, EVENTS as EVENTS, assign_standard_callbacks as assign_standard_callbacks
from gevent._interfaces import ILoop as ILoop
from gevent.exceptions import LoopExit as LoopExit
from typing import NamedTuple

ffi: Incomplete
libuv: Incomplete

class _Callbacks(AbstractCallbacks):
    def python_sigchld_callback(self, watcher_ptr, _signum) -> None: ...
    def python_timer0_callback(self, watcher_ptr): ...
    def python_queue_callback(self, watcher_ptr, revents) -> None: ...
GEVENT_CORE_EVENTS = EVENTS
READ: Incomplete
WRITE: Incomplete

def get_version(): ...
def get_header_version(): ...
def supported_backends(): ...

class loop(AbstractLoop):
    approx_timer_resolution: float
    CALLBACK_CHECK_COUNT: Incomplete
    SIGNAL_CHECK_INTERVAL_MS: int
    error_handler: Incomplete
    def __init__(self, flags: Incomplete | None = None, default: Incomplete | None = None) -> None: ...
    @property
    def ptr(self): ...

    class _HandleState(NamedTuple):
        handle: Incomplete
        type: Incomplete
        watcher: Incomplete
        ref: Incomplete
        active: Incomplete
        closing: Incomplete
    def debug(self):
        """
        Return all the handles that are open and their ref status.
        """
    def ref(self) -> None: ...
    def unref(self) -> None: ...
    def break_(self, how: Incomplete | None = None) -> None: ...
    def reinit(self) -> None: ...
    def run(self, nowait: bool = False, once: bool = False): ...
    def now(self): ...
    def update_now(self) -> None: ...
    def fileno(self): ...
    def install_sigchld(self) -> None: ...
    def reset_sigchld(self) -> None: ...
    def io(self, fd, events, ref: bool = True, priority: Incomplete | None = None): ...
    def prepare(self, ref: bool = True, priority: Incomplete | None = None) -> None: ...
