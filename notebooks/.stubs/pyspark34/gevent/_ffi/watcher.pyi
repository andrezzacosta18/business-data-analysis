from _typeshed import Incomplete
from gevent._compat import fsencode as fsencode
from gevent._config import config as config
from gevent._ffi import DEBUG as DEBUG, GEVENT_DEBUG_LEVEL as GEVENT_DEBUG_LEVEL
from gevent._ffi.loop import GEVENT_CORE_EVENTS as GEVENT_CORE_EVENTS
from gevent._util import LazyOnClass as LazyOnClass

def tracemalloc(init): ...

class _TB:
    lines: Incomplete
    def __init__(self, lines) -> None: ...
    def format(self): ...

ALLOW_WATCHER_DEL: Incomplete

class ResourceWarning(Warning):
    """Python 2 fallback"""
class _NoWatcherResult(int): ...

def events_to_str(event_field, all_events): ...
def not_while_active(func): ...
def only_if_watcher(func): ...

class AbstractWatcherType(type):
    """
    Base metaclass for watchers.

    To use, you will:

    - subclass the watcher class defined from this type.
    - optionally subclass this type
    """
    def __new__(cls, name, bases, cls_dict): ...
    def new_handle(cls, obj): ...
    def new(cls, kind): ...

class watcher:
    loop: Incomplete
    def __init__(self, _loop, ref: bool = True, priority: Incomplete | None = None, args=...) -> None: ...
    def close(self) -> None: ...
    def __enter__(self): ...
    def __exit__(self, t: type[BaseException] | None, v: BaseException | None, tb: types.TracebackType | None) -> None: ...
    def __del__(self) -> None: ...
    @property
    def ref(self) -> None: ...
    callback: Incomplete
    args: Incomplete
    def start(self, callback, *args) -> None: ...
    def stop(self) -> None: ...
    priority: Incomplete
    @property
    def active(self): ...
    @property
    def pending(self): ...

class IoMixin:
    EVENT_MASK: int
    def __init__(self, loop, fd, events, ref: bool = True, priority: Incomplete | None = None, _args: Incomplete | None = None) -> None: ...
    def start(self, callback, *args, **kwargs) -> None: ...

class TimerMixin:
    def __init__(self, loop, after: float = 0.0, repeat: float = 0.0, ref: bool = True, priority: Incomplete | None = None) -> None: ...
    def start(self, callback, *args, **kw) -> None: ...
    def again(self, callback, *args, **kw) -> None: ...

class SignalMixin:
    def __init__(self, loop, signalnum, ref: bool = True, priority: Incomplete | None = None) -> None: ...

class IdleMixin: ...
class PrepareMixin: ...
class CheckMixin: ...
class ForkMixin: ...

class AsyncMixin:
    def send(self) -> None: ...
    def send_ignoring_arg(self, _ignored):
        """
        Calling compatibility with ``greenlet.switch(arg)``
        as used by waiters that have ``rawlink``.

        This is an advanced method, not usually needed.
        """
    @property
    def pending(self) -> None: ...

class ChildMixin:
    def __init__(self, loop, pid, trace: int = 0, ref: bool = True) -> None: ...
    @property
    def pid(self): ...
    @property
    def rpid(self): ...
    @property
    def rstatus(self): ...

class StatMixin:
    def __init__(self, _loop, path, interval: float = 0.0, ref: bool = True, priority: Incomplete | None = None) -> None: ...
    @property
    def path(self): ...
    @property
    def attr(self) -> None: ...
    @property
    def prev(self) -> None: ...
    @property
    def interval(self): ...
