from _typeshed import Incomplete

__all__ = ['AbstractLoop', 'assign_standard_callbacks']

class _EVENTSType: ...

class _DiscardedSet(frozenset):
    def discard(self, o) -> None:
        """Does nothing."""

class AbstractCallbacks:
    ffi: Incomplete
    callbacks: Incomplete
    def __init__(self, ffi) -> None: ...
    def from_handle(self, handle): ...
    def python_callback(self, handle, revents):
        """
        Returns an integer having one of three values:

        - -1
          An exception occurred during the callback and you must call
          :func:`_python_handle_error` to deal with it. The Python watcher
          object will have the exception tuple saved in ``_exc_info``.
        - 1
          Everything went according to plan. You should check to see if the native
          watcher is still active, and call :func:`python_stop` if it is not. This will
          clean up the memory. Finding the watcher still active at the event loop level,
          but not having stopped itself at the gevent level is a buggy scenario and
          shouldn't happen.
        - 2
          Everything went according to plan, but the watcher has already
          been stopped. Its memory may no longer be valid.

        This function should never return 0, as that's the default value that
        Python exceptions will produce.
        """
    def python_handle_error(self, handle, _revents) -> None: ...
    def unhandled_onerror(self, t, v, tb): ...
    def python_stop(self, handle) -> None: ...
    def python_check_callback(self, watcher_ptr) -> None: ...
    def python_check_callback(self, watcher_ptr) -> None: ...
    def python_prepare_callback(self, watcher_ptr) -> None: ...
    def check_callback_onerror(self, t, v, tb) -> None: ...

def assign_standard_callbacks(ffi, lib, callbacks_class, extras=()):
    """
    Given the typical *ffi* and *lib* arguments, and a subclass of :class:`AbstractCallbacks`
    in *callbacks_class*, set up the ``def_extern`` Python callbacks from C
    into an instance of *callbacks_class*.

    :param tuple extras: If given, this is a sequence of ``(name, error_function)``
      additional callbacks to register. Each *name* is an attribute of
      the *callbacks_class* instance. (Each element cas also be just a *name*.)
    :return: The *callbacks_class* instance. This object must be kept alive,
      typically at module scope.
    """

class AbstractLoop:
    CALLBACK_CHECK_COUNT: int
    error_handler: Incomplete
    starting_timer_may_update_loop_time: bool
    def __init__(self, ffi, lib, watchers, flags: Incomplete | None = None, default: Incomplete | None = None) -> None: ...
    def destroy(self): ...
    @property
    def ptr(self): ...
    @property
    def WatcherType(self): ...
    @property
    def MAXPRI(self): ...
    @property
    def MINPRI(self): ...
    def handle_error(self, context, type, value, tb) -> None: ...
    def run(self, nowait: bool = False, once: bool = False) -> None: ...
    def reinit(self) -> None: ...
    def ref(self) -> None: ...
    def unref(self) -> None: ...
    def break_(self, how: Incomplete | None = None) -> None: ...
    def verify(self) -> None: ...
    def now(self) -> None: ...
    def update_now(self) -> None: ...
    def update(self) -> None: ...
    @property
    def default(self): ...
    @property
    def iteration(self): ...
    @property
    def depth(self): ...
    @property
    def backend_int(self): ...
    @property
    def backend(self): ...
    @property
    def pendingcnt(self): ...
    def io(self, fd, events, ref: bool = True, priority: Incomplete | None = None): ...
    def closing_fd(self, fd): ...
    def timer(self, after, repeat: float = 0.0, ref: bool = True, priority: Incomplete | None = None): ...
    def signal(self, signum, ref: bool = True, priority: Incomplete | None = None): ...
    def idle(self, ref: bool = True, priority: Incomplete | None = None): ...
    def prepare(self, ref: bool = True, priority: Incomplete | None = None): ...
    def check(self, ref: bool = True, priority: Incomplete | None = None): ...
    def fork(self, ref: bool = True, priority: Incomplete | None = None): ...
    def async_(self, ref: bool = True, priority: Incomplete | None = None): ...
    def child(self, pid, trace: int = 0, ref: bool = True): ...
    def install_sigchld(self) -> None: ...
    def stat(self, path, interval: float = 0.0, ref: bool = True, priority: Incomplete | None = None): ...
    def callback(self, priority: Incomplete | None = None): ...
    def run_callback(self, func, *args): ...
    def run_callback_threadsafe(self, func, *args): ...
    def fileno(self) -> None: ...
    @property
    def activecnt(self): ...
