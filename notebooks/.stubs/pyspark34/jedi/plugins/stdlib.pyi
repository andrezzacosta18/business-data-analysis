from _typeshed import Incomplete
from collections.abc import Generator
from jedi import debug as debug
from jedi.inference import analysis as analysis, compiled as compiled
from jedi.inference.arguments import AbstractArguments as AbstractArguments, ParamIssue as ParamIssue, TreeArgumentsWrapper as TreeArgumentsWrapper, iterate_argument_clinic as iterate_argument_clinic, repack_with_argument_clinic as repack_with_argument_clinic
from jedi.inference.base_value import ContextualizedNode as ContextualizedNode, LazyValueWrapper as LazyValueWrapper, NO_VALUES as NO_VALUES, ValueSet as ValueSet, ValueWrapper as ValueWrapper
from jedi.inference.filters import AttributeOverwrite as AttributeOverwrite, DictFilter as DictFilter, ParserTreeFilter as ParserTreeFilter, publish_method as publish_method
from jedi.inference.helpers import get_str_or_none as get_str_or_none
from jedi.inference.lazy_value import LazyKnownValue as LazyKnownValue, LazyKnownValues as LazyKnownValues, LazyTreeValue as LazyTreeValue
from jedi.inference.names import BaseTreeParamName as BaseTreeParamName, ValueName as ValueName
from jedi.inference.signature import AbstractSignature as AbstractSignature, SignatureWrapper as SignatureWrapper
from jedi.inference.utils import safe_property as safe_property
from jedi.inference.value import ClassValue as ClassValue, ModuleValue as ModuleValue, iterable as iterable
from jedi.inference.value.function import FunctionMixin as FunctionMixin
from jedi.inference.value.instance import AnonymousMethodExecutionContext as AnonymousMethodExecutionContext, MethodExecutionContext as MethodExecutionContext
from jedi.inference.value.klass import ClassMixin as ClassMixin

def execute(callback): ...
def argument_clinic(clinic_string, want_value: bool = False, want_context: bool = False, want_arguments: bool = False, want_inference_state: bool = False, want_callback: bool = False):
    """
    Works like Argument Clinic (PEP 436), to validate function params.
    """
def builtins_next(iterators, defaults, inference_state): ...
def builtins_iter(iterators_or_callables, defaults): ...
def builtins_getattr(objects, names, defaults: Incomplete | None = None): ...
def builtins_type(objects, bases, dicts): ...

class SuperInstance(LazyValueWrapper):
    """To be used like the object ``super`` returns."""
    inference_state: Incomplete
    def __init__(self, inference_state, instance) -> None: ...
    def get_filters(self, origin_scope: Incomplete | None = None) -> Generator[Incomplete, None, None]: ...

def builtins_super(types, objects, context): ...

class ReversedObject(AttributeOverwrite):
    def __init__(self, reversed_obj, iter_list) -> None: ...
    def py__iter__(self, contextualized_node: Incomplete | None = None): ...

def builtins_reversed(sequences, value, arguments): ...
def builtins_isinstance(objects, types, arguments, inference_state): ...

class StaticMethodObject(ValueWrapper):
    def py__get__(self, instance, class_value): ...

def builtins_staticmethod(functions): ...

class ClassMethodObject(ValueWrapper):
    def __init__(self, class_method_obj, function) -> None: ...
    def py__get__(self, instance, class_value): ...

class ClassMethodGet(ValueWrapper):
    def __init__(self, get_method, klass, function) -> None: ...
    def get_signatures(self): ...
    def py__call__(self, arguments): ...

class ClassMethodArguments(TreeArgumentsWrapper):
    def __init__(self, klass, arguments) -> None: ...
    def unpack(self, func: Incomplete | None = None) -> Generator[Incomplete, None, None]: ...

def builtins_classmethod(functions, value, arguments): ...

class PropertyObject(AttributeOverwrite, ValueWrapper):
    api_type: str
    def __init__(self, property_obj, function) -> None: ...
    def py__get__(self, instance, class_value): ...

def builtins_property(functions, callback): ...
def collections_namedtuple(value, arguments, callback):
    """
    Implementation of the namedtuple function.

    This has to be done by processing the namedtuple class template and
    inferring the result.

    """

class PartialObject(ValueWrapper):
    def __init__(self, actual_value, arguments, instance: Incomplete | None = None) -> None: ...
    def get_signatures(self): ...
    def py__call__(self, arguments): ...
    def py__doc__(self):
        """
        In CPython partial does not replace the docstring. However we are still
        imitating it here, because we want this docstring to be worth something
        for the user.
        """
    def py__get__(self, instance, class_value): ...

class PartialMethodObject(PartialObject):
    def py__get__(self, instance, class_value): ...

class PartialSignature(SignatureWrapper):
    def __init__(self, wrapped_signature, skipped_arg_count, skipped_arg_set) -> None: ...
    def get_param_names(self, resolve_stars: bool = False): ...

class MergedPartialArguments(AbstractArguments):
    def __init__(self, partial_arguments, call_arguments, instance: Incomplete | None = None) -> None: ...
    def unpack(self, funcdef: Incomplete | None = None) -> Generator[Incomplete, None, None]: ...

def functools_partial(value, arguments, callback): ...
def functools_partialmethod(value, arguments, callback): ...

class DataclassWrapper(ValueWrapper, ClassMixin):
    def get_signatures(self): ...

class DataclassSignature(AbstractSignature):
    def __init__(self, value, param_names) -> None: ...
    def get_param_names(self, resolve_stars: bool = False): ...

class DataclassParamName(BaseTreeParamName):
    annotation_node: Incomplete
    default_node: Incomplete
    def __init__(self, parent_context, tree_name, annotation_node, default_node) -> None: ...
    def get_kind(self): ...
    def infer(self): ...

class ItemGetterCallable(ValueWrapper):
    def __init__(self, instance, args_value_set) -> None: ...
    def py__call__(self, item_value_set): ...

class WrapsCallable(ValueWrapper):
    def py__call__(self, funcs): ...

class Wrapped(ValueWrapper, FunctionMixin):
    def __init__(self, func, original_function) -> None: ...
    @property
    def name(self): ...
    def get_signature_functions(self): ...

def get_metaclass_filters(func): ...

class EnumInstance(LazyValueWrapper):
    inference_state: Incomplete
    tree_node: Incomplete
    def __init__(self, cls, name) -> None: ...
    def name(self): ...
    def get_filters(self, origin_scope: Incomplete | None = None) -> Generator[Incomplete, None, None]: ...

def tree_name_to_values(func): ...
