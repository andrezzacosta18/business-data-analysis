from _typeshed import Incomplete
from collections.abc import Generator
from jedi import debug as debug
from jedi.inference import compiled as compiled
from jedi.inference.arguments import ValuesArguments as ValuesArguments, unpack_arglist as unpack_arglist
from jedi.inference.base_value import NO_VALUES as NO_VALUES, ValueSet as ValueSet, iterator_to_value_set as iterator_to_value_set
from jedi.inference.cache import CachedMetaClass as CachedMetaClass, inference_state_method_cache as inference_state_method_cache, inference_state_method_generator_cache as inference_state_method_generator_cache
from jedi.inference.context import ClassContext as ClassContext
from jedi.inference.filters import ParserTreeFilter as ParserTreeFilter
from jedi.inference.gradual.generics import LazyGenericManager as LazyGenericManager, TupleGenericManager as TupleGenericManager
from jedi.inference.lazy_value import LazyKnownValues as LazyKnownValues, LazyTreeValue as LazyTreeValue
from jedi.inference.names import TreeNameDefinition as TreeNameDefinition, ValueName as ValueName
from jedi.inference.value.function import FunctionAndClassBase as FunctionAndClassBase
from jedi.parser_utils import expr_is_dotted as expr_is_dotted, function_is_property as function_is_property, get_cached_parent_scope as get_cached_parent_scope
from jedi.plugins import plugin_manager as plugin_manager

class ClassName(TreeNameDefinition):
    def __init__(self, class_value, tree_name, name_context, apply_decorators) -> None: ...
    def infer(self) -> Generator[Incomplete, Incomplete, None]: ...
    @property
    def api_type(self): ...

class ClassFilter(ParserTreeFilter):
    def __init__(self, class_value, node_context: Incomplete | None = None, until_position: Incomplete | None = None, origin_scope: Incomplete | None = None, is_instance: bool = False) -> None: ...

class ClassMixin:
    def is_class(self): ...
    def is_class_mixin(self): ...
    def py__call__(self, arguments): ...
    def py__class__(self): ...
    @property
    def name(self): ...
    def py__name__(self): ...
    def py__mro__(self) -> Generator[Incomplete, None, None]: ...
    def get_filters(self, origin_scope: Incomplete | None = None, is_instance: bool = False, include_metaclasses: bool = True, include_type_when_class: bool = True) -> Generator[Incomplete, Incomplete, None]: ...
    def get_signatures(self): ...
    def get_type_hint(self, add_class_info: bool = True): ...
    def is_typeddict(self): ...
    def py__getitem__(self, index_value_set, contextualized_node): ...
    def with_generics(self, generics_tuple): ...
    def define_generics(self, type_var_dict): ...

class ClassValue(ClassMixin, FunctionAndClassBase, metaclass=CachedMetaClass):
    api_type: str
    def list_type_vars(self): ...
    def py__bases__(self): ...
    def get_metaclass_filters(self, metaclasses, is_instance): ...
    def get_metaclasses(self): ...
    def get_metaclass_signatures(self, metaclasses): ...
