import abc
from _typeshed import Incomplete
from collections.abc import Generator
from jedi import debug as debug, settings as settings
from jedi.inference import compiled as compiled
from jedi.inference.arguments import TreeArgumentsWrapper as TreeArgumentsWrapper, ValuesArguments as ValuesArguments
from jedi.inference.base_value import NO_VALUES as NO_VALUES, Value as Value, ValueSet as ValueSet, ValueWrapper as ValueWrapper, iterator_to_value_set as iterator_to_value_set
from jedi.inference.cache import inference_state_method_cache as inference_state_method_cache
from jedi.inference.compiled.value import CompiledValueFilter as CompiledValueFilter
from jedi.inference.filters import AbstractFilter as AbstractFilter, AnonymousFunctionExecutionFilter as AnonymousFunctionExecutionFilter
from jedi.inference.helpers import is_big_annoying_library as is_big_annoying_library, values_from_qualified_names as values_from_qualified_names
from jedi.inference.lazy_value import LazyKnownValue as LazyKnownValue, LazyKnownValues as LazyKnownValues
from jedi.inference.names import NameWrapper as NameWrapper, ParamName as ParamName, TreeNameDefinition as TreeNameDefinition, ValueName as ValueName
from jedi.inference.value.dynamic_arrays import get_dynamic_array_instance as get_dynamic_array_instance
from jedi.inference.value.function import BaseFunctionExecutionContext as BaseFunctionExecutionContext, FunctionExecutionContext as FunctionExecutionContext, FunctionMixin as FunctionMixin, FunctionNameInClass as FunctionNameInClass, FunctionValue as FunctionValue, OverloadedFunctionValue as OverloadedFunctionValue
from jedi.inference.value.klass import ClassFilter as ClassFilter
from jedi.parser_utils import function_is_classmethod as function_is_classmethod, function_is_staticmethod as function_is_staticmethod

class InstanceExecutedParamName(ParamName):
    def __init__(self, instance, function_value, tree_name) -> None: ...
    def infer(self): ...
    def matches_signature(self): ...

class AnonymousMethodExecutionFilter(AnonymousFunctionExecutionFilter):
    def __init__(self, instance, *args, **kwargs) -> None: ...

class AnonymousMethodExecutionContext(BaseFunctionExecutionContext):
    instance: Incomplete
    def __init__(self, instance, value) -> None: ...
    def get_filters(self, until_position: Incomplete | None = None, origin_scope: Incomplete | None = None) -> Generator[Incomplete, None, None]: ...
    def get_param_names(self): ...

class MethodExecutionContext(FunctionExecutionContext):
    instance: Incomplete
    def __init__(self, instance, *args, **kwargs) -> None: ...

class AbstractInstanceValue(Value, metaclass=abc.ABCMeta):
    api_type: str
    class_value: Incomplete
    def __init__(self, inference_state, parent_context, class_value) -> None: ...
    def is_instance(self): ...
    def get_qualified_names(self): ...
    def get_annotated_class_object(self): ...
    def py__class__(self): ...
    def py__bool__(self) -> None: ...
    @property
    @abc.abstractmethod
    def name(self): ...
    def get_signatures(self): ...
    def get_function_slot_names(self, name): ...
    def execute_function_slots(self, names, *inferred_args): ...
    def get_type_hint(self, add_class_info: bool = True): ...
    def py__getitem__(self, index_value_set, contextualized_node): ...
    def py__iter__(self, contextualized_node: Incomplete | None = None): ...

class CompiledInstance(AbstractInstanceValue):
    def __init__(self, inference_state, parent_context, class_value, arguments) -> None: ...
    def get_filters(self, origin_scope: Incomplete | None = None, include_self_names: bool = True) -> Generator[Incomplete, None, None]: ...
    @property
    def name(self): ...
    def is_stub(self): ...

class _BaseTreeInstance(AbstractInstanceValue):
    @property
    def array_type(self): ...
    @property
    def name(self): ...
    def get_filters(self, origin_scope: Incomplete | None = None, include_self_names: bool = True) -> Generator[Incomplete, None, None]: ...
    def create_instance_context(self, class_context, node): ...
    def py__getattribute__alternatives(self, string_name):
        """
        Since nothing was inferred, now check the __getattr__ and
        __getattribute__ methods. Stubs don't need to be checked, because
        they don't contain any logic.
        """
    def py__next__(self, contextualized_node: Incomplete | None = None) -> Generator[Incomplete, None, None]: ...
    def py__call__(self, arguments): ...
    def py__get__(self, instance, class_value):
        """
        obj may be None.
        """

class TreeInstance(_BaseTreeInstance):
    tree_node: Incomplete
    def __init__(self, inference_state, parent_context, class_value, arguments) -> None: ...
    def get_annotated_class_object(self): ...
    def get_key_values(self): ...
    def py__simple_getitem__(self, index): ...

class AnonymousInstance(_BaseTreeInstance): ...

class CompiledInstanceName(NameWrapper):
    def infer(self) -> Generator[Incomplete, None, None]: ...

class CompiledInstanceClassFilter(AbstractFilter):
    def __init__(self, instance, f) -> None: ...
    def get(self, name): ...
    def values(self): ...

class BoundMethod(FunctionMixin, ValueWrapper):
    instance: Incomplete
    def __init__(self, instance, class_context, function) -> None: ...
    def is_bound_method(self): ...
    @property
    def name(self): ...
    def py__class__(self): ...
    def py__call__(self, arguments): ...
    def get_signature_functions(self): ...
    def get_signatures(self): ...

class CompiledBoundMethod(ValueWrapper):
    def is_bound_method(self): ...
    def get_signatures(self): ...

class SelfName(TreeNameDefinition):
    """
    This name calculates the parent_context lazily.
    """
    class_context: Incomplete
    tree_name: Incomplete
    def __init__(self, instance, class_context, tree_name) -> None: ...
    @property
    def parent_context(self): ...
    def get_defining_qualified_value(self): ...
    def infer(self): ...

class LazyInstanceClassName(NameWrapper):
    def __init__(self, instance, class_member_name) -> None: ...
    def infer(self) -> Generator[Incomplete, Incomplete, None]: ...
    def get_signatures(self): ...
    def get_defining_qualified_value(self): ...

class InstanceClassFilter(AbstractFilter):
    """
    This filter is special in that it uses the class filter and wraps the
    resulting names in LazyInstanceClassName. The idea is that the class name
    filtering can be very flexible and always be reflected in instances.
    """
    def __init__(self, instance, class_filter) -> None: ...
    def get(self, name): ...
    def values(self): ...

class SelfAttributeFilter(ClassFilter):
    """
    This class basically filters all the use cases where `self.*` was assigned.
    """
    def __init__(self, instance, instance_class, node_context, origin_scope) -> None: ...

class InstanceArguments(TreeArgumentsWrapper):
    instance: Incomplete
    def __init__(self, instance, arguments) -> None: ...
    def unpack(self, func: Incomplete | None = None) -> Generator[Incomplete, Incomplete, None]: ...
