import abc
from _typeshed import Incomplete
from collections.abc import Generator
from jedi import debug as debug, parser_utils as parser_utils
from jedi.inference import compiled as compiled, docstrings as docstrings, flow_analysis as flow_analysis, recursion as recursion
from jedi.inference.base_value import ContextualizedNode as ContextualizedNode, NO_VALUES as NO_VALUES, TreeValue as TreeValue, ValueSet as ValueSet, ValueWrapper as ValueWrapper
from jedi.inference.cache import CachedMetaClass as CachedMetaClass, inference_state_method_cache as inference_state_method_cache
from jedi.inference.context import TreeContextMixin as TreeContextMixin, ValueContext as ValueContext
from jedi.inference.filters import AnonymousFunctionExecutionFilter as AnonymousFunctionExecutionFilter, FunctionExecutionFilter as FunctionExecutionFilter, ParserTreeFilter as ParserTreeFilter
from jedi.inference.gradual.generics import TupleGenericManager as TupleGenericManager
from jedi.inference.helpers import values_from_qualified_names as values_from_qualified_names
from jedi.inference.lazy_value import LazyKnownValue as LazyKnownValue, LazyKnownValues as LazyKnownValues, LazyTreeValue as LazyTreeValue
from jedi.inference.names import AbstractNameDefinition as AbstractNameDefinition, AnonymousParamName as AnonymousParamName, NameWrapper as NameWrapper, ParamName as ParamName, ValueName as ValueName
from jedi.inference.parser_cache import get_yield_exprs as get_yield_exprs
from jedi.inference.signature import TreeSignature as TreeSignature
from jedi.inference.value import iterable as iterable

class LambdaName(AbstractNameDefinition, metaclass=abc.ABCMeta):
    string_name: str
    api_type: str
    parent_context: Incomplete
    def __init__(self, lambda_value) -> None: ...
    @property
    def start_pos(self): ...
    def infer(self): ...

class FunctionAndClassBase(TreeValue):
    def get_qualified_names(self): ...

class FunctionMixin:
    api_type: str
    def get_filters(self, origin_scope: Incomplete | None = None) -> Generator[Incomplete, Incomplete, None]: ...
    def py__get__(self, instance, class_value): ...
    def get_param_names(self): ...
    @property
    def name(self): ...
    def is_function(self): ...
    def py__name__(self): ...
    def get_type_hint(self, add_class_info: bool = True): ...
    def py__call__(self, arguments): ...
    def get_signatures(self): ...

class FunctionValue(FunctionMixin, FunctionAndClassBase, metaclass=CachedMetaClass):
    @classmethod
    def from_context(cls, context, tree_node): ...
    def py__class__(self): ...
    def get_default_param_context(self): ...
    def get_signature_functions(self): ...

class FunctionNameInClass(NameWrapper):
    def __init__(self, class_context, name) -> None: ...
    def get_defining_qualified_value(self): ...

class MethodValue(FunctionValue):
    class_context: Incomplete
    def __init__(self, inference_state, class_context, *args, **kwargs) -> None: ...
    def get_default_param_context(self): ...
    def get_qualified_names(self): ...
    @property
    def name(self): ...

class BaseFunctionExecutionContext(ValueContext, TreeContextMixin, metaclass=abc.ABCMeta):
    def infer_annotations(self) -> None: ...
    def get_return_values(self, check_yields: bool = False): ...
    def get_yield_lazy_values(self, is_async: bool = False) -> Generator[Incomplete, Incomplete, None]: ...
    def merge_yield_values(self, is_async: bool = False): ...
    def is_generator(self): ...
    def infer(self):
        """
        Created to be used by inheritance.
        """

class FunctionExecutionContext(BaseFunctionExecutionContext):
    def __init__(self, function_value, arguments) -> None: ...
    def get_filters(self, until_position: Incomplete | None = None, origin_scope: Incomplete | None = None) -> Generator[Incomplete, None, None]: ...
    def infer_annotations(self): ...
    def get_param_names(self): ...

class AnonymousFunctionExecution(BaseFunctionExecutionContext):
    def infer_annotations(self): ...
    def get_filters(self, until_position: Incomplete | None = None, origin_scope: Incomplete | None = None) -> Generator[Incomplete, None, None]: ...
    def get_param_names(self): ...

class OverloadedFunctionValue(FunctionMixin, ValueWrapper):
    def __init__(self, function, overloaded_functions) -> None: ...
    def py__call__(self, arguments): ...
    def get_signature_functions(self): ...
    def get_type_hint(self, add_class_info: bool = True): ...
