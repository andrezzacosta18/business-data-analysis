import abc
from _typeshed import Incomplete
from collections.abc import Generator
from jedi import debug as debug
from jedi.cache import memoize_method as memoize_method
from jedi.inference.base_value import NO_VALUES as NO_VALUES, Value as Value, ValueSet as ValueSet
from jedi.inference.cache import inference_state_function_cache as inference_state_function_cache
from jedi.inference.context import CompiledContext as CompiledContext, CompiledModuleContext as CompiledModuleContext
from jedi.inference.filters import AbstractFilter as AbstractFilter
from jedi.inference.helpers import reraise_getitem_errors as reraise_getitem_errors
from jedi.inference.lazy_value import LazyKnownValue as LazyKnownValue
from jedi.inference.names import AbstractNameDefinition as AbstractNameDefinition, ParamNameInterface as ParamNameInterface, ValueNameMixin as ValueNameMixin
from jedi.inference.signature import BuiltinSignature as BuiltinSignature
from jedi.inference.utils import to_list as to_list
from pathlib import Path

class CheckAttribute:
    """Raises :exc:`AttributeError` if the attribute X is not available."""
    check_name: Incomplete
    def __init__(self, check_name: Incomplete | None = None) -> None: ...
    func: Incomplete
    def __call__(self, func): ...
    def __get__(self, instance, owner): ...

class CompiledValue(Value):
    access_handle: Incomplete
    def __init__(self, inference_state, access_handle, parent_context: Incomplete | None = None) -> None: ...
    def py__call__(self, arguments): ...
    def py__class__(self): ...
    def py__mro__(self): ...
    def py__bases__(self): ...
    def get_qualified_names(self): ...
    def py__bool__(self): ...
    def is_class(self): ...
    def is_function(self): ...
    def is_module(self): ...
    def is_compiled(self): ...
    def is_stub(self): ...
    def is_instance(self): ...
    def py__doc__(self): ...
    def get_param_names(self) -> Generator[Incomplete, None, None]: ...
    def get_signatures(self): ...
    @property
    def api_type(self): ...
    def get_filters(self, is_instance: bool = False, origin_scope: Incomplete | None = None) -> Generator[Incomplete, None, None]: ...
    def py__simple_getitem__(self, index): ...
    def py__getitem__(self, index_value_set, contextualized_node): ...
    def py__iter__(self, contextualized_node: Incomplete | None = None) -> Generator[Incomplete, Incomplete, None]: ...
    def py__name__(self): ...
    @property
    def name(self): ...
    def get_safe_value(self, default=...): ...
    def execute_operation(self, other, operator): ...
    def execute_annotation(self): ...
    def negate(self): ...
    def get_metaclasses(self): ...
    @property
    def array_type(self): ...
    def get_key_values(self): ...
    def get_type_hint(self, add_class_info: bool = True): ...

class CompiledModule(CompiledValue):
    file_io: Incomplete
    def py__path__(self): ...
    def is_package(self): ...
    @property
    def string_names(self): ...
    def py__file__(self) -> Path | None: ...

class CompiledName(AbstractNameDefinition, metaclass=abc.ABCMeta):
    parent_context: Incomplete
    string_name: Incomplete
    is_descriptor: Incomplete
    def __init__(self, inference_state, parent_value, name, is_descriptor) -> None: ...
    def py__doc__(self): ...
    def get_defining_qualified_value(self): ...
    @property
    def api_type(self): ...
    def infer(self): ...
    def infer_compiled_value(self): ...

class SignatureParamName(ParamNameInterface, AbstractNameDefinition, metaclass=abc.ABCMeta):
    parent_context: Incomplete
    def __init__(self, compiled_value, signature_param) -> None: ...
    @property
    def string_name(self): ...
    def to_string(self): ...
    def get_kind(self): ...
    def infer(self): ...

class UnresolvableParamName(ParamNameInterface, AbstractNameDefinition, metaclass=abc.ABCMeta):
    parent_context: Incomplete
    string_name: Incomplete
    def __init__(self, compiled_value, name, default) -> None: ...
    def get_kind(self): ...
    def to_string(self): ...
    def infer(self): ...

class CompiledValueName(ValueNameMixin, AbstractNameDefinition, metaclass=abc.ABCMeta):
    string_name: Incomplete
    parent_context: Incomplete
    def __init__(self, value, name) -> None: ...

class EmptyCompiledName(AbstractNameDefinition, metaclass=abc.ABCMeta):
    """
    Accessing some names will raise an exception. To avoid not having any
    completions, just give Jedi the option to return this object. It infers to
    nothing.
    """
    parent_context: Incomplete
    string_name: Incomplete
    def __init__(self, inference_state, name) -> None: ...
    def infer(self): ...

class CompiledValueFilter(AbstractFilter):
    compiled_value: Incomplete
    is_instance: Incomplete
    def __init__(self, inference_state, compiled_value, is_instance: bool = False) -> None: ...
    def get(self, name): ...
    def values(self): ...

docstr_defaults: Incomplete

def create_from_name(inference_state, compiled_value, name): ...
def create_from_access_path(inference_state, access_path): ...
def create_cached_compiled_value(inference_state, access_handle, parent_context): ...
