import abc
from _typeshed import Incomplete
from abc import abstractmethod
from jedi.cache import memoize_method as memoize_method
from jedi.inference import docstrings as docstrings
from jedi.inference.base_value import NO_VALUES as NO_VALUES, ValueSet as ValueSet
from jedi.inference.cache import inference_state_method_cache as inference_state_method_cache
from jedi.inference.helpers import deep_ast_copy as deep_ast_copy, infer_call_of_leaf as infer_call_of_leaf
from jedi.inference.utils import unite as unite
from jedi.parser_utils import clean_scope_docstring as clean_scope_docstring, find_statement_documentation as find_statement_documentation
from jedi.plugins import plugin_manager as plugin_manager
from typing import Tuple

class AbstractNameDefinition(metaclass=abc.ABCMeta):
    start_pos: Tuple[int, int] | None
    string_name: str
    parent_context: Incomplete
    tree_name: Incomplete
    is_value_name: bool
    @abstractmethod
    def infer(self): ...
    @abstractmethod
    def goto(self): ...
    def get_qualified_names(self, include_module_names: bool = False): ...
    def get_root_context(self): ...
    def get_public_name(self): ...
    def is_import(self): ...
    def py__doc__(self): ...
    @property
    def api_type(self): ...
    def get_defining_qualified_value(self) -> None:
        """
        Returns either None or the value that is public and qualified. Won't
        return a function, because a name in a function is never public.
        """

class AbstractArbitraryName(AbstractNameDefinition, metaclass=abc.ABCMeta):
    """
    When you e.g. want to complete dicts keys, you probably want to complete
    string literals, which is not really a name, but for Jedi we use this
    concept of Name for completions as well.
    """
    is_value_name: bool
    inference_state: Incomplete
    string_name: Incomplete
    parent_context: Incomplete
    def __init__(self, inference_state, string) -> None: ...
    def infer(self): ...

class AbstractTreeName(AbstractNameDefinition, metaclass=abc.ABCMeta):
    parent_context: Incomplete
    tree_name: Incomplete
    def __init__(self, parent_context, tree_name) -> None: ...
    def get_qualified_names(self, include_module_names: bool = False): ...
    def get_defining_qualified_value(self): ...
    def goto(self): ...
    def is_import(self): ...
    @property
    def string_name(self): ...
    @property
    def start_pos(self): ...

class ValueNameMixin:
    def infer(self): ...
    def py__doc__(self): ...
    def get_root_context(self): ...
    def get_defining_qualified_value(self): ...
    @property
    def api_type(self): ...

class ValueName(ValueNameMixin, AbstractTreeName):
    def __init__(self, value, tree_name) -> None: ...
    def goto(self): ...

class TreeNameDefinition(AbstractTreeName):
    def infer(self): ...
    @property
    def api_type(self): ...
    def assignment_indexes(self):
        """
        Returns an array of tuple(int, node) of the indexes that are used in
        tuple assignments.

        For example if the name is ``y`` in the following code::

            x, (y, z) = 2, ''

        would result in ``[(1, xyz_node), (0, yz_node)]``.

        When searching for b in the case ``a, *b, c = [...]`` it will return::

            [(slice(1, -1), abc_node)]
        """
    @property
    def inference_state(self): ...
    def py__doc__(self): ...

class _ParamMixin:
    def maybe_positional_argument(self, include_star: bool = True): ...
    def maybe_keyword_argument(self, include_stars: bool = True): ...
    def get_qualified_names(self, include_module_names: bool = False) -> None: ...

class ParamNameInterface(_ParamMixin):
    api_type: str
    def get_kind(self) -> None: ...
    def to_string(self) -> None: ...
    def get_executed_param_name(self) -> None:
        """
        For dealing with type inference and working around the graph, we
        sometimes want to have the param name of the execution. This feels a
        bit strange and we might have to refactor at some point.

        For now however it exists to avoid infering params when we don't really
        need them (e.g. when we can just instead use annotations.
        """
    @property
    def star_count(self): ...
    def infer_default(self): ...

class BaseTreeParamName(ParamNameInterface, AbstractTreeName, metaclass=abc.ABCMeta):
    annotation_node: Incomplete
    default_node: Incomplete
    def to_string(self): ...
    def get_public_name(self): ...
    def goto(self, **kwargs): ...

class _ActualTreeParamName(BaseTreeParamName):
    function_value: Incomplete
    def __init__(self, function_value, tree_name) -> None: ...
    @property
    def annotation_node(self): ...
    def infer_annotation(self, execute_annotation: bool = True, ignore_stars: bool = False): ...
    def infer_default(self): ...
    @property
    def default_node(self): ...
    def get_kind(self): ...
    def infer(self): ...

class AnonymousParamName(_ActualTreeParamName):
    def goto(self): ...
    def infer(self): ...

class ParamName(_ActualTreeParamName):
    arguments: Incomplete
    def __init__(self, function_value, tree_name, arguments) -> None: ...
    def infer(self): ...
    def get_executed_param_name(self): ...

class ParamNameWrapper(_ParamMixin):
    def __init__(self, param_name) -> None: ...
    def __getattr__(self, name): ...

class ImportName(AbstractNameDefinition):
    start_pos: Incomplete
    string_name: Incomplete
    def __init__(self, parent_context, string_name) -> None: ...
    def get_qualified_names(self, include_module_names: bool = False): ...
    @property
    def parent_context(self): ...
    def infer(self): ...
    def goto(self): ...
    @property
    def api_type(self): ...
    def py__doc__(self): ...

class SubModuleName(ImportName): ...

class NameWrapper:
    def __init__(self, wrapped_name) -> None: ...
    def __getattr__(self, name): ...

class StubNameMixin:
    def py__doc__(self): ...

class StubName(StubNameMixin, TreeNameDefinition):
    def infer(self): ...

class ModuleName(ValueNameMixin, AbstractNameDefinition, metaclass=abc.ABCMeta):
    start_pos: Incomplete
    def __init__(self, value, name) -> None: ...
    @property
    def string_name(self): ...

class StubModuleName(StubNameMixin, ModuleName, metaclass=abc.ABCMeta): ...
