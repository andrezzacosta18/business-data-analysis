import abc
from _typeshed import Incomplete
from abc import abstractmethod
from collections.abc import Generator
from jedi import debug as debug, parser_utils as parser_utils
from jedi.inference.base_value import NO_VALUES as NO_VALUES, ValueSet as ValueSet
from jedi.inference.filters import GlobalNameFilter as GlobalNameFilter, MergedFilter as MergedFilter, ParserTreeFilter as ParserTreeFilter
from jedi.inference.names import AnonymousParamName as AnonymousParamName, TreeNameDefinition as TreeNameDefinition
from jedi.parser_utils import get_parent_scope as get_parent_scope
from pathlib import Path

class AbstractContext(metaclass=abc.ABCMeta):
    inference_state: Incomplete
    predefined_names: Incomplete
    def __init__(self, inference_state) -> None: ...
    @abstractmethod
    def get_filters(self, until_position: Incomplete | None = None, origin_scope: Incomplete | None = None): ...
    def goto(self, name_or_str, position): ...
    def py__getattribute__(self, name_or_str, name_context: Incomplete | None = None, position: Incomplete | None = None, analysis_errors: bool = True):
        """
        :param position: Position of the last statement -> tuple of line, column
        """
    def get_root_context(self): ...
    def is_module(self): ...
    def is_builtins_module(self): ...
    def is_class(self): ...
    def is_stub(self): ...
    def is_instance(self): ...
    def is_compiled(self): ...
    def is_bound_method(self): ...
    @abstractmethod
    def py__name__(self): ...
    def get_value(self) -> None: ...
    @property
    def name(self) -> None: ...
    def get_qualified_names(self): ...
    def py__doc__(self): ...
    def predefine_names(self, flow_scope, dct) -> Generator[None, None, None]: ...

class ValueContext(AbstractContext, metaclass=abc.ABCMeta):
    """
    Should be defined, otherwise the API returns empty types.
    """
    def __init__(self, value) -> None: ...
    @property
    def tree_node(self): ...
    @property
    def parent_context(self): ...
    def is_module(self): ...
    def is_builtins_module(self): ...
    def is_class(self): ...
    def is_stub(self): ...
    def is_instance(self): ...
    def is_compiled(self): ...
    def is_bound_method(self): ...
    def py__name__(self): ...
    @property
    def name(self): ...
    def get_qualified_names(self): ...
    def py__doc__(self): ...
    def get_value(self): ...

class TreeContextMixin:
    def infer_node(self, node): ...
    def create_value(self, node): ...
    def create_context(self, node): ...
    def create_name(self, tree_name): ...

class FunctionContext(TreeContextMixin, ValueContext):
    def get_filters(self, until_position: Incomplete | None = None, origin_scope: Incomplete | None = None) -> Generator[Incomplete, None, None]: ...

class ModuleContext(TreeContextMixin, ValueContext):
    def py__file__(self) -> Path | None: ...
    def get_filters(self, until_position: Incomplete | None = None, origin_scope: Incomplete | None = None) -> Generator[Incomplete, Incomplete, None]: ...
    def get_global_filter(self): ...
    @property
    def string_names(self): ...
    @property
    def code_lines(self): ...
    def get_value(self):
        """
        This is the only function that converts a context back to a value.
        This is necessary for stub -> python conversion and vice versa. However
        this method shouldn't be moved to AbstractContext.
        """

class NamespaceContext(TreeContextMixin, ValueContext):
    def get_filters(self, until_position: Incomplete | None = None, origin_scope: Incomplete | None = None): ...
    def get_value(self): ...
    @property
    def string_names(self): ...
    def py__file__(self) -> Path | None: ...

class ClassContext(TreeContextMixin, ValueContext):
    def get_filters(self, until_position: Incomplete | None = None, origin_scope: Incomplete | None = None) -> Generator[Incomplete, None, None]: ...
    def get_global_filter(self, until_position: Incomplete | None = None, origin_scope: Incomplete | None = None): ...

class CompForContext(TreeContextMixin, AbstractContext):
    tree_node: Incomplete
    parent_context: Incomplete
    def __init__(self, parent_context, comp_for) -> None: ...
    def get_filters(self, until_position: Incomplete | None = None, origin_scope: Incomplete | None = None) -> Generator[Incomplete, None, None]: ...
    def get_value(self) -> None: ...
    def py__name__(self): ...

class CompiledContext(ValueContext):
    def get_filters(self, until_position: Incomplete | None = None, origin_scope: Incomplete | None = None): ...

class CompiledModuleContext(CompiledContext):
    code_lines: Incomplete
    def get_value(self): ...
    @property
    def string_names(self): ...
    def py__file__(self) -> Path | None: ...

def get_global_filters(context, until_position, origin_scope) -> Generator[Incomplete, Incomplete, None]:
    '''
    Returns all filters in order of priority for name resolution.

    For global name lookups. The filters will handle name resolution
    themselves, but here we gather possible filters downwards.

    >>> from jedi import Script
    >>> script = Script(\'\'\'
    ... x = [\'a\', \'b\', \'c\']
    ... def func():
    ...     y = None
    ... \'\'\')
    >>> module_node = script._module_node
    >>> scope = next(module_node.iter_funcdefs())
    >>> scope
    <Function: func@3-5>
    >>> context = script._get_module_context().create_context(scope)
    >>> filters = list(get_global_filters(context, (4, 0), None))

    First we get the names from the function scope.

    >>> print(filters[0])  # doctest: +ELLIPSIS
    MergedFilter(<ParserTreeFilter: ...>, <GlobalNameFilter: ...>)
    >>> sorted(str(n) for n in filters[0].values())  # doctest: +NORMALIZE_WHITESPACE
    [\'<TreeNameDefinition: string_name=func start_pos=(3, 4)>\',
     \'<TreeNameDefinition: string_name=x start_pos=(2, 0)>\']
    >>> filters[0]._filters[0]._until_position
    (4, 0)
    >>> filters[0]._filters[1]._until_position

    Then it yields the names from one level "lower". In this example, this is
    the module scope (including globals).
    As a side note, you can see, that the position in the filter is None on the
    globals filter, because there the whole module is searched.

    >>> list(filters[1].values())  # package modules -> Also empty.
    []
    >>> sorted(name.string_name for name in filters[2].values())  # Module attributes
    [\'__doc__\', \'__name__\', \'__package__\']

    Finally, it yields the builtin filter, if `include_builtin` is
    true (default).

    >>> list(filters[3].values())  # doctest: +ELLIPSIS
    [...]
    '''
