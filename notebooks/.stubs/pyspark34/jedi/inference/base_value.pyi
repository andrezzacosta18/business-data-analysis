from _typeshed import Incomplete
from collections.abc import Generator
from jedi import debug as debug
from jedi.cache import memoize_method as memoize_method
from jedi.inference.cache import inference_state_as_method_param_cache as inference_state_as_method_param_cache
from jedi.inference.helpers import SimpleGetItemNotFound as SimpleGetItemNotFound
from jedi.inference.utils import safe_property as safe_property
from jedi.parser_utils import clean_scope_docstring as clean_scope_docstring

sentinel: Incomplete

class HasNoContext(Exception): ...

class HelperValueMixin:
    def get_root_context(self): ...
    def execute(self, arguments): ...
    def execute_with_values(self, *value_list): ...
    def execute_annotation(self): ...
    def gather_annotation_classes(self): ...
    def merge_types_of_iterate(self, contextualized_node: Incomplete | None = None, is_async: bool = False): ...
    def goto(self, name_or_str, name_context: Incomplete | None = None, analysis_errors: bool = True): ...
    def py__getattribute__(self, name_or_str, name_context: Incomplete | None = None, position: Incomplete | None = None, analysis_errors: bool = True):
        """
        :param position: Position of the last statement -> tuple of line, column
        """
    def py__await__(self): ...
    def py__name__(self): ...
    def iterate(self, contextualized_node: Incomplete | None = None, is_async: bool = False): ...
    def is_sub_class_of(self, class_value): ...
    def is_same_class(self, class2): ...
    def as_context(self, *args, **kwargs): ...

class Value(HelperValueMixin):
    """
    To be implemented by subclasses.
    """
    tree_node: Incomplete
    array_type: Incomplete
    api_type: str
    inference_state: Incomplete
    parent_context: Incomplete
    def __init__(self, inference_state, parent_context: Incomplete | None = None) -> None: ...
    def py__getitem__(self, index_value_set, contextualized_node): ...
    def py__simple_getitem__(self, index) -> None: ...
    def py__iter__(self, contextualized_node: Incomplete | None = None): ...
    def py__next__(self, contextualized_node: Incomplete | None = None): ...
    def get_signatures(self): ...
    def is_class(self): ...
    def is_class_mixin(self): ...
    def is_instance(self): ...
    def is_function(self): ...
    def is_module(self): ...
    def is_namespace(self): ...
    def is_compiled(self): ...
    def is_bound_method(self): ...
    def is_builtins_module(self): ...
    def py__bool__(self):
        """
        Since Wrapper is a super class for classes, functions and modules,
        the return value will always be true.
        """
    def py__doc__(self): ...
    def get_safe_value(self, default=...): ...
    def execute_operation(self, other, operator): ...
    def py__call__(self, arguments): ...
    def py__stop_iteration_returns(self): ...
    def py__getattribute__alternatives(self, name_or_str):
        """
        For now a way to add values in cases like __getattr__.
        """
    def py__get__(self, instance, class_value): ...
    def py__get__on_class(self, calling_instance, instance, class_value): ...
    def get_qualified_names(self) -> None: ...
    def is_stub(self): ...
    @property
    def name(self) -> None: ...
    def get_type_hint(self, add_class_info: bool = True) -> None: ...
    def infer_type_vars(self, value_set):
        """
        When the current instance represents a type annotation, this method
        tries to find information about undefined type vars and returns a dict
        from type var name to value set.

        This is for example important to understand what `iter([1])` returns.
        According to typeshed, `iter` returns an `Iterator[_T]`:

            def iter(iterable: Iterable[_T]) -> Iterator[_T]: ...

        This functions would generate `int` for `_T` in this case, because it
        unpacks the `Iterable`.

        Parameters
        ----------

        `self`: represents the annotation of the current parameter to infer the
            value for. In the above example, this would initially be the
            `Iterable[_T]` of the `iterable` parameter and then, when recursing,
            just the `_T` generic parameter.

        `value_set`: represents the actual argument passed to the parameter
            we're inferred for, or (for recursive calls) their types. In the
            above example this would first be the representation of the list
            `[1]` and then, when recursing, just of `1`.
        """

def iterate_values(values, contextualized_node: Incomplete | None = None, is_async: bool = False):
    """
    Calls `iterate`, on all values but ignores the ordering and just returns
    all values that the iterate functions yield.
    """

class _ValueWrapperBase(HelperValueMixin):
    def name(self): ...
    @classmethod
    def create_cached(cls, inference_state, *args, **kwargs): ...
    def __getattr__(self, name): ...

class LazyValueWrapper(_ValueWrapperBase): ...

class ValueWrapper(_ValueWrapperBase):
    def __init__(self, wrapped_value) -> None: ...

class TreeValue(Value):
    tree_node: Incomplete
    def __init__(self, inference_state, parent_context, tree_node) -> None: ...

class ContextualizedNode:
    context: Incomplete
    node: Incomplete
    def __init__(self, context, node) -> None: ...
    def get_root_context(self): ...
    def infer(self): ...

class ValueSet:
    def __init__(self, iterable) -> None: ...
    @classmethod
    def from_sets(cls, sets):
        """
        Used to work with an iterable of set.
        """
    def __or__(self, other): ...
    def __and__(self, other): ...
    def __iter__(self): ...
    def __bool__(self) -> bool: ...
    def __len__(self) -> int: ...
    def filter(self, filter_func): ...
    def __getattr__(self, name): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __hash__(self): ...
    def py__class__(self): ...
    def iterate(self, contextualized_node: Incomplete | None = None, is_async: bool = False) -> Generator[Incomplete, None, None]: ...
    def execute(self, arguments): ...
    def execute_with_values(self, *args, **kwargs): ...
    def goto(self, *args, **kwargs): ...
    def py__getattribute__(self, *args, **kwargs): ...
    def get_item(self, *args, **kwargs): ...
    def try_merge(self, function_name): ...
    def gather_annotation_classes(self): ...
    def get_signatures(self): ...
    def get_type_hint(self, add_class_info: bool = True): ...
    def infer_type_vars(self, value_set): ...

NO_VALUES: Incomplete

def iterator_to_value_set(func): ...
