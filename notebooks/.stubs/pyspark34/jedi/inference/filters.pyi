import abc
from _typeshed import Incomplete
from abc import abstractmethod
from collections.abc import Generator
from jedi.inference import flow_analysis as flow_analysis
from jedi.inference.base_value import LazyValueWrapper as LazyValueWrapper, ValueSet as ValueSet, ValueWrapper as ValueWrapper
from jedi.inference.names import AbstractNameDefinition as AbstractNameDefinition, AnonymousParamName as AnonymousParamName, NameWrapper as NameWrapper, ParamName as ParamName, TreeNameDefinition as TreeNameDefinition
from jedi.inference.utils import to_list as to_list
from jedi.parser_utils import get_cached_parent_scope as get_cached_parent_scope, get_parso_cache_node as get_parso_cache_node
from parso.python.tree import Name as Name, UsedNamesMapping as UsedNamesMapping
from typing import Type

class AbstractFilter(metaclass=abc.ABCMeta):
    @abstractmethod
    def get(self, name): ...
    @abstractmethod
    def values(self): ...

class FilterWrapper:
    name_wrapper_class: Type[NameWrapper]
    def __init__(self, wrapped_filter) -> None: ...
    def wrap_names(self, names): ...
    def get(self, name): ...
    def values(self): ...

class _AbstractUsedNamesFilter(AbstractFilter):
    name_class = TreeNameDefinition
    parent_context: Incomplete
    def __init__(self, parent_context, node_context: Incomplete | None = None) -> None: ...
    def get(self, name): ...
    def values(self): ...

class ParserTreeFilter(_AbstractUsedNamesFilter):
    def __init__(self, parent_context, node_context: Incomplete | None = None, until_position: Incomplete | None = None, origin_scope: Incomplete | None = None) -> None:
        """
        node_context is an option to specify a second value for use cases
        like the class mro where the parent class of a new name would be the
        value, but for some type inference it's important to have a local
        value of the other classes.
        """

class _FunctionExecutionFilter(ParserTreeFilter):
    def __init__(self, parent_context, function_value, until_position, origin_scope) -> None: ...

class FunctionExecutionFilter(_FunctionExecutionFilter):
    def __init__(self, *args, arguments, **kwargs) -> None: ...

class AnonymousFunctionExecutionFilter(_FunctionExecutionFilter): ...

class GlobalNameFilter(_AbstractUsedNamesFilter):
    def get(self, name): ...
    def values(self): ...

class DictFilter(AbstractFilter):
    def __init__(self, dct) -> None: ...
    def get(self, name): ...
    def values(self): ...

class MergedFilter:
    def __init__(self, *filters) -> None: ...
    def get(self, name): ...
    def values(self): ...

class _BuiltinMappedMethod(ValueWrapper):
    """``Generator.__next__`` ``dict.values`` methods and so on."""
    api_type: str
    def __init__(self, value, method, builtin_func) -> None: ...
    def py__call__(self, arguments): ...

class SpecialMethodFilter(DictFilter):
    """
    A filter for methods that are defined in this module on the corresponding
    classes like Generator (for __next__, etc).
    """
    class SpecialMethodName(AbstractNameDefinition, metaclass=abc.ABCMeta):
        api_type: str
        parent_context: Incomplete
        string_name: Incomplete
        def __init__(self, parent_context, string_name, callable_, builtin_value) -> None: ...
        def infer(self): ...
    value: Incomplete
    def __init__(self, value, dct, builtin_value) -> None: ...

class _OverwriteMeta(type):
    def __init__(cls, name, bases, dct) -> None: ...

class _AttributeOverwriteMixin:
    def get_filters(self, *args, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...

class LazyAttributeOverwrite(_AttributeOverwriteMixin, LazyValueWrapper, metaclass=_OverwriteMeta):
    inference_state: Incomplete
    def __init__(self, inference_state) -> None: ...

class AttributeOverwrite(_AttributeOverwriteMixin, ValueWrapper, metaclass=_OverwriteMeta): ...

def publish_method(method_name): ...
