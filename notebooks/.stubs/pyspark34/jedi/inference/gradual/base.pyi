import abc
from _typeshed import Incomplete
from collections.abc import Generator
from jedi.inference.base_value import LazyValueWrapper as LazyValueWrapper, NO_VALUES as NO_VALUES, Value as Value, ValueSet as ValueSet, ValueWrapper as ValueWrapper, iterator_to_value_set as iterator_to_value_set
from jedi.inference.cache import inference_state_method_cache as inference_state_method_cache
from jedi.inference.compiled import builtin_from_name as builtin_from_name
from jedi.inference.context import ClassContext as ClassContext
from jedi.inference.gradual.generics import TupleGenericManager as TupleGenericManager
from jedi.inference.names import AbstractNameDefinition as AbstractNameDefinition, ValueName as ValueName
from jedi.inference.utils import to_list as to_list
from jedi.inference.value.klass import ClassFilter as ClassFilter, ClassMixin as ClassMixin

class _BoundTypeVarName(AbstractNameDefinition, metaclass=abc.ABCMeta):
    """
    This type var was bound to a certain type, e.g. int.
    """
    parent_context: Incomplete
    def __init__(self, type_var, value_set) -> None: ...
    def infer(self): ...
    def py__name__(self): ...

class _TypeVarFilter:
    """
    A filter for all given variables in a class.

        A = TypeVar('A')
        B = TypeVar('B')
        class Foo(Mapping[A, B]):
            ...

    In this example we would have two type vars given: A and B
    """
    def __init__(self, generics, type_vars) -> None: ...
    def get(self, name): ...
    def values(self): ...

class _AnnotatedClassContext(ClassContext):
    def get_filters(self, *args, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...

class DefineGenericBaseClass(LazyValueWrapper):
    def __init__(self, generics_manager) -> None: ...
    def get_generics(self): ...
    def define_generics(self, type_var_dict): ...
    def is_same_class(self, other): ...
    def get_signatures(self): ...

class GenericClass(DefineGenericBaseClass, ClassMixin):
    """
    A class that is defined with generics, might be something simple like:

        class Foo(Generic[T]): ...
        my_foo_int_cls = Foo[int]
    """
    def __init__(self, class_value, generics_manager) -> None: ...
    def get_type_hint(self, add_class_info: bool = True): ...
    def get_type_var_filter(self): ...
    def py__call__(self, arguments): ...
    def py__bases__(self) -> Generator[Incomplete, None, None]: ...
    def is_sub_class_of(self, class_value): ...
    def with_generics(self, generics_tuple): ...
    def infer_type_vars(self, value_set): ...

class _LazyGenericBaseClass:
    def __init__(self, class_value, lazy_base_class, generics_manager) -> None: ...
    def infer(self) -> Generator[Incomplete, None, None]: ...

class _GenericInstanceWrapper(ValueWrapper):
    def py__stop_iteration_returns(self): ...
    def get_type_hint(self, add_class_info: bool = True): ...

class _PseudoTreeNameClass(Value):
    """
    In typeshed, some classes are defined like this:

        Tuple: _SpecialForm = ...

    Now this is not a real class, therefore we have to do some workarounds like
    this class. Essentially this class makes it possible to goto that `Tuple`
    name, without affecting anything else negatively.
    """
    api_type: str
    def __init__(self, parent_context, tree_name) -> None: ...
    @property
    def tree_node(self): ...
    def get_filters(self, *args, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
    def py__class__(self): ...
    @property
    def name(self): ...
    def get_qualified_names(self): ...

class BaseTypingValue(LazyValueWrapper):
    inference_state: Incomplete
    parent_context: Incomplete
    def __init__(self, parent_context, tree_name) -> None: ...
    @property
    def name(self): ...
    def get_signatures(self): ...

class BaseTypingClassWithGenerics(DefineGenericBaseClass):
    inference_state: Incomplete
    parent_context: Incomplete
    def __init__(self, parent_context, tree_name, generics_manager) -> None: ...

class BaseTypingInstance(LazyValueWrapper):
    inference_state: Incomplete
    parent_context: Incomplete
    def __init__(self, parent_context, class_value, tree_name, generics_manager) -> None: ...
    def py__class__(self): ...
    def get_annotated_class_object(self): ...
    def get_qualified_names(self): ...
    @property
    def name(self): ...
