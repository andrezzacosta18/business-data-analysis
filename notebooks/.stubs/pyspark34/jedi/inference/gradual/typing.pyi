from _typeshed import Incomplete
from collections.abc import Generator
from jedi import debug as debug
from jedi.inference.arguments import repack_with_argument_clinic as repack_with_argument_clinic
from jedi.inference.base_value import LazyValueWrapper as LazyValueWrapper, NO_VALUES as NO_VALUES, Value as Value, ValueSet as ValueSet, ValueWrapper as ValueWrapper
from jedi.inference.compiled import builtin_from_name as builtin_from_name, create_simple_object as create_simple_object
from jedi.inference.filters import FilterWrapper as FilterWrapper
from jedi.inference.gradual.base import BaseTypingClassWithGenerics as BaseTypingClassWithGenerics, BaseTypingInstance as BaseTypingInstance, BaseTypingValue as BaseTypingValue
from jedi.inference.gradual.generics import LazyGenericManager as LazyGenericManager, TupleGenericManager as TupleGenericManager
from jedi.inference.gradual.type_var import TypeVarClass as TypeVarClass
from jedi.inference.lazy_value import LazyKnownValues as LazyKnownValues
from jedi.inference.names import NameWrapper as NameWrapper, ValueName as ValueName
from jedi.inference.value.klass import ClassMixin as ClassMixin

class TypingModuleName(NameWrapper):
    def infer(self): ...

class TypingModuleFilterWrapper(FilterWrapper):
    name_wrapper_class = TypingModuleName

class ProxyWithGenerics(BaseTypingClassWithGenerics):
    def execute_annotation(self): ...
    def gather_annotation_classes(self): ...
    def infer_type_vars(self, value_set): ...

class ProxyTypingValue(BaseTypingValue):
    index_class = ProxyWithGenerics
    def with_generics(self, generics_tuple): ...
    def py__getitem__(self, index_value_set, contextualized_node): ...

class _TypingClassMixin(ClassMixin):
    def py__bases__(self): ...
    def get_metaclasses(self): ...
    @property
    def name(self): ...

class TypingClassWithGenerics(ProxyWithGenerics, _TypingClassMixin):
    def infer_type_vars(self, value_set): ...

class ProxyTypingClassValue(ProxyTypingValue, _TypingClassMixin):
    index_class = TypingClassWithGenerics

class TypeAlias(LazyValueWrapper):
    inference_state: Incomplete
    parent_context: Incomplete
    def __init__(self, parent_context, origin_tree_name, actual) -> None: ...
    @property
    def name(self): ...
    def py__name__(self): ...
    def gather_annotation_classes(self): ...
    def get_signatures(self): ...

class Callable(BaseTypingInstance):
    def py__call__(self, arguments):
        """
            def x() -> Callable[[Callable[..., _T]], _T]: ...
        """
    def py__get__(self, instance, class_value): ...

class Tuple(BaseTypingInstance):
    def py__simple_getitem__(self, index): ...
    def py__iter__(self, contextualized_node: Incomplete | None = None) -> Generator[Incomplete, None, None]: ...
    def py__getitem__(self, index_value_set, contextualized_node): ...
    @property
    def name(self): ...
    def infer_type_vars(self, value_set): ...

class Generic(BaseTypingInstance): ...
class Protocol(BaseTypingInstance): ...

class AnyClass(BaseTypingValue):
    def execute_annotation(self): ...

class OverloadFunction(BaseTypingValue):
    def py__call__(self, func_value_set): ...

class NewTypeFunction(ValueWrapper):
    def py__call__(self, arguments): ...

class NewType(Value):
    tree_node: Incomplete
    def __init__(self, inference_state, parent_context, tree_node, type_value_set) -> None: ...
    def py__class__(self): ...
    def py__call__(self, arguments): ...
    @property
    def name(self): ...

class CastFunction(ValueWrapper):
    def py__call__(self, type_value_set, object_value_set): ...

class TypedDictClass(BaseTypingValue):
    """
    This class has no responsibilities and is just here to make sure that typed
    dicts can be identified.
    """

class TypedDict(LazyValueWrapper):
    """Represents the instance version of ``TypedDictClass``."""
    inference_state: Incomplete
    parent_context: Incomplete
    tree_node: Incomplete
    def __init__(self, definition_class) -> None: ...
    @property
    def name(self): ...
    def py__simple_getitem__(self, index): ...
    def get_key_values(self): ...
