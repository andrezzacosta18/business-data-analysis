from _typeshed import Incomplete
from jedi import debug as debug
from jedi.api.completion import search_in_module as search_in_module
from jedi.api.environment import create_environment as create_environment, get_cached_default_environment as get_cached_default_environment
from jedi.api.exceptions import WrongVersion as WrongVersion
from jedi.api.helpers import get_module_names as get_module_names, split_search_string as split_search_string
from jedi.file_io import FolderIO as FolderIO
from jedi.inference.cache import inference_state_as_method_param_cache as inference_state_as_method_param_cache
from jedi.inference.imports import iter_module_names as iter_module_names, load_module_from_path as load_module_from_path, load_namespace_from_path as load_namespace_from_path
from jedi.inference.references import recurse_find_python_folders_and_files as recurse_find_python_folders_and_files, search_in_file_ios as search_in_file_ios
from jedi.inference.sys_path import discover_buildout_paths as discover_buildout_paths

class Project:
    """
    Projects are a simple way to manage Python folders and define how Jedi does
    import resolution. It is mostly used as a parameter to :class:`.Script`.
    Additionally there are functions to search a whole project.
    """
    @classmethod
    def load(cls, path):
        """
        Loads a project from a specific path. You should not provide the path
        to ``.jedi/project.json``, but rather the path to the project folder.

        :param path: The path of the directory you want to use as a project.
        """
    def save(self):
        """
        Saves the project configuration in the project in ``.jedi/project.json``.
        """
    added_sys_path: Incomplete
    def __init__(self, path, *, environment_path: Incomplete | None = None, load_unsafe_extensions: bool = False, sys_path: Incomplete | None = None, added_sys_path=(), smart_sys_path: bool = True) -> None:
        """
        :param path: The base path for this project.
        :param environment_path: The Python executable path, typically the path
            of a virtual environment.
        :param load_unsafe_extensions: Default False, Loads extensions that are not in the
            sys path and in the local directories. With this option enabled,
            this is potentially unsafe if you clone a git repository and
            analyze it's code, because those compiled extensions will be
            important and therefore have execution privileges.
        :param sys_path: list of str. You can override the sys path if you
            want. By default the ``sys.path.`` is generated by the
            environment (virtualenvs, etc).
        :param added_sys_path: list of str. Adds these paths at the end of the
            sys path.
        :param smart_sys_path: If this is enabled (default), adds paths from
            local directories. Otherwise you will have to rely on your packages
            being properly configured on the ``sys.path``.
        """
    @property
    def path(self):
        """
        The base path for this project.
        """
    @property
    def sys_path(self):
        """
        The sys path provided to this project. This can be None and in that
        case will be auto generated.
        """
    @property
    def smart_sys_path(self):
        """
        If the sys path is going to be calculated in a smart way, where
        additional paths are added.
        """
    @property
    def load_unsafe_extensions(self):
        """
        Wheter the project loads unsafe extensions.
        """
    def get_environment(self): ...
    def search(self, string, *, all_scopes: bool = False):
        """
        Searches a name in the whole project. If the project is very big,
        at some point Jedi will stop searching. However it's also very much
        recommended to not exhaust the generator. Just display the first ten
        results to the user.

        There are currently three different search patterns:

        - ``foo`` to search for a definition foo in any file or a file called
          ``foo.py`` or ``foo.pyi``.
        - ``foo.bar`` to search for the ``foo`` and then an attribute ``bar``
          in it.
        - ``class foo.bar.Bar`` or ``def foo.bar.baz`` to search for a specific
          API type.

        :param bool all_scopes: Default False; searches not only for
            definitions on the top level of a module level, but also in
            functions and classes.
        :yields: :class:`.Name`
        """
    def complete_search(self, string, **kwargs):
        """
        Like :meth:`.Script.search`, but completes that string. An empty string
        lists all definitions in a project, so be careful with that.

        :param bool all_scopes: Default False; searches not only for
            definitions on the top level of a module level, but also in
            functions and classes.
        :yields: :class:`.Completion`
        """

def get_default_project(path: Incomplete | None = None):
    """
    If a project is not defined by the user, Jedi tries to define a project by
    itself as well as possible. Jedi traverses folders until it finds one of
    the following:

    1. A ``.jedi/config.json``
    2. One of the following files: ``setup.py``, ``.git``, ``.hg``,
       ``requirements.txt`` and ``MANIFEST.in``.
    """
