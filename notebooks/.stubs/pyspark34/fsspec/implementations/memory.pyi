from _typeshed import Incomplete
from fsspec import AbstractFileSystem as AbstractFileSystem
from io import BytesIO
from typing import Any, ClassVar

logger: Incomplete

class MemoryFileSystem(AbstractFileSystem):
    """A filesystem based on a dict of BytesIO objects

    This is a global filesystem so instances of this class all point to the same
    in memory filesystem.
    """
    store: ClassVar[dict[str, Any]]
    pseudo_dirs: Incomplete
    protocol: str
    root_marker: str
    def ls(self, path, detail: bool = True, **kwargs): ...
    def mkdir(self, path, create_parents: bool = True, **kwargs) -> None: ...
    def makedirs(self, path, exist_ok: bool = False) -> None: ...
    def pipe_file(self, path, value, **kwargs) -> None:
        """Set the bytes of given file

        Avoids copies of the data if possible
        """
    def rmdir(self, path) -> None: ...
    def info(self, path, **kwargs): ...
    def cp_file(self, path1, path2, **kwargs) -> None: ...
    def cat_file(self, path, start: Incomplete | None = None, end: Incomplete | None = None, **kwargs): ...
    def modified(self, path): ...
    def created(self, path): ...
    def rm(self, path, recursive: bool = False, maxdepth: Incomplete | None = None) -> None: ...

class MemoryFile(BytesIO):
    """A BytesIO which can't close and works as a context manager

    Can initialise with data. Each path should only be active once at any moment.

    No need to provide fs, path if auto-committing (default)
    """
    fs: Incomplete
    path: Incomplete
    created: Incomplete
    modified: Incomplete
    def __init__(self, fs: Incomplete | None = None, path: Incomplete | None = None, data: Incomplete | None = None) -> None: ...
    @property
    def size(self): ...
    def __enter__(self): ...
    def close(self) -> None: ...
    def discard(self) -> None: ...
    def commit(self) -> None: ...
