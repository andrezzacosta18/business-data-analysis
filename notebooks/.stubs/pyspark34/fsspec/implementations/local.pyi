import io
from _typeshed import Incomplete
from fsspec import AbstractFileSystem as AbstractFileSystem
from fsspec.compression import compr as compr
from fsspec.core import get_compression as get_compression
from fsspec.utils import isfilelike as isfilelike, stringify_path as stringify_path

logger: Incomplete

class LocalFileSystem(AbstractFileSystem):
    """Interface to files on local storage

    Parameters
    ----------
    auto_mkdir: bool
        Whether, when opening a file, the directory containing it should
        be created (if it doesn't already exist). This is assumed by pyarrow
        code.
    """
    root_marker: str
    protocol: Incomplete
    local_file: bool
    auto_mkdir: Incomplete
    def __init__(self, auto_mkdir: bool = False, **kwargs) -> None: ...
    @property
    def fsid(self): ...
    def mkdir(self, path, create_parents: bool = True, **kwargs) -> None: ...
    def makedirs(self, path, exist_ok: bool = False) -> None: ...
    def rmdir(self, path) -> None: ...
    def ls(self, path, detail: bool = False, **kwargs): ...
    def info(self, path, **kwargs): ...
    def lexists(self, path, **kwargs): ...
    def cp_file(self, path1, path2, **kwargs) -> None: ...
    def get_file(self, path1, path2, callback: Incomplete | None = None, **kwargs): ...
    def put_file(self, path1, path2, callback: Incomplete | None = None, **kwargs): ...
    def mv_file(self, path1, path2, **kwargs) -> None: ...
    def link(self, src, dst, **kwargs) -> None: ...
    def symlink(self, src, dst, **kwargs) -> None: ...
    def islink(self, path) -> bool: ...
    def rm_file(self, path) -> None: ...
    def rm(self, path, recursive: bool = False, maxdepth: Incomplete | None = None) -> None: ...
    def unstrip_protocol(self, name): ...
    def touch(self, path, truncate: bool = True, **kwargs) -> None: ...
    def created(self, path): ...
    def modified(self, path): ...
    def chmod(self, path, mode): ...

def make_path_posix(path, sep=...):
    """Make path generic"""
def trailing_sep(path):
    """Return True if the path ends with a path separator.

    A forward slash is always considered a path separator, even on Operating
    Systems that normally use a backslash.
    """

class LocalFileOpener(io.IOBase):
    path: Incomplete
    mode: Incomplete
    fs: Incomplete
    f: Incomplete
    autocommit: Incomplete
    compression: Incomplete
    blocksize: Incomplete
    def __init__(self, path, mode, autocommit: bool = True, fs: Incomplete | None = None, compression: Incomplete | None = None, **kwargs) -> None: ...
    def commit(self) -> None: ...
    def discard(self) -> None: ...
    def readable(self) -> bool: ...
    def writable(self) -> bool: ...
    def read(self, *args, **kwargs): ...
    def write(self, *args, **kwargs): ...
    def tell(self, *args, **kwargs): ...
    def seek(self, *args, **kwargs): ...
    def seekable(self, *args, **kwargs): ...
    def readline(self, *args, **kwargs): ...
    def readlines(self, *args, **kwargs): ...
    def close(self): ...
    @property
    def closed(self): ...
    def fileno(self): ...
    def flush(self) -> None: ...
    def __iter__(self): ...
    def __getattr__(self, item): ...
    def __enter__(self): ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_value: BaseException | None, traceback: types.TracebackType | None) -> None: ...
