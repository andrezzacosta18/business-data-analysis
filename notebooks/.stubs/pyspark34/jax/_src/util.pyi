import numpy as np
from _typeshed import Incomplete
from collections.abc import Iterable, Iterator, Sequence
from jax._src.config import config as config
from typing import Any, Callable, Generic, TypeVar, overload

logger: Incomplete
Seq = Sequence
T = TypeVar('T')
T1 = TypeVar('T1')
T2 = TypeVar('T2')
T3 = TypeVar('T3')

@overload
def safe_zip(__arg1: Iterable[T1]) -> list[tuple[T1]]: ...
@overload
def safe_zip(__arg1: Iterable[T1], __arg2: Iterable[T2]) -> list[tuple[T1, T2]]: ...
@overload
def safe_zip(__arg1: Iterable[T1], __arg2: Iterable[T2], __arg3: Iterable[T3]) -> list[tuple[T1, T2, T3]]: ...
@overload
def safe_zip(__arg1: Iterable[Any], __arg2: Iterable[Any], __arg3: Iterable[Any], __arg4: Iterable[Any], *args) -> list[tuple[Any, ...]]: ...
@overload
def safe_map(f: Callable[[T1], T], __arg1: Iterable[T1]) -> list[T]: ...
@overload
def safe_map(f: Callable[[T1, T2], T], __arg1: Iterable[T1], __arg2: Iterable[T2]) -> list[T]: ...
@overload
def safe_map(f: Callable[[T1, T2, T3], T], __arg1: Iterable[T1], __arg2: Iterable[T2], __arg3: Iterable[T3]) -> list[T]: ...
@overload
def safe_map(f: Callable[..., T], __arg1: Iterable[Any], __arg2: Iterable[Any], __arg3: Iterable[Any], __arg4: Iterable[Any], *args) -> list[T]: ...
def unzip2(xys: Iterable[tuple[T1, T2]]) -> tuple[tuple[T1, ...], tuple[T2, ...]]:
    """Unzip sequence of length-2 tuples into two tuples."""
def unzip3(xyzs: Iterable[tuple[T1, T2, T3]]) -> tuple[tuple[T1, ...], tuple[T2, ...], tuple[T3, ...]]:
    """Unzip sequence of length-3 tuples into three tuples."""
def subvals(lst, replace): ...
def split_list(args: Sequence[T], ns: Sequence[int]) -> list[list[T]]: ...
def partition_list(bs: Sequence[bool], l: Sequence[T]) -> tuple[list[T], list[T]]: ...
def merge_lists(bs: Sequence[bool], l0: Sequence[T], l1: Sequence[T]) -> list[T]: ...
def split_dict(dct, names): ...
def concatenate(xs: Iterable[Sequence[T]]) -> list[T]:
    """Concatenates/flattens a list of lists."""
flatten = concatenate

def unflatten(xs: Iterable[T], ns: Sequence[int]) -> list[list[T]]:
    """Splits `xs` into subsequences of lengths `ns`.

  Unlike `split_list`, the `sum(ns)` must be equal to `len(xs)`."""
def curry(f):
    """Curries arguments of f, returning a function on any remaining arguments.

  For example:
  >>> f = lambda x, y, z, w: x * y + z * w
  >>> f(2,3,4,5)
  26
  >>> curry(f)(2)(3, 4, 5)
  26
  >>> curry(f)(2, 3)(4, 5)
  26
  >>> curry(f)(2, 3, 4, 5)()
  26
  """
def toposort(end_nodes): ...
def check_toposort(nodes) -> None: ...
def split_merge(predicate, xs): ...
def cache(max_size: int = 4096): ...

memoize: Incomplete

def weakref_lru_cache(call: Callable, maxsize: int = 2048):
    """
  Least recently used cache decorator with weakref support.

  The cache will take a weakref to the first argument of the wrapped function
  and strong refs to all subsequent operations. In all other respects it should
  behave similar to `functools.lru_cache`.
  """
def clear_all_weakref_lru_caches() -> None: ...

class Unhashable:
    val: Incomplete
    def __init__(self, val) -> None: ...
    def __eq__(self, other): ...

class Hashable:
    val: Incomplete
    def __init__(self, val) -> None: ...
    def __hash__(self): ...
    def __eq__(self, other): ...

class WrapKwArgs:
    val: Incomplete
    def __init__(self, val) -> None: ...
    def __hash__(self): ...
    def __eq__(self, other): ...

def wrap_name(name, transform_name): ...
def canonicalize_axis(axis, num_dims) -> int:
    """Canonicalize an axis in [-num_dims, num_dims) to [0, num_dims)."""
def moveaxis(x, src, dst): ...
def ceil_of_ratio(x, y): ...
def wraps(wrapped: Callable, namestr: str | None = None, docstr: str | None = None, **kwargs) -> Callable[[T], T]:
    """
  Like functools.wraps, but with finer-grained control over the name and docstring
  of the resulting function.
  """
def assert_unreachable(x) -> None: ...
def tuple_insert(t, idx, val): ...
def tuple_delete(t, idx): ...

class HashableFunction:
    """Decouples function equality and hash from its identity.

  Local lambdas and function defs are reallocated on each function call, making
  the functions created on different calls compare as unequal. This breaks our
  caching logic, which should really only care about comparing the semantics and
  not actual identity.

  This class makes it possible to compare different functions based on their
  semantics. The parts that are taken into account are: the bytecode of the
  wrapped function (which is cached by the CPython interpreter and is stable
  across the invocations of the surrounding function), and `closure` which
  should contain all values in scope that affect the function semantics. In
  particular `closure` should contain all elements of the function closure, or
  it should be possible to derive the relevant elements of the true function
  closure based solely on the contents of the `closure` argument (e.g. in case
  some closed-over values are not hashable, but are entirely determined by
  hashable locals).
  """
    f: Incomplete
    closure: Incomplete
    def __init__(self, f, closure) -> None: ...
    def __eq__(self, other): ...
    def __hash__(self): ...
    def __call__(self, *args, **kwargs): ...

def as_hashable_function(closure): ...

class HashablePartial:
    f: Incomplete
    args: Incomplete
    kwargs: Incomplete
    def __init__(self, f, *args, **kwargs) -> None: ...
    def __eq__(self, other): ...
    def __hash__(self): ...
    def __call__(self, *args, **kwargs): ...

def maybe_named_axis(axis, if_pos, if_named): ...
def distributed_debug_log(*pairs) -> None:
    """Format and log `pairs` if config.jax_distributed_debug is enabled.

  Args:
    pairs: A sequence of label/value pairs to log. The first pair is treated as
    a heading for subsequent pairs.
  """

class OrderedSet(Generic[T]):
    elts_set: set[T]
    elts_list: list[T]
    def __init__(self) -> None: ...
    def add(self, elt: T) -> None: ...
    def update(self, elts: Seq[T]) -> None: ...
    def __iter__(self) -> Iterator[T]: ...
    def __len__(self) -> int: ...
    def __contains__(self, elt: T) -> bool: ...

class HashableWrapper:
    x: Any
    hash: int | None
    def __init__(self, x) -> None: ...
    def __hash__(self): ...
    def __eq__(self, other): ...

def set_module(module: str) -> Callable[[T], T]: ...
def use_cpp_class(cpp_cls: Any) -> Callable[[T], T]: ...
def use_cpp_method(is_enabled: bool = True) -> Callable[[T], T]: ...

NumpyComplexWarning: type[Warning]
NumpyComplexWarning = np.ComplexWarning
