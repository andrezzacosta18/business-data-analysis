import abc
import numpy as np
from _typeshed import Incomplete
from jax._src import lib as lib
from jax._src.sharding import Sharding as Sharding
from typing import Any, Callable, Sequence

Shard = Any
Device = Any
Traceback = Any

class Array(abc.ABC):
    aval: Any
    @property
    def dtype(self) -> np.dtype: ...
    @property
    def ndim(self) -> int: ...
    @property
    def size(self) -> int: ...
    @property
    def itemsize(self) -> int: ...
    @property
    def shape(self) -> tuple[int, ...]: ...
    @property
    def sharding(self) -> Sharding: ...
    @property
    def addressable_shards(self) -> Sequence[Shard]: ...
    def __init__(self, shape, dtype: Incomplete | None = None, buffer: Incomplete | None = None, offset: int = 0, strides: Incomplete | None = None, order: Incomplete | None = None) -> None: ...
    def __getitem__(self, key) -> Array: ...
    def __setitem__(self, key, value) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Any: ...
    def __reversed__(self) -> Any: ...
    def __round__(self, ndigits: Incomplete | None = None) -> Array: ...
    def __lt__(self, other) -> Array: ...
    def __le__(self, other) -> Array: ...
    def __eq__(self, other) -> Array: ...
    def __ne__(self, other) -> Array: ...
    def __gt__(self, other) -> Array: ...
    def __ge__(self, other) -> Array: ...
    def __neg__(self) -> Array: ...
    def __pos__(self) -> Array: ...
    def __abs__(self) -> Array: ...
    def __invert__(self) -> Array: ...
    def __add__(self, other) -> Array: ...
    def __sub__(self, other) -> Array: ...
    def __mul__(self, other) -> Array: ...
    def __matmul__(self, other) -> Array: ...
    def __truediv__(self, other) -> Array: ...
    def __floordiv__(self, other) -> Array: ...
    def __mod__(self, other) -> Array: ...
    def __divmod__(self, other) -> Array: ...
    def __pow__(self, other) -> Array: ...
    def __lshift__(self, other) -> Array: ...
    def __rshift__(self, other) -> Array: ...
    def __and__(self, other) -> Array: ...
    def __xor__(self, other) -> Array: ...
    def __or__(self, other) -> Array: ...
    def __radd__(self, other) -> Array: ...
    def __rsub__(self, other) -> Array: ...
    def __rmul__(self, other) -> Array: ...
    def __rmatmul__(self, other) -> Array: ...
    def __rtruediv__(self, other) -> Array: ...
    def __rfloordiv__(self, other) -> Array: ...
    def __rmod__(self, other) -> Array: ...
    def __rdivmod__(self, other) -> Array: ...
    def __rpow__(self, other) -> Array: ...
    def __rlshift__(self, other) -> Array: ...
    def __rrshift__(self, other) -> Array: ...
    def __rand__(self, other) -> Array: ...
    def __rxor__(self, other) -> Array: ...
    def __ror__(self, other) -> Array: ...
    def __bool__(self) -> bool: ...
    def __complex__(self) -> complex: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __index__(self) -> int: ...
    def all(self, axis: int | Sequence[int] | None = None, out: Incomplete | None = None, keepdims: Incomplete | None = None) -> Array: ...
    def any(self, axis: int | Sequence[int] | None = None, out: Incomplete | None = None, keepdims: Incomplete | None = None) -> Array: ...
    def argmax(self, axis: int | None = None, out: Incomplete | None = None, keepdims: Incomplete | None = None) -> Array: ...
    def argmin(self, axis: int | None = None, out: Incomplete | None = None, keepdims: Incomplete | None = None) -> Array: ...
    def argpartition(self, kth, axis: int = -1, kind: str = 'introselect', order: Incomplete | None = None) -> Array: ...
    def argsort(self, axis: int | None = -1, kind: str = 'quicksort', order: Incomplete | None = None) -> Array: ...
    def astype(self, dtype) -> Array: ...
    def choose(self, choices, out: Incomplete | None = None, mode: str = 'raise') -> Array: ...
    def clip(self, min: Incomplete | None = None, max: Incomplete | None = None, out: Incomplete | None = None) -> Array: ...
    def compress(self, condition, axis: int | None = None, out: Incomplete | None = None) -> Array: ...
    def conj(self) -> Array: ...
    def conjugate(self) -> Array: ...
    def copy(self) -> Array: ...
    def cumprod(self, axis: int | Sequence[int] | None = None, dtype: Incomplete | None = None, out: Incomplete | None = None) -> Array: ...
    def cumsum(self, axis: int | Sequence[int] | None = None, dtype: Incomplete | None = None, out: Incomplete | None = None) -> Array: ...
    def diagonal(self, offset: int = 0, axis1: int = 0, axis2: int = 1) -> Array: ...
    def dot(self, b, *, precision: Incomplete | None = None) -> Array: ...
    def flatten(self) -> Array: ...
    @property
    def imag(self) -> Array: ...
    def item(self, *args) -> Any: ...
    def max(self, axis: int | Sequence[int] | None = None, out: Incomplete | None = None, keepdims: Incomplete | None = None, initial: Incomplete | None = None, where: Incomplete | None = None) -> Array: ...
    def mean(self, axis: int | Sequence[int] | None = None, dtype: Incomplete | None = None, out: Incomplete | None = None, keepdims: bool = False, *, where: Incomplete | None = None) -> Array: ...
    def min(self, axis: int | Sequence[int] | None = None, out: Incomplete | None = None, keepdims: Incomplete | None = None, initial: Incomplete | None = None, where: Incomplete | None = None) -> Array: ...
    @property
    def nbytes(self) -> int: ...
    def nonzero(self, *, size: Incomplete | None = None, fill_value: Incomplete | None = None) -> Array: ...
    def prod(self, axis: int | Sequence[int] | None = None, dtype: Incomplete | None = None, out: Incomplete | None = None, keepdims: Incomplete | None = None, initial: Incomplete | None = None, where: Incomplete | None = None) -> Array: ...
    def ptp(self, axis: int | Sequence[int] | None = None, out: Incomplete | None = None, keepdims: bool = False) -> Array: ...
    def ravel(self, order: str = 'C') -> Array: ...
    @property
    def real(self) -> Array: ...
    def repeat(self, repeats, axis: int | None = None, *, total_repeat_length: Incomplete | None = None) -> Array: ...
    def reshape(self, *args, order: str = 'C') -> Array: ...
    def round(self, decimals: int = 0, out: Incomplete | None = None) -> Array: ...
    def searchsorted(self, v, side: str = 'left', sorter: Incomplete | None = None) -> Array: ...
    def sort(self, axis: int | None = -1, kind: str = 'quicksort', order: Incomplete | None = None) -> Array: ...
    def squeeze(self, axis: int | Sequence[int] | None = None) -> Array: ...
    def std(self, axis: int | Sequence[int] | None = None, dtype: Incomplete | None = None, out: Incomplete | None = None, ddof: int = 0, keepdims: bool = False, *, where: Incomplete | None = None) -> Array: ...
    def sum(self, axis: int | Sequence[int] | None = None, dtype: Incomplete | None = None, out: Incomplete | None = None, keepdims: Incomplete | None = None, initial: Incomplete | None = None, where: Incomplete | None = None) -> Array: ...
    def swapaxes(self, axis1: int, axis2: int) -> Array: ...
    def take(self, indices, axis: int | None = None, out: Incomplete | None = None, mode: Incomplete | None = None) -> Array: ...
    def tobytes(self, order: str = 'C') -> bytes: ...
    def tolist(self) -> list[Any]: ...
    def trace(self, offset: int = 0, axis1: int = 0, axis2: int = 1, dtype: Incomplete | None = None, out: Incomplete | None = None) -> Array: ...
    def transpose(self, *args) -> Array: ...
    @property
    def T(self) -> Array: ...
    @property
    def mT(self) -> Array: ...
    def var(self, axis: int | Sequence[int] | None = None, dtype: Incomplete | None = None, out: Incomplete | None = None, ddof: int = 0, keepdims: bool = False, *, where: Incomplete | None = None) -> Array: ...
    def view(self, dtype: Incomplete | None = None, type: Incomplete | None = None) -> Array: ...
    def __array__(self) -> np.ndarray: ...
    def __dlpack__(self) -> Any: ...
    @property
    def at(self) -> _IndexUpdateHelper: ...
    @property
    def weak_type(self) -> bool: ...
    def addressable_data(self, index: int) -> Array: ...
    def block_until_ready(self) -> Array: ...
    def copy_to_host_async(self) -> None: ...
    def delete(self) -> None: ...
    def device(self) -> Device: ...
    def devices(self) -> set[Device]: ...
    @property
    def global_shards(self) -> Sequence[Shard]: ...
    def is_deleted(self) -> bool: ...
    @property
    def is_fully_addressable(self) -> bool: ...
    @property
    def is_fully_replicated(self) -> bool: ...
    def on_device_size_in_bytes(self) -> int: ...
    @property
    def traceback(self) -> Traceback: ...
    def unsafe_buffer_pointer(self) -> int: ...
    @property
    def device_buffers(self) -> Any: ...
ArrayLike = Array | np.ndarray | np.bool_ | np.number | bool | int | float | complex

class _IndexUpdateHelper:
    def __getitem__(self, index: Any) -> _IndexUpdateRef: ...

class _IndexUpdateRef:
    def get(self, indices_are_sorted: bool = False, unique_indices: bool = False, mode: str | None = None, fill_value: ArrayLike | None = None) -> Array: ...
    def set(self, values: Any, indices_are_sorted: bool = False, unique_indices: bool = False, mode: str | None = None, fill_value: ArrayLike | None = None) -> Array: ...
    def add(self, values: Any, indices_are_sorted: bool = False, unique_indices: bool = False, mode: str | None = None) -> Array: ...
    def mul(self, values: Any, indices_are_sorted: bool = False, unique_indices: bool = False, mode: str | None = None) -> Array: ...
    def multiply(self, values: Any, indices_are_sorted: bool = False, unique_indices: bool = False, mode: str | None = None) -> Array: ...
    def divide(self, values: Any, indices_are_sorted: bool = False, unique_indices: bool = False, mode: str | None = None) -> Array: ...
    def power(self, values: Any, indices_are_sorted: bool = False, unique_indices: bool = False, mode: str | None = None) -> Array: ...
    def min(self, values: Any, indices_are_sorted: bool = False, unique_indices: bool = False, mode: str | None = None) -> Array: ...
    def max(self, values: Any, indices_are_sorted: bool = False, unique_indices: bool = False, mode: str | None = None) -> Array: ...
    def apply(self, func: Callable[[ArrayLike], ArrayLike], indices_are_sorted: bool = False, unique_indices: bool = False, mode: str | None = None) -> Array: ...
