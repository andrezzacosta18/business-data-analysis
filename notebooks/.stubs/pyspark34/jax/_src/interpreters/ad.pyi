from _typeshed import Incomplete
from collections.abc import Generator, Sequence
from jax import config as config
from jax._src import core as core, linear_util as lu, source_info_util as source_info_util
from jax._src.ad_util import Zero as Zero, add_jaxvals as add_jaxvals, add_jaxvals_p as add_jaxvals_p, replace_internal_symbolic_zeros as replace_internal_symbolic_zeros, replace_rule_output_symbolic_zeros as replace_rule_output_symbolic_zeros, zeros_like_aval as zeros_like_aval, zeros_like_jaxval as zeros_like_jaxval, zeros_like_p as zeros_like_p
from jax._src.api_util import flatten_fun as flatten_fun, flatten_fun_nokwargs as flatten_fun_nokwargs
from jax._src.core import Literal as Literal, Primitive as Primitive, Trace as Trace, Tracer as Tracer, call_p as call_p, get_aval as get_aval, raise_to_shaped as raise_to_shaped
from jax._src.dtypes import dtype as dtype, float0 as float0
from jax._src.util import as_hashable_function as as_hashable_function, partition_list as partition_list, safe_map as safe_map, safe_zip as safe_zip, split_list as split_list, unzip2 as unzip2, weakref_lru_cache as weakref_lru_cache, wrap_name as wrap_name
from jax.tree_util import Partial as Partial, register_pytree_node as register_pytree_node, tree_flatten as tree_flatten, tree_unflatten as tree_unflatten
from typing import Any, Callable

zip = safe_zip
map = safe_map

def identity(x): ...
def jvp(fun: lu.WrappedFun, has_aux: bool = False, instantiate: bool = True, transform_stack: bool = True) -> Any: ...
def jvpfun(instantiate, transform_stack, primals, tangents) -> Generator[Incomplete, Incomplete, None]: ...
def jvp_subtrace(main, primals, tangents) -> Generator[Incomplete, Incomplete, None]: ...
def jvp_subtrace_aux(main, primals, tangents) -> Generator[Incomplete, Incomplete, None]: ...
def linearize(traceable, *primals, **kwargs): ...
def vjp(traceable, primals, has_aux: bool = False, reduce_axes=()): ...
def unpair_pval(pval): ...
def replace_float0s(primal, tangent): ...
def recast_to_float0(primal, tangent): ...
def backward_pass(jaxpr: core.Jaxpr, reduce_axes, transform_stack, consts, primals_in, cotangents_in): ...
def closed_backward_pass(jaxpr: core.ClosedJaxpr, reduce_axes, transform_stack, primals_in, cotangents_in): ...

class UndefinedPrimal:
    aval: Incomplete
    def __init__(self, aval) -> None: ...

def is_undefined_primal(x): ...
def get_primitive_transpose(p): ...
def nonzero_tangent_outputs(*args, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...

class JVPTrace(Trace):
    def pure(self, val): ...
    def lift(self, val): ...
    def sublift(self, val): ...
    def process_primitive(self, primitive, tracers, params): ...
    def process_call(self, call_primitive, f, tracers, params): ...
    def post_process_call(self, call_primitive, out_tracers, params): ...
    process_map = process_call
    post_process_map = post_process_call
    def process_custom_jvp_call(self, _, __, f_jvp, tracers, *, symbolic_zeros): ...
    def post_process_custom_jvp_call(self, out_tracers, _) -> None: ...
    def process_custom_vjp_call(self, _, __, fwd, bwd, tracers, out_trees, symbolic_zeros): ...
    def post_process_custom_vjp_call(self, out_tracers, _) -> None: ...
    def process_custom_transpose(self, prim, call, tracers, **params): ...
    def join(self, xt, yt): ...

class JVPTracer(Tracer):
    primal: Incomplete
    tangent: Incomplete
    def __init__(self, trace, primal, tangent) -> None: ...
    @property
    def aval(self): ...
    def full_lower(self): ...

call_param_updaters: dict[core.Primitive, Callable]
call_transpose_param_updaters: dict[core.Primitive, Callable]
primitive_jvps: dict[core.Primitive, Callable]
primitive_transposes: dict[core.Primitive, Callable]
reducing_transposes: dict[core.Primitive, Callable]

def deflinear(primitive, transpose_rule) -> None: ...
def linear_jvp(primitive, primals, tangents, **params): ...
def linear_transpose(transpose_rule, cotangent, *args, **kwargs): ...
def deflinear2(primitive, transpose_rule) -> None: ...
def linear_transpose2(transpose_rule, cotangent, *args, **kwargs): ...
def defjvp(primitive, *jvprules) -> None: ...
def standard_jvp(jvprules, primitive, primals, tangents, **params): ...
def defjvp2(primitive, *jvprules) -> None: ...
def standard_jvp2(jvprules, primitive, primals, tangents, **params): ...
def add_tangents(x, y): ...
def defbilinear(prim, lhs_rule, rhs_rule): ...
def bilinear_transpose(lhs_rule, rhs_rule, cotangent, x, y, **kwargs): ...
def defjvp_zero(primitive) -> None: ...
def zero_jvp(primitive, primals, tangents, **params): ...
def instantiate_zeros(tangent): ...
def instantiate_zeros_aval(aval, tangent): ...
def traceable(in_tree, *primals_and_tangents) -> Generator[Incomplete, Incomplete, None]: ...
def call_transpose(primitive, params, call_jaxpr, args, ct, _, reduce_axes): ...
def nonzero_outputs(*args, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def map_transpose(primitive, params, call_jaxpr, args, ct, _, reduce_axes): ...
def jvp_jaxpr(jaxpr: core.ClosedJaxpr, nonzeros: Sequence[bool], instantiate: bool | Sequence[bool]) -> tuple[core.ClosedJaxpr, list[bool]]: ...
def f_jvp_traceable(nonzeros, *primals_and_nztangents) -> Generator[Incomplete, Incomplete, None]: ...
def rearrange_binders(jaxpr: core.ClosedJaxpr, primals_in, tangents_in, primals_out, tangents_out): ...

custom_lin_p: core.Primitive

def raise_custom_vjp_error_on_jvp(*_, **__) -> None: ...

class CustomJVPException(Exception):
    def __init__(self) -> None: ...

class CustomVJPException(Exception):
    def __init__(self) -> None: ...
