import dataclasses
from _typeshed import Incomplete
from collections.abc import Generator
from jax import config as config
from jax._src import core as core, linear_util as lu, source_info_util as source_info_util
from jax._src.ad_util import SymbolicZero as SymbolicZero, Zero as Zero, add_jaxvals as add_jaxvals, add_jaxvals_p as add_jaxvals_p, instantiate as instantiate, replace_rule_output_symbolic_zeros as replace_rule_output_symbolic_zeros, zeros_like_jaxval as zeros_like_jaxval, zeros_like_p as zeros_like_p
from jax._src.core import AxisName as AxisName, Trace as Trace, Tracer as Tracer, raise_to_shaped as raise_to_shaped
from jax._src.tree_util import register_pytree_node as register_pytree_node, tree_flatten as tree_flatten, tree_unflatten as tree_unflatten
from jax._src.typing import Array as Array
from jax._src.util import as_hashable_function as as_hashable_function, canonicalize_axis as canonicalize_axis, curry as curry, memoize as memoize, moveaxis as moveaxis, safe_map as safe_map, safe_zip as safe_zip, split_list as split_list, unzip2 as unzip2, unzip3 as unzip3, weakref_lru_cache as weakref_lru_cache
from typing import Any, Callable

map: Incomplete
unsafe_map: Incomplete
zip: Incomplete
unsafe_zip: Incomplete

@dataclasses.dataclass(frozen=True)
class JumbleTy:
    binder: core.Var
    length: int | Tracer | core.Var
    elt_ty: core.DShapedArray
    replace = dataclasses.replace
    def __init__(self, binder, length, elt_ty) -> None: ...

@dataclasses.dataclass(frozen=True)
class IndexedAxisSize:
    idx: core.Var
    lengths: Array | core.Var | Tracer
    replace = dataclasses.replace
    def __init__(self, idx, lengths) -> None: ...

@dataclasses.dataclass(frozen=True)
class Jumble:
    aval: JumbleTy
    data: Array
    def __init__(self, aval, data) -> None: ...

class JumbleAxis: ...

jumble_axis: Incomplete

@dataclasses.dataclass(frozen=True)
class RaggedAxis:
    stacked_axis: int
    ragged_axes: tuple[tuple[int, Any], ...]
    @property
    def size(self): ...
    def move_stacked_axis(self, dst: int) -> RaggedAxis: ...
    def __init__(self, stacked_axis, ragged_axes) -> None: ...

def transpose_ragged_axes(dim: RaggedAxis, perm: tuple[int, ...]) -> RaggedAxis: ...
def make_batch_axis(ndim: int, stacked_axis: int, ragged_axes: list[tuple[int, Array | core.Var]]) -> int | RaggedAxis: ...
def bdim_as_shape(bdim: int | RaggedAxis, data_shape: core.Shape) -> core.Shape: ...
def shape_as_bdim(stacked_axis: int, data_shape: core.Shape) -> int | RaggedAxis: ...
Vmappable = Any
Elt = Any
MapSpec = Any
AxisSize = Any
GetIdx = Callable[[], Tracer]
ToEltHandler = Callable[[Callable, GetIdx, Vmappable, MapSpec], Elt]
FromEltHandler = Callable[[Callable, AxisSize, Elt, MapSpec], Vmappable]
MakeIotaHandler = Callable[[AxisSize], Array]

def to_elt(trace: Trace, get_idx: GetIdx, x: Vmappable, spec: MapSpec) -> Elt: ...

to_elt_handlers: dict[type, ToEltHandler]

def from_elt(trace: BatchTrace, axis_size: AxisSize, x: Elt, spec: MapSpec) -> Vmappable: ...

from_elt_handlers: dict[type, FromEltHandler]

def make_iota(axis_size: AxisSize) -> Array: ...

make_iota_handlers: dict[type, MakeIotaHandler]

def register_vmappable(data_type: type, spec_type: type, axis_size_type: type, to_elt: Callable, from_elt: Callable, make_iota: Callable | None): ...

vmappables: dict[type, tuple[type, type]]
spec_types: set[type]

def unregister_vmappable(data_type: type) -> None: ...
def is_vmappable(x: Any) -> bool: ...
def flatten_fun_for_vmap(in_tree, *args_flat) -> Generator[Incomplete, Incomplete, None]: ...

NotMapped: Incomplete
not_mapped: Incomplete

class BatchTracer(Tracer):
    val: Incomplete
    batch_dim: Incomplete
    source_info: Incomplete
    def __init__(self, trace, val, batch_dim: NotMapped | int | RaggedAxis, source_info: source_info_util.SourceInfo | None = None) -> None: ...
    @property
    def aval(self): ...
    def full_lower(self): ...
    def get_referent(self): ...

class BatchTrace(Trace):
    axis_name: Incomplete
    spmd_axis_name: Incomplete
    def __init__(self, *args, axis_name, spmd_axis_name: Incomplete | None = None) -> None: ...
    def pure(self, val): ...
    def lift(self, val): ...
    def sublift(self, val): ...
    def get_primitive_batcher(self, primitive, frame): ...
    def get_axis_primitive_batcher(self, primitive, frame): ...
    def get_frame(self, vals, dims) -> core.AxisEnvFrame: ...
    def process_primitive(self, primitive, tracers, params): ...
    def process_call(self, call_primitive, f, tracers, params): ...
    def post_process_call(self, call_primitive, out_tracers, params): ...
    def process_map(self, map_primitive, f: lu.WrappedFun, tracers, params): ...
    def post_process_map(self, call_primitive, out_tracers, params): ...
    def process_custom_jvp_call(self, prim, fun, jvp, tracers, *, symbolic_zeros): ...
    def post_process_custom_jvp_call(self, out_tracers, jvp_was_run): ...
    def process_custom_vjp_call(self, prim, fun, fwd, bwd, tracers, *, out_trees, symbolic_zeros): ...
    def post_process_custom_vjp_call(self, out_tracers, _): ...
    def post_process_custom_vjp_call_fwd(self, out_tracers, out_trees): ...

def batch(fun: lu.WrappedFun, axis_name: AxisName, axis_size, in_dims, out_dim_dests, main_type: type[BatchTrace] = ..., spmd_axis_name: tuple[AxisName, ...] | None = None) -> lu.WrappedFun: ...
def vtile(f_flat: lu.WrappedFun, in_axes_flat: tuple[int | None, ...], out_axes_flat: tuple[int | None, ...], tile_size: int | None, axis_name: AxisName, main_type: type[BatchTrace] = ...): ...
def batch_subtrace(main, in_dims, *in_vals) -> Generator[Incomplete, Incomplete, None]: ...
def indirectify_ragged_axes(dims): ...
def indirectify_ragged_axes_against_inputs_outputs(dims, in_vals, out_vals): ...
def resolve_ragged_axes(vals, dims): ...
def resolve_ragged_axes_against_inputs_outputs(in_vals, out_vals, dims): ...
def batch_jaxpr2(closed_jaxpr: core.ClosedJaxpr, axis_size: core.AxisSize, in_axes: tuple[int | NotMapped | RaggedAxis, ...], axis_name: AxisName, spmd_axis_name: AxisName, main_type: type[BatchTrace]) -> tuple[core.ClosedJaxpr, tuple[int | NotMapped | RaggedAxis, ...]]: ...
def handle_ragged(in_avals: list[core.AbstractValue], dim: RaggedAxis, aval: core.ShapedArray) -> tuple[int, core.ShapedArray]: ...
def batch_jaxpr(closed_jaxpr, axis_size, in_batched, instantiate, axis_name, spmd_axis_name, main_type): ...
def batch_jaxpr_axes(closed_jaxpr, axis_size, in_axes, out_axes_dest, axis_name, spmd_axis_name, main_type): ...

class ZeroIfMapped: ...

zero_if_mapped: Incomplete

def batch_custom_jvp_subtrace(main, in_dims, *in_vals) -> Generator[Incomplete, Incomplete, None]: ...
def batch_custom_vjp_bwd(bwd, axis_name, axis_size, in_dims, out_dim_dests, main_type, spmd_axis_name): ...
BatchingRule = Callable[..., tuple[Any, None | int | tuple[None | int, ...]]]
primitive_batchers: dict[core.Primitive, BatchingRule]
axis_primitive_batchers: dict[core.Primitive, Callable]
spmd_axis_primitive_batchers: dict[core.Primitive, Callable]

def defvectorized(prim) -> None: ...
def vectorized_batcher(prim, batched_args, batch_dims, **params): ...
def defbroadcasting(prim) -> None: ...
def broadcast_batcher(prim, args, dims, **params):
    """Process a primitive with built-in broadcasting.

  Args:
    args: the possibly-batched arguments
    dims: list or tuple of the same length as `args`, where each
      entry indicates the batching state of the corresponding entry to `args`:
      either an int indicating the batch dimension, or else `not_mapped`
      indicating no batching.
  """
def defreducer(prim, ident) -> None: ...
def reducer_batcher(prim, ident, batched_args, batch_dims, axes, **params): ...
def mask_ragged_axes(operand: Array, ident, axis_spec: RaggedAxis) -> Array: ...
def move_stacked_axis(operand, bdim, dst): ...
def broadcast(x, sz, axis): ...
def matchaxis(axis_name, sz, src, dst, x, sum_match: bool = False): ...
def bdim_at_front(x, bdim, size): ...
def add_batched(batched_args, batch_dims): ...
def zeros_like_batched(batched_args, batch_dims): ...
