import abc
import jax
from _typeshed import Incomplete
from collections.abc import Hashable, Iterator, Sequence
from jax import lax as lax, tree_util as tree_util
from jax._src import ad_util as ad_util, api as api, basearray as basearray, core as core, dispatch as dispatch, dtypes as dtypes, sharding_specs as sharding_specs, typing as typing
from jax._src.api import jit as jit, vmap as vmap
from jax._src.config import config as config
from jax._src.dtypes import float0 as float0
from jax._src.interpreters import ad as ad, batching as batching, mlir as mlir, pxla as pxla, xla as xla
from jax._src.lib import gpu_prng as gpu_prng, xla_client as xc
from jax._src.lib.mlir import ir as ir
from jax._src.lib.mlir.dialects import hlo as hlo
from jax._src.numpy.array_methods import _IndexUpdateHelper
from jax._src.partition_spec import PartitionSpec as PartitionSpec
from jax._src.sharding_impls import GSPMDSharding as GSPMDSharding, NamedSharding as NamedSharding, PmapSharding as PmapSharding, XLACompatibleSharding as XLACompatibleSharding
from jax._src.typing import Array as Array
from jax._src.util import safe_map as safe_map, safe_zip as safe_zip
from typing import Any, Callable, NamedTuple

map: Incomplete
unsafe_map: Incomplete
zip: Incomplete
unsafe_zip: Incomplete
Device: Incomplete
Shard = Any
Shape = tuple[int, ...]
UINT_DTYPES: Incomplete

class PRNGImpl(NamedTuple):
    """Specifies PRNG key shape and operations.

  A PRNG implementation is determined by a key type ``K`` and a
  collection of functions that operate on such keys. The key type
  ``K`` is an array type with element type uint32 and shape specified
  by ``key_shape``. The type signature of each operations is::

    seed :: int[] -> K
    fold_in :: K -> int[] -> K
    split[shape] :: K -> K[*shape]
    random_bits[shape, bit_width] :: K -> uint<bit_width>[*shape]

  A PRNG implementation is adapted to an array-like object of keys
  ``K`` by the ``PRNGKeyArray`` class, which should be created via the
  ``seed_with_impl`` function.
  """
    key_shape: Shape
    seed: Callable
    split: Callable
    random_bits: Callable
    fold_in: Callable
    tag: str = ...
    def __hash__(self) -> int: ...
    def pprint(self): ...

class PRNGKeyArrayMeta(abc.ABCMeta):
    """Metaclass for overriding PRNGKeyArray isinstance checks."""
    def __instancecheck__(cls, instance): ...

class PRNGKeyArray(jax.Array, metaclass=PRNGKeyArrayMeta):
    """An array whose elements are PRNG keys"""
    @abc.abstractmethod
    def unsafe_buffer_pointer(self) -> int: ...
    @abc.abstractmethod
    def block_until_ready(self) -> PRNGKeyArray: ...
    @abc.abstractmethod
    def copy_to_host_async(self) -> None: ...
    @property
    @abc.abstractmethod
    def shape(self) -> tuple[int, ...]: ...
    @property
    @abc.abstractmethod
    def ndim(self) -> int: ...
    @property
    @abc.abstractmethod
    def size(self) -> int: ...
    @property
    @abc.abstractmethod
    def dtype(self): ...
    @property
    @abc.abstractmethod
    def itemsize(self): ...
    @property
    @abc.abstractmethod
    def sharding(self): ...
    @property
    @abc.abstractmethod
    def at(self) -> _IndexUpdateHelper: ...
    @abc.abstractmethod
    def __len__(self) -> int: ...
    @abc.abstractmethod
    def __iter__(self) -> Iterator[PRNGKeyArray]: ...
    @abc.abstractmethod
    def reshape(self, *args, order: str = 'C') -> PRNGKeyArray: ...
    @property
    @abc.abstractmethod
    def T(self) -> PRNGKeyArray: ...
    @abc.abstractmethod
    def __getitem__(self, _) -> PRNGKeyArray: ...
    @abc.abstractmethod
    def ravel(self, *_, **__) -> PRNGKeyArray: ...
    @abc.abstractmethod
    def squeeze(self, *_, **__) -> PRNGKeyArray: ...
    @abc.abstractmethod
    def swapaxes(self, *_, **__) -> PRNGKeyArray: ...
    @abc.abstractmethod
    def take(self, *_, **__) -> PRNGKeyArray: ...
    @abc.abstractmethod
    def transpose(self, *_, **__) -> PRNGKeyArray: ...
    @abc.abstractmethod
    def flatten(self, *_, **__) -> PRNGKeyArray: ...
    @property
    @abc.abstractmethod
    def is_fully_addressable(self) -> bool: ...
    @property
    @abc.abstractmethod
    def is_fully_replicated(self) -> bool: ...
    @abc.abstractmethod
    def device(self) -> Device: ...
    @abc.abstractmethod
    def devices(self) -> set[Device]: ...
    @abc.abstractmethod
    def delete(self) -> None: ...
    @abc.abstractmethod
    def is_deleted(self) -> bool: ...
    @abc.abstractmethod
    def on_device_size_in_bytes(self) -> int: ...
    @property
    @abc.abstractmethod
    def addressable_shards(self) -> list[Shard]: ...
    @property
    @abc.abstractmethod
    def global_shards(self) -> list[Shard]: ...
    @abc.abstractmethod
    def addressable_data(self, index: int) -> PRNGKeyArray: ...

class PRNGKeyArrayImpl(PRNGKeyArray):
    """An array of PRNG keys backed by an RNG implementation.

  This class lifts the definition of a PRNG, provided in the form of a
  ``PRNGImpl``, into an array-like pytree class. Instances of this
  class behave like an array whose base elements are keys, hiding the
  fact that keys are typically arrays (of ``uint32`` dtype) themselves.

  PRNGKeyArrays are also restricted relative to JAX arrays in that
  they do not expose arithmetic operations. They instead expose
  wrapper methods around the PRNG implementation functions (``split``,
  ``random_bits``, ``fold_in``).
  """
    impl: PRNGImpl
    def __init__(self, impl, key_data: Any) -> None: ...
    def block_until_ready(self): ...
    def copy_to_host_async(self) -> None: ...
    @property
    def aval(self): ...
    @property
    def shape(self): ...
    @property
    def size(self): ...
    @property
    def ndim(self): ...
    @property
    def dtype(self): ...
    @property
    def itemsize(self): ...
    device: Incomplete
    devices: Incomplete
    is_fully_addressable: Incomplete
    is_fully_replicated: Incomplete
    delete: Incomplete
    is_deleted: Incomplete
    on_device_size_in_bytes: Incomplete
    unsafe_buffer_pointer: Incomplete
    def unsafe_raw_array(self): ...
    def addressable_data(self, index: int) -> PRNGKeyArrayImpl: ...
    @property
    def addressable_shards(self) -> list[Shard]: ...
    @property
    def global_shards(self) -> list[Shard]: ...
    @property
    def sharding(self): ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[PRNGKeyArrayImpl]: ...
    def pprint(self): ...
    def copy(self): ...
    __hash__: Incomplete
    __array_priority__: int
    @property
    def at(self) -> _IndexUpdateHelper: ...
    @property
    def T(self) -> PRNGKeyArray: ...
    def __getitem__(self, _) -> PRNGKeyArray: ...
    def flatten(self, *_, **__) -> PRNGKeyArray: ...
    def ravel(self, *_, **__) -> PRNGKeyArray: ...
    def reshape(self, *_, **__) -> PRNGKeyArray: ...
    def squeeze(self, *_, **__) -> PRNGKeyArray: ...
    def swapaxes(self, *_, **__) -> PRNGKeyArray: ...
    def take(self, *_, **__) -> PRNGKeyArray: ...
    def transpose(self, *_, **__) -> PRNGKeyArray: ...

def prngkeyarrayimpl_flatten(x): ...
def prngkeyarrayimpl_unflatten(impl, children): ...
def seed_with_impl(impl: PRNGImpl, seed: int | Array) -> PRNGKeyArrayImpl: ...
def keys_shaped_array(impl, shape): ...
def keys_aval_to_base_arr_aval(keys_aval): ...
def base_arr_shape_to_keys_shape(impl, base_arr_shape): ...
def make_key_array_phys_sharding(aval, sharding, is_sharding_from_xla): ...

class KeyTyRules:
    @staticmethod
    def full(shape, fill_value, dtype): ...
    @staticmethod
    def physical_element_aval(dtype) -> core.ShapedArray: ...
    @staticmethod
    def physical_const(val) -> Array: ...
    @staticmethod
    def physical_hlo_sharding(aval, hlo_sharding: xc.HloSharding) -> xc.HloSharding: ...
    @staticmethod
    def logical_op_sharding(aval, phys_sharding) -> XLACompatibleSharding: ...
    @staticmethod
    def result_handler(sticky_device, aval): ...
    @staticmethod
    def local_sharded_result_handler(aval, sharding, indices): ...
    @staticmethod
    def global_sharded_result_handler(aval, out_sharding, committed, is_out_sharding_from_xla): ...
    @staticmethod
    def make_sharded_array(aval, sharding, arrays, committed): ...
    @staticmethod
    def device_put_sharded(vals, aval, sharding, devices): ...
    @staticmethod
    def device_put_replicated(val, aval, sharding, devices): ...

class KeyTy(dtypes.ExtendedDType):
    impl: Hashable
    type: Incomplete
    def __init__(self, impl) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def itemsize(self) -> int: ...
    def __eq__(self, other): ...
    def __hash__(self) -> int: ...

def key_array_shard_arg_handler(x: PRNGKeyArrayImpl, devices, indices, sharding): ...
def key_array_constant_handler(x): ...
def iterated_vmap_unary(n, f): ...
def squeeze_vmap(f, left): ...
def iterated_vmap_binary_bcast(shape1, shape2, f): ...
def random_seed(seeds, impl): ...

random_seed_p: Incomplete

def random_seed_abstract_eval(seeds_aval, *, impl): ...
def random_seed_impl(seeds, *, impl): ...
def random_seed_impl_base(seeds, *, impl): ...
def random_seed_lowering(ctx, seeds, *, impl): ...
def random_split(keys, shape: Shape): ...

random_split_p: Incomplete

def random_split_abstract_eval(keys_aval, *, shape): ...
def random_split_impl(keys, *, shape): ...
def random_split_impl_base(impl, base_arr, keys_ndim, *, shape): ...
def random_split_lowering(ctx, keys, *, shape): ...
def random_fold_in(keys, msgs): ...

random_fold_in_p: Incomplete

def random_fold_in_abstract_eval(keys_aval, msgs_aval): ...
def random_fold_in_impl(keys, msgs): ...
def random_fold_in_impl_base(impl, base_arr, msgs, keys_shape): ...
def random_fold_in_lowering(ctx, keys, msgs): ...
def random_bits(keys, bit_width, shape): ...

random_bits_p: Incomplete

def random_bits_abstract_eval(keys_aval, *, bit_width, shape): ...
def random_bits_impl(keys, *, bit_width, shape): ...
def random_bits_impl_base(impl, base_arr, keys_ndim, *, bit_width, shape): ...
def random_bits_lowering(ctx, keys, *, bit_width, shape): ...
def random_wrap(base_arr, *, impl): ...

random_wrap_p: Incomplete

def random_wrap_abstract_eval(base_arr_aval, *, impl): ...
def random_wrap_impl(base_arr, *, impl): ...
def random_wrap_lowering(ctx, base_arr, *, impl): ...
def random_wrap_batch_rule(batched_args, batch_dims, *, impl): ...
def random_unwrap(keys): ...

random_unwrap_p: Incomplete

def random_unwrap_abstract_eval(keys_aval): ...
def random_unwrap_impl(keys): ...
def random_unwrap_lowering(ctx, keys): ...
def threefry_seed(seed: typing.Array) -> typing.Array:
    """Create a single raw threefry PRNG key from an integer seed.

  Args:
    seed: a 64- or 32-bit integer used as the value of the key.

  Returns:
    The PRNG key contents, modeled as an array of shape (2,) and dtype
    uint32. The key is constructed from a 64-bit seed by effectively
    bit-casting to a pair of uint32 values (or from a 32-bit seed by
    first padding out with zeros).
  """

rotate_left: Incomplete

def apply_round(v, rot): ...
def rotate_list(xs): ...
def rolled_loop_step(i, state): ...

threefry2x32_p: Incomplete

def iota_2x32_shape(shape):
    """Reshaped ``uint64`` iota, as two parallel ``uint32`` arrays.

  Setting aside representation, this function essentially computes the
  equivalent of::

    jax.lax.iota(dtype=np.uint64, size=math.prod(shape)).reshape(shape)

  However:

  * It returns two parallel ``uint32`` arrays instead of one
    ``uint64`` array. This renders it invariant under either setting of
    the system-wide ``jax_enable_x64`` configuration flag.

  * It lowers in a way such that the compiler's automatic SPMD
    partitioner recognizes its partitionability.

  For example::

    >>> import numpy as np
    >>> from jax import lax
    >>> from jax._src import prng

    >>> prng.iota_2x32_shape((3, 4))
    [Array([[0, 0, 0, 0],
            [0, 0, 0, 0],
            [0, 0, 0, 0]], dtype=uint32),
     Array([[ 0,  1,  2,  3],
            [ 4,  5,  6,  7],
            [ 8,  9, 10, 11]], dtype=uint32)]

    >>> def reshaped_iota(shape):
    ...   return lax.iota(size=math.prod(shape), dtype=np.uint32).reshape(shape)
    ...
    >>> reshaped_iota((3, 4))
    Array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11]], dtype=uint32)

  Args:
    shape: the output shape

  Returns:
    A pair of ``uint32`` arrays ``(counts_hi, counts_lo)``, both of
    shape ``shape``, representing the higher-order and lower-order 32
    bits of the 64 bit unsigned iota.
  """

iota_2x32_shape_p: Incomplete

def iota_2x32_shape_abstract_eval(*, shape): ...
def bcast_iotas_to_reshaped_iota(add: Callable[[ir.Value, ir.Value], ir.Value], mul: Callable[[core.DimSize, ir.Value], ir.Value], shape: core.Shape, iotas: Sequence[ir.Value]) -> ir.Value: ...
def iota_2x32_shape_lowering(ctx, *, shape): ...
def threefry_2x32(keypair, count):
    """Apply the Threefry 2x32 hash.

  Args:
    keypair: a pair of 32bit unsigned integers used for the key.
    count: an array of dtype uint32 used for the counts.

  Returns:
    An array of dtype uint32 with the same shape as `count`.
  """
def threefry_split(key: typing.Array, shape: Shape) -> typing.Array: ...
def threefry_fold_in(key: typing.Array, data: typing.Array) -> typing.Array: ...
def threefry_random_bits(key: typing.Array, bit_width, shape):
    """Sample uniform random bits of given width and shape using PRNG key."""

threefry_prng_impl: Incomplete
rbg_prng_impl: Incomplete
unsafe_rbg_prng_impl: Incomplete
