import jax._src.pretty_printer as pp
import threading
from _typeshed import Incomplete
from collections.abc import Generator, Hashable, Iterable, Iterator, Sequence
from dataclasses import dataclass
from jax._src import dtypes as dtypes, effects as effects, linear_util as lu, source_info_util as source_info_util, traceback_util as traceback_util, typing as typing
from jax._src.config import config as config
from jax._src.errors import ConcretizationTypeError as ConcretizationTypeError, TracerArrayConversionError as TracerArrayConversionError, TracerBoolConversionError as TracerBoolConversionError, TracerIntegerConversionError as TracerIntegerConversionError, UnexpectedTracerError as UnexpectedTracerError
from jax._src.lib import jax_jit as jax_jit
from jax._src.typing import Array as Array, DimSize as DimSize, Shape as Shape
from jax._src.util import HashableFunction as HashableFunction, HashableWrapper as HashableWrapper, as_hashable_function as as_hashable_function, curry as curry, partition_list as partition_list, safe_map as safe_map, safe_zip as safe_zip, tuple_delete as tuple_delete, tuple_insert as tuple_insert, weakref_lru_cache as weakref_lru_cache
from typing import Any, Callable, ClassVar, DefaultDict, Generic, NamedTuple, TypeVar, overload

zip: Incomplete
unsafe_zip: Incomplete
map: Incomplete
unsafe_map: Incomplete
Effect: Incomplete
Effects: Incomplete
EffectTypeSet: Incomplete
no_effects: Effects

class JaxprDebugInfo(NamedTuple):
    traced_for: str
    func_src_info: str
    arg_names: tuple[str | None, ...]
    result_paths: tuple[str | None, ...]

class Jaxpr:
    constvars: Incomplete
    invars: Incomplete
    outvars: Incomplete
    eqns: Incomplete
    effects: Incomplete
    debug_info: Incomplete
    def __init__(self, constvars: Sequence[Var], invars: Sequence[Var], outvars: Sequence[Atom], eqns: Sequence[JaxprEqn], effects: Effects = ..., debug_info: JaxprDebugInfo | None = None) -> None:
        """
    Args:
      constvars: list of variables introduced for constants. Array constants are
        replaced with such variables while scalar constants are kept inline.
      invars: list of input variables. Together, `constvars` and `invars` are
        the inputs to the Jaxpr.
      outvars: list of output atoms.
      eqns: list of equations.
      effects: set of effects. The effects on a jaxpr are a superset of the
        union of the effects for each equation.
      debug_info: optional JaxprDebugInfo.
    """
    def pretty_print(self, *, source_info: bool = False, print_shapes: bool = True, custom_pp_eqn_rules: bool = True, name_stack: bool = False, print_effects: bool = False, **kw): ...
    def replace(self, *, constvars: Incomplete | None = None, invars: Incomplete | None = None, outvars: Incomplete | None = None, eqns: Incomplete | None = None, effects: Incomplete | None = None, debug_info: Incomplete | None = None): ...

def join_effects(*effects: Effects) -> Effects: ...
def jaxprs_in_params(params) -> Iterator[Jaxpr]: ...
def subjaxprs(jaxpr: Jaxpr) -> Iterator[Jaxpr]:
    """Generator for all subjaxprs found in the params of jaxpr.eqns.

  Does not descend recursively into the found subjaxprs.
  """

class ClosedJaxpr:
    jaxpr: Incomplete
    consts: Incomplete
    def __init__(self, jaxpr: Jaxpr, consts: Sequence) -> None: ...
    @property
    def in_avals(self): ...
    @property
    def out_avals(self): ...
    @property
    def literals(self): ...
    @property
    def eqns(self): ...
    @property
    def effects(self) -> Effects: ...
    def map_jaxpr(self, f): ...
    def replace(self, *, jaxpr: Incomplete | None = None, consts: Incomplete | None = None): ...
    def pretty_print(self, *, source_info: bool = False, print_shapes: bool = True, name_stack: bool = False, custom_pp_eqn_rules: bool = True, **kw): ...

def jaxpr_as_fun(closed_jaxpr: ClosedJaxpr, *args): ...

class JaxprEqn(NamedTuple):
    invars: list[Atom]
    outvars: list[Var]
    primitive: Primitive
    params: dict[str, Any]
    effects: Effects
    source_info: source_info_util.SourceInfo
    def replace(self, invars: list[Atom] | None = None, outvars: list[Var] | None = None, primitive: Primitive | None = None, params: dict[str, Any] | None = None, effects: Effects | None = None, source_info: source_info_util.SourceInfo | None = None): ...

def new_jaxpr_eqn(invars, outvars, primitive, params, effects, source_info: Incomplete | None = None): ...

class Var:
    count: int
    suffix: str
    aval: AbstractValue
    def __init__(self, count: int, suffix: str, aval: AbstractValue) -> None: ...
    def __lt__(self, other): ...

def gensym(jaxprs: Sequence[Jaxpr] | None = None, suffix: str = '') -> Callable[[AbstractValue], Var]:
    """Produce distinct variables, printed with the optional suffix.

  If `jaxprs` is provided, the variables produced will be distinct from those in
  any of the given jaxprs.
  """

class DropVar(Var):
    def __init__(self, aval: AbstractValue) -> None: ...

class Literal:
    val: Any
    aval: AbstractValue
    hash: int | None
    def __init__(self, val, aval) -> None: ...
    __hash__: Incomplete

literalable_types: set[type]
Atom = Var | Literal

class Primitive:
    name: str
    multiple_results: bool
    call_primitive: bool
    map_primitive: bool
    def __init__(self, name: str) -> None: ...
    def bind(self, *args, **params): ...
    def bind_with_trace(self, trace, args, params): ...
    def def_impl(self, impl): ...
    def def_abstract_eval(self, abstract_eval): ...
    def def_effectful_abstract_eval(self, effectful_abstract_eval): ...
    def def_custom_bind(self, bind): ...
    def impl(self, *args, **params) -> None: ...
    def abstract_eval(self, *args, **params) -> None: ...
    def get_bind_params(self, params): ...

def traverse_jaxpr_params(f, params):
    """Applies f to each jaxpr parameter and returns a tuple of returned values."""
def eval_jaxpr(jaxpr: Jaxpr, consts, *args, propagate_source_info: bool = True): ...
TracerType = TypeVar('TracerType', bound='Tracer')

class Trace(Generic[TracerType]):
    main: MainTrace
    level: int
    sublevel: Sublevel
    def __init__(self, main: MainTrace, sublevel: Sublevel) -> None: ...
    def full_raise(self, val) -> TracerType: ...
    def pure(self, val) -> TracerType: ...
    def lift(self, tracer) -> TracerType: ...
    def sublift(self, tracer) -> TracerType: ...
    def process_primitive(self, primitive, tracers, params) -> None: ...
    def process_call(self, call_primitive, f, tracers, params) -> None: ...
    def process_map(self, map_primitive, f, tracers, params) -> None: ...
    def process_custom_jvp_call(self, primitive, fun, jvp, tracers, *, symbolic_zeros) -> None: ...
    def process_custom_transpose(self, prim, call, tracers, **params) -> None: ...
    def process_custom_vjp_call(self, primitive, fun, fwd, bwd, tracers, out_trees, symbolic_zeros) -> None: ...

def raise_as_much_as_possible(tracer) -> Tracer: ...
def escaped_tracer_error(tracer, detail: Incomplete | None = None): ...
def check_scalar_conversion(arr: Array): ...
def check_integer_conversion(arr: Array): ...
def check_bool_conversion(arr: Array, warn_on_empty: bool = False): ...

class Tracer(typing.Array):
    __array_priority__: int
    def __array__(self, *args, **kw) -> None: ...
    def __dlpack__(self, *args, **kw) -> None: ...
    def tolist(self) -> None: ...
    def tobytes(self, order: str = 'C') -> None: ...
    def __init__(self, trace: Trace) -> None: ...
    def __iter__(self): ...
    def __reversed__(self): ...
    def __len__(self) -> int: ...
    @property
    def sharding(self) -> None: ...
    @property
    def addressable_shards(self) -> None: ...
    @property
    def at(self): ...
    @property
    def aval(self) -> None: ...
    def get_referent(self) -> Any: ...
    def __bool__(self) -> bool: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __complex__(self) -> complex: ...
    def __hex__(self): ...
    def __oct__(self): ...
    def __index__(self) -> int: ...
    def __reduce__(self) -> None: ...
    def __setitem__(self, idx, val) -> None: ...
    def __array_module__(self, types): ...
    def __getattr__(self, name): ...
    def addressable_data(self, index) -> None: ...
    @property
    def block_until_ready(self) -> None: ...
    @property
    def copy_to_host_async(self) -> None: ...
    def delete(self) -> None: ...
    def device(self) -> None: ...
    def devices(self) -> None: ...
    @property
    def global_shards(self) -> None: ...
    def is_deleted(self) -> None: ...
    @property
    def is_fully_addressable(self) -> None: ...
    @property
    def is_fully_replicated(self) -> None: ...
    def on_device_size_in_bytes(self) -> None: ...
    @property
    def traceback(self) -> None: ...
    def unsafe_buffer_pointer(self) -> None: ...

class aval_property(NamedTuple):
    fget: Incomplete

class aval_method(NamedTuple):
    fun: Incomplete

class EvalTrace(Trace):
    def pure(self, x): ...
    lift = pure
    sublift = pure
    def process_primitive(self, primitive, tracers, params): ...
    def process_call(self, primitive, f, tracers, params): ...
    process_map = process_call
    def process_custom_transpose(self, primitive, call, tracers, **_): ...
    def process_custom_jvp_call(self, primitive, fun, jvp, tracers, **_): ...
    def process_custom_vjp_call(self, primitive, fun, fwd, bwd, tracers, **_): ...

class MainTrace:
    level: int
    trace_type: type[Trace]
    payload: dict[str, Any]
    def __init__(self, level, trace_type, **payload) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def with_cur_sublevel(self): ...

class TraceStack:
    stack: list[MainTrace]
    dynamic: MainTrace
    def __init__(self) -> None: ...
    def next_level(self) -> int: ...
    def push(self, main_trace: MainTrace) -> None: ...
    def pop(self) -> None: ...
    def copy(self): ...

class Sublevel:
    level: Incomplete
    def __init__(self, level: int) -> None: ...
    def __eq__(self, other): ...
    def __lt__(self, other): ...

class AxisEnvFrame(NamedTuple):
    name: Incomplete
    size: Incomplete
    main_trace: Incomplete
AxisName = Hashable
no_axis_name: Incomplete

class TraceState:
    trace_stack: TraceStack
    substack: list[Sublevel]
    axis_env: list[AxisEnvFrame]
    def __init__(self) -> None: ...
    def copy(self): ...

class ThreadLocalState(threading.local):
    trace_state: Incomplete
    def __init__(self) -> None: ...

thread_local_state: Incomplete

def trace_state_clean() -> bool: ...
def reset_trace_state() -> bool:
    """Resets the global trace state and returns True if it was already clean."""
def cur_sublevel() -> Sublevel: ...

TRACER_LEAK_DEBUGGER_WARNING: str

def maybe_find_leaked_tracers(x: MainTrace | Sublevel | None) -> list[Tracer]:
    """Find the leaked tracers holding a reference to the MainTrace or SubLevel.

  It's possible there's none! eg. there's some cases where JAX itself holds a
  reference to `x` inside of a lambda closure, and no tracers were leaked
  by the user. In this case an empty list is returned.
  """
def leaked_tracer_error(name: str, t, tracers: list[Tracer]) -> Exception: ...
def new_main(trace_type: type[Trace], dynamic: bool = False, **payload) -> Generator[MainTrace, None, None]: ...
def new_dynamic(level: int) -> Generator[None, None, None]: ...
def dynamic_level() -> int: ...
def new_base_main(trace_type: type[Trace], **payload) -> Generator[MainTrace, None, None]: ...
def ensure_compile_time_eval() -> Generator[None, None, None]:
    '''Context manager to ensure evaluation at trace/compile time (or error).

  Some JAX APIs like :func:`jax.jit` and :func:`jax.lax.scan` involve staging,
  i.e., delaying the evaluation of numerical expressions (like :mod:`jax.numpy`
  function applications) so that instead of performing those computations
  eagerly while evaluating the corresponding Python expressions, their
  computation is carried out separately, e.g. after optimized compilation. But
  this delay can be undesirable. For example, numerical values might be needed
  to evaluate Python control flow and so their evaluation cannot be delayed. As
  another example, it may be beneficial to ensure compile time evaluation (or
  "constant folding") for performance reasons.

  This context manager ensures that JAX computations are evaluated eagerly. If
  eager evaluation is not possible, a ``ConcretizationTypeError`` is raised.

  Here\'s a contrived example::

    import jax
    import jax.numpy as jnp

    @jax.jit
    def f(x):
      with jax.ensure_compile_time_eval():
        y = jnp.sin(3.0)
        z = jnp.sin(y)
        z_positive = z > 0
      if z_positive:  # z_positive is usable in Python control flow
        return jnp.sin(x)
      else:
        return jnp.cos(x)

  Here\'s a real-world example from https://github.com/google/jax/issues/3974::

    import jax
    import jax.numpy as jnp
    from jax import random

    @jax.jit
    def jax_fn(x):
      with jax.ensure_compile_time_eval():
        y = random.randint(random.PRNGKey(0), (1000,1000), 0, 100)
      y2 = y @ y
      x2 = jnp.sum(y2) * x
      return x2

  A similar behavior can often be achieved simply by \'hoisting\' the constant
  expression out of the corresponding staging API::

    y = random.randint(random.PRNGKey(0), (1000,1000), 0, 100)

    @jax.jit
    def jax_fn(x):
      y2 = y @ y
      x2 = jnp.sum(y2)*x
      return x2

  But in some cases it can be more convenient to use this context manager.
  '''
eval_context = ensure_compile_time_eval

def new_sublevel() -> Generator[None, None, None]: ...
def full_lower(val): ...
def find_top_trace(xs) -> Trace: ...
def get_referent(x: Any) -> Any: ...
def same_referent(x: Any, y: Any) -> bool: ...
def dedup_referents(itr: Iterable[Any]) -> list[Any]: ...
def definitely_equal(x, y): ...

class AbstractValue:
    def at_least_vspace(self) -> None: ...
    def strip_weak_type(self) -> AbstractValue: ...
    def strip_named_shape(self) -> AbstractValue: ...
    def join(self, other) -> None: ...
    def update(self, **kwargs) -> None: ...
    def str_short(self, short_dtypes: bool = False): ...

class DBIdx(NamedTuple):
    val: int

@dataclass(frozen=True)
class InDBIdx:
    val: int
    def __init__(self, val) -> None: ...

@dataclass(frozen=True)
class OutDBIdx:
    val: int
    def __init__(self, val) -> None: ...
InputType = tuple[tuple[AbstractValue, bool], ...]
OutputType = tuple[tuple[AbstractValue, bool], ...]

class Bot(AbstractValue): ...

bot: Incomplete

def lattice_join(x: AbstractValue | None, y: AbstractValue | None) -> AbstractValue: ...
Value = Any

def valid_jaxtype(x) -> bool: ...
def check_valid_jaxtype(x) -> None: ...
def concrete_aval(x): ...
def get_aval(x): ...
def concretization_function_error(fun, suggest_astype: bool = False): ...
def concrete_or_error(force: Any, val: Any, context: str = ''):
    """Like force(val), but gives the context in the error message."""
def concrete_dim_or_error(val: Any, context: str = ''):
    """Like concrete_or_error(operator.index)."""
@overload
def physical_aval(aval: ShapedArray) -> ShapedArray: ...
@overload
def physical_aval(aval: DShapedArray) -> DShapedArray: ...
@overload
def physical_aval(aval: AbstractValue) -> AbstractValue: ...

class UnshapedArray(AbstractValue):
    array_abstraction_level: int
    dtype: Incomplete
    weak_type: Incomplete
    def __init__(self, dtype, weak_type: bool = False) -> None: ...
    def update(self, dtype: Incomplete | None = None, weak_type: Incomplete | None = None): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __hash__(self): ...
    def at_least_vspace(self) -> AbstractValue: ...
    def join(self, other): ...
    def str_short(self, short_dtypes: bool = False) -> str: ...
    def strip_weak_type(self):
        """Returns a copy of the aval with weak_type=False."""
    @property
    def shape(self) -> None: ...

class ShapedArray(UnshapedArray):
    array_abstraction_level: int
    shape: Incomplete
    dtype: Incomplete
    weak_type: Incomplete
    named_shape: Incomplete
    def __init__(self, shape, dtype, weak_type: bool = False, named_shape: Incomplete | None = None) -> None: ...
    def update(self, shape: Incomplete | None = None, dtype: Incomplete | None = None, weak_type: Incomplete | None = None, named_shape: Incomplete | None = None): ...
    ndim: Incomplete
    size: Incomplete
    broadcast: ClassVar[aval_method | None]
    transpose: ClassVar[aval_method | None]
    reshape: ClassVar[aval_method | None]
    def __eq__(self, other): ...
    def __hash__(self): ...
    def at_least_vspace(self): ...
    def join(self, other): ...
    def str_short(self, short_dtypes: bool = False): ...
    def strip_named_shape(self): ...

class ConcreteArray(ShapedArray):
    array_abstraction_level: int
    val: Incomplete
    def __init__(self, dtype, val, weak_type: Incomplete | None = None) -> None: ...
    def update(self, dtype: Incomplete | None = None, val: Incomplete | None = None, weak_type: Incomplete | None = None): ...
    def __eq__(self, other): ...
    def __hash__(self): ...
    def join(self, other) -> AbstractValue: ...
    def str_short(self, short_dtypes: bool = False) -> str: ...

def primal_dtype_to_tangent_dtype(primal_dtype): ...

class DShapedArray(UnshapedArray):
    shape: tuple[AxisSize, ...]
    array_abstraction_level: int
    dtype: Incomplete
    weak_type: Incomplete
    def __init__(self, shape, dtype, weak_type: bool = False) -> None: ...
    ndim: Incomplete
    size: Incomplete
    def str_short(self, short_dtypes: bool = False) -> str: ...
    def update(self, shape: Incomplete | None = None, dtype: Incomplete | None = None, weak_type: Incomplete | None = None): ...
    def __eq__(self, other): ...
    def __hash__(self): ...
    def join(self, other): ...
    def at_least_vspace(self): ...

class DConcreteArray(DShapedArray):
    array_abstraction_level: int
    val: Incomplete
    def __init__(self, shape, dtype, weak_type, val) -> None: ...

pytype_aval_mappings: dict[type, Callable[[Any], AbstractValue]]

class DArray:
    def __init__(self, aval, data) -> None: ...
    shape: Incomplete
    dtype: Incomplete
    def __hash__(self) -> int: ...
    def __eq__(self, other): ...
    def __len__(self) -> int: ...

@dataclass(frozen=True, eq=True)
class bint(dtypes.ExtendedDType):
    bound: int
    @property
    def type(self) -> type: ...
    @property
    def name(self) -> str: ...
    def __init__(self, bound) -> None: ...
AxisSize = int | DArray | Tracer | Var | DBIdx | InDBIdx | OutDBIdx

class AbstractToken(AbstractValue):
    def join(self, other): ...
    def str_short(self, short_dtypes: bool = False): ...
    def at_least_vspace(self): ...

abstract_token: AbstractToken

class Token: ...

token: Token

def raise_to_shaped(aval: AbstractValue, weak_type: Incomplete | None = None): ...

raise_to_shaped_mappings: dict[type, Callable]

class InconclusiveDimensionOperation(Exception):
    """Raised when we cannot conclusively compute with symbolic dimensions."""

def is_symbolic_dim(v: Any) -> bool:
    """Checks if a value is a symbolic dimension used for shape polymorphism.

  This should be used very rarely, because symbolic dimensions overload all
  operators, and should just work.
  """
def is_constant_dim(d: DimSize) -> bool: ...
def is_dim(v: Any) -> bool: ...
def is_constant_shape(s: Shape) -> bool: ...
def definitely_equal_one_of_dim(d1: DimSize, dlist: Sequence[DimSize]) -> bool: ...
def definitely_equal_shape(s1: Shape, s2: Shape) -> bool:
    """Check that two shapes are guaranteed to be element-wise equal.

  In presence of dynamic shapes may return False even when the shapes may
  be equal at runtime.
  """
def divide_shape_sizes(s1: Shape, s2: Shape) -> DimSize:
    '''Returns an integer "i" s.t., i * size(s2) == size(s1).
  Raises InconclusiveDimensionOperation if there is no such integer.'''
def cancel_divide_tracers(num, denom): ...
def is_empty_shape(s: Shape) -> bool: ...
def dilate_dim(d: DimSize, dilation: DimSize) -> DimSize:
    """max(0, 1 + dilation * (d - 1)).

  Assumes dilation >= 1.
  """
def stride_dim(d: DimSize, window_size: DimSize, window_stride: DimSize) -> DimSize:
    """max(0, (d - window_size) // window_stride + 1)

  If d < window_size, returns 0.
  We assume window_size >= 1 and window_stride >= 1.
  """
def non_negative_dim(d: DimSize) -> DimSize:
    """max(d, 0)."""
def dimension_as_value(d: DimSize):
    """Turns a dimension size into a JAX array.
     This is the identity function for constant dimensions.

     Has the same abstract value as Python constants.
     """
def canonicalize_shape(shape: Shape, context: str = '') -> tuple[Any, ...]:
    """Canonicalizes and checks for errors in a user-provided shape value.

  Args:
    shape: a Python value that represents a shape.

  Returns:
    A tuple of canonical dimension values.
  """
def canonicalize_dim(d: DimSize, context: str = '') -> DimSize:
    """Canonicalizes and checks for errors in a user-provided shape dimension value.

  Args:
    f: a Python value that represents a dimension.

  Returns:
    A canonical dimension value.
  """

class SomeTracer: ...

def replace_tracer_for_error_message(obj): ...
def evaluate_shape(shape: Shape, dim_vars: Sequence[str], *dim_values: Array) -> Sequence[Array]:
    """Evaluates a shape possibly containing non-constants.

  Args:
    shape: the shape to evaluate.
    dim_vars: the dimension variables names that may appear in `shape`.
    dim_values: the dimension values corresponding to `dim_vars`.

  Returns:
     a tuple of JAX values corresponding to `shape`, of type
     `dim_value_dtype`.
  """
def dim_value_dtype():
    """The dtype to be used for dimension values."""
def dim_constant(ct: int): ...
def dim_value_aval() -> AbstractValue: ...

class NamedShape:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def rank(self): ...
    @property
    def positional_rank(self): ...
    @property
    def named_rank(self): ...
    @property
    def positional(self): ...
    @property
    def names(self): ...
    @property
    def named_sizes(self): ...
    @property
    def named_items(self): ...
    def __getitem__(self, idx): ...
    @property
    def total(self): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

def join_named_shapes(*named_shapes): ...
def as_named_shape(shape) -> NamedShape: ...

class CallPrimitive(Primitive):
    multiple_results: bool
    call_primitive: bool
    def bind(self, fun, *args, **params): ...
    def get_bind_params(self, params): ...

def call_bind_with_continuation(primitive: CallPrimitive, fun, *args, **params): ...
def process_env_traces_call(primitive: CallPrimitive, level: int, params_tuple: tuple, *args): ...
def apply_todos(todos, outs): ...
def call_impl(f: lu.WrappedFun, *args, **params): ...

call_p: CallPrimitive
call: Incomplete

class ClosedCallPrimitive(CallPrimitive):
    def get_bind_params(self, params): ...

closed_call_p: ClosedCallPrimitive
outfeed_primitives: set[Primitive]

def jaxpr_uses_outfeed(jaxpr: Jaxpr) -> bool:
    """Finds if there are outfeed primitives anywhere inside a Jaxpr."""
def primitive_uses_outfeed(prim: Primitive, params: dict) -> bool: ...

class MapPrimitive(Primitive):
    multiple_results: bool
    map_primitive: bool
    def bind(self, fun, *args, **params): ...
    def process(self, trace, fun, tracers, params): ...
    def post_process(self, trace, out_tracers, params): ...
    def get_bind_params(self, params): ...

def map_bind_with_continuation(primitive: MapPrimitive, fun, *args, out_axes_thunk, **params): ...
def map_bind(primitive: MapPrimitive, fun, *args, **params): ...
def process_env_traces_map(primitive: MapPrimitive, level: int, params_tuple: tuple, *args): ...
def mapped_aval(size: AxisSize, axis: int | None, aval: AbstractValue) -> AbstractValue: ...
def unmapped_aval(size: AxisSize, axis_name, axis: int | None, aval: AbstractValue) -> AbstractValue: ...
AvalMapHandlerPair = tuple[Callable, Callable]
aval_mapping_handlers: dict[type, AvalMapHandlerPair]

def extend_axis_env(axis_name: AxisName, size: int, tag: Any): ...
def extend_axis_env_nd(axes: Iterable[tuple[AxisName, int]], tag: Any = None): ...
def stash_axis_env() -> Generator[None, None, None]:
    """Promise that a function or with-suite does not depend implicitly on axis env"""

class _TempAxisName:
    id: Incomplete
    def __init__(self, obj) -> None: ...
    def __hash__(self): ...
    def __eq__(self, other): ...
    def __lt__(self, other): ...

def axis_frame(axis_name: AxisName, main_trace: MainTrace | None = None) -> AxisEnvFrame: ...
ParamDict = dict[str, Any]
AxisSubst = Callable[[AxisName], tuple[AxisName, ...]]

class NameGatheringSubst:
    axis_names: Incomplete
    def __init__(self) -> None: ...
    def __call__(self, axis_name): ...

def used_axis_names(primitive: Primitive, params: ParamDict) -> set[AxisName]: ...
def subst_axis_names(primitive: Primitive, params: ParamDict, subst: AxisSubst, traverse: bool = True) -> ParamDict: ...

class DuplicateAxisNameError(Exception):
    var: Incomplete
    eqn: Incomplete
    def __init__(self, var) -> None: ...

def subst_axis_names_var(v: Var, subst: AxisSubst, var_map: dict[Var, Var]) -> Var: ...
def subst_axis_names_eqn(eqn: JaxprEqn, subst: AxisSubst, var_map: dict[Var, Var]) -> JaxprEqn: ...
def do_subst_axis_names_jaxpr(jaxpr: Jaxpr | ClosedJaxpr, subst: AxisSubst): ...
def used_axis_names_jaxpr(jaxpr: Jaxpr | ClosedJaxpr): ...
def subst_axis_names_jaxpr(jaxpr: Jaxpr | ClosedJaxpr, subst: AxisSubst): ...
def replace_jaxpr_effects(jaxpr: ClosedJaxpr, effects: Effects): ...

axis_substitution_rules: dict[Primitive, Callable[[ParamDict, AxisSubst, bool], ParamDict]]

class AxisPrimitive(Primitive):
    def bind(self, *args, **params): ...

def typecheck(aval: AbstractValue, x) -> bool: ...
def typecompat(aval_ref: AbstractValue, aval: AbstractValue) -> bool:
    """Determine whether `aval` conforms to `aval_ref`.

  Ignores weak_type and named_shape, other than to check that an axis name isn't
  used with different sizes.
  """
def typematch(aval1: AbstractValue, aval2: AbstractValue) -> bool:
    """Determine whether `aval1` and `aval2` are equivalent.

  Ignores weak_type and named_shape, other than to check that an axis name isn't
  used with different sizes.
  """

class JaxprTypeError(TypeError): ...

custom_typechecks: dict[Primitive, Callable]

def check_jaxpr(jaxpr: Jaxpr):
    """Checks well-formedness of a jaxpr.

  Specifically, check that:
  - variables that are read are bound beforehand
  - variables are typed equally throughout a jaxpr
  - variable type annotations are compatible with their binding expression

  Raises `JaxprTypeError` if `jaxpr` is determined invalid. Returns `None`
  otherwise.
  """
def check_type(ctx_factory: Callable[[], tuple[JaxprPpContext, JaxprPpSettings]], env: set[Var], ty: AbstractValue) -> None: ...
def substitute_vars_in_output_ty(out_type: Sequence[AbstractValue], in_atoms: Sequence[Atom], out_binders: Sequence[Var]) -> list[AbstractValue]: ...
def check_eqn(prim, in_avals, params): ...

class JaxprPpSettings(NamedTuple):
    print_shapes: bool = ...
    source_info: bool = ...
    name_stack: bool = ...
    custom_pp_eqn_rules: bool = ...
    print_effects: bool = ...

class JaxprPpContext:
    var_ids: DefaultDict[Var, int]
    def __init__(self) -> None: ...

def pp_var(v: Var, context: JaxprPpContext) -> str: ...
def pp_aval(a: AbstractValue, context: JaxprPpContext) -> str: ...
def pp_vars(vs: Sequence[Any], context: JaxprPpContext, *, separator: str = '', print_shapes: bool = False) -> pp.Doc: ...
def pp_kv_pair(k: str, v: Any, context: JaxprPpContext, settings: JaxprPpSettings) -> pp.Doc: ...
def pp_kv_pairs(kv_pairs, context: JaxprPpContext, settings: JaxprPpSettings) -> pp.Doc: ...
def pp_eqn(eqn: JaxprEqn, context: JaxprPpContext, settings: JaxprPpSettings) -> pp.Doc: ...

CustomPpEqnRule: Incomplete
pp_eqn_rules: dict[Primitive, CustomPpEqnRule]

def pp_eqns(eqns, context: JaxprPpContext, settings: JaxprPpSettings) -> pp.Doc: ...
def str_eqn_compact(primitive_name: str, params: dict) -> str:
    """Compact equation to string conversion used in HLO metadata."""
def pp_jaxpr_skeleton(jaxpr, eqns_fn, context: JaxprPpContext, settings: JaxprPpSettings) -> pp.Doc: ...
def pp_jaxpr(jaxpr, context: JaxprPpContext, settings: JaxprPpSettings) -> pp.Doc: ...
def pp_jaxprs(jaxprs, context: JaxprPpContext, settings: JaxprPpSettings) -> pp.Doc: ...
def pp_jaxpr_eqn_range(jaxpr: Jaxpr, lo: int, hi: int, context: JaxprPpContext, settings: JaxprPpSettings) -> pp.Doc: ...
def pp_effect(effect: Effect, context: JaxprPpContext) -> pp.Doc: ...
def last_used(jaxpr: Jaxpr) -> dict[Var, JaxprEqn | None]:
    """Returns a mapping from every var in jaxpr to what equation uses it last."""
def clean_up_dead_vars(eqn: JaxprEqn, env: dict[Var, Any], last_used: dict[Var, JaxprEqn | None]):
    """Remove all eqn.invars from env if eqn is the last time they were used."""
