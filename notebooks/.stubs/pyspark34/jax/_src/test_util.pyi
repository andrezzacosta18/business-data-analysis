from _typeshed import Incomplete
from absl.testing import absltest, parameterized
from collections.abc import Generator, Iterable, Sequence
from jax import lax as lax
from jax._src import api as api, core as core, dispatch as dispatch, monitoring as monitoring, stages as stages, xla_bridge as xla_bridge
from jax._src.config import bool_env as bool_env, config as config, persistent_cache_min_compile_time_secs as persistent_cache_min_compile_time_secs, raise_persistent_cache_errors as raise_persistent_cache_errors
from jax._src.interpreters import mlir as mlir, pxla as pxla
from jax._src.numpy.util import promote_dtypes as promote_dtypes, promote_dtypes_inexact as promote_dtypes_inexact
from jax._src.public_test_util import check_close as check_close, check_grads as check_grads, check_jvp as check_jvp, check_vjp as check_vjp, default_gradient_tolerance as default_gradient_tolerance, default_tolerance as default_tolerance, tolerance as tolerance
from jax._src.util import unzip2 as unzip2
from jax.experimental.compilation_cache import compilation_cache as compilation_cache
from jax.tree_util import tree_all as tree_all, tree_flatten as tree_flatten, tree_map as tree_map, tree_unflatten as tree_unflatten
from typing import Any, Callable

TEST_WITH_PERSISTENT_COMPILATION_CACHE: Incomplete
kSanitizeNameRE: Incomplete

def sanitize_test_name(s: str) -> str: ...
def num_float_bits(dtype): ...
def to_default_dtype(arr):
    """Convert a value to an array with JAX's default dtype.

  This is generally used for type conversions of values returned by numpy functions,
  to make their dtypes take into account the state of the ``jax_enable_x64`` and
  ``jax_default_dtype_bits`` flags.
  """
def with_jax_dtype_defaults(func, use_defaults: bool = True):
    """Return a version of a function with outputs that match JAX's default dtypes.

  This is generally used to wrap numpy functions within tests, in order to make
  their default output dtypes match those of corresponding JAX functions, taking
  into account the state of the ``jax_enable_x64`` and ``jax_default_dtype_bits``
  flags.

  Args:
    use_defaults : whether to convert any given output to the default dtype. May be
      a single boolean, in which case it specifies the conversion for all outputs,
      or may be a a pytree with the same structure as the function output.
  """
def is_sequence(x): ...
def join_tolerance(tol1, tol2): ...
def check_eq(xs, ys, err_msg: str = '') -> None: ...
def capture_stdout() -> Generator[Callable[[], str], None, None]: ...
def count_device_put() -> Generator[Incomplete, None, Incomplete]: ...
def count_primitive_compiles() -> Generator[Incomplete, None, None]: ...
def count_pjit_cpp_cache_miss() -> Generator[Incomplete, None, Incomplete]: ...
def count_aot_jit_cpp_cache_miss() -> Generator[Incomplete, None, Incomplete]: ...
def count_jit_and_pmap_compiles() -> Generator[Incomplete, None, Incomplete]: ...
def assert_num_jit_and_pmap_compilations(times) -> Generator[None, None, None]: ...
def device_under_test(): ...
def supported_dtypes(): ...
def is_device_rocm(): ...
def is_device_cuda(): ...
def is_cloud_tpu(): ...
def is_device_tpu_v4(): ...
def test_device_matches(device_types: Iterable[str]) -> bool: ...
def skip_on_devices(*disabled_devices):
    """A decorator for test methods to skip the test on certain devices."""
def run_on_devices(*enabled_devices):
    """A decorator for test methods to run the test only on certain devices."""
def device_supports_buffer_donation():
    """A decorator for test methods to run the test only on devices that support
  buffer donation."""
def set_host_platform_device_count(nr_devices: int):
    """Returns a closure that undoes the operation."""
def skip_on_flag(flag_name, skip_value):
    """A decorator for test methods to skip the test when flags are set."""
def pytest_mark_if_available(marker: str):
    """A decorator for test classes or methods to pytest.mark if installed."""
def format_test_name_suffix(opname, shapes, dtypes): ...

class ScalarShape:
    def __len__(self) -> int: ...
    def __getitem__(self, i) -> None: ...

class _NumpyScalar(ScalarShape): ...
class _PythonScalar(ScalarShape): ...

NUMPY_SCALAR_SHAPE: Incomplete
PYTHON_SCALAR_SHAPE: Incomplete

def is_valid_shape(shape, dtype): ...
def dtype_str(dtype): ...
def format_shape_dtype_string(shape, dtype): ...
def rand_fullrange(rng, standardize_nans: bool = False):
    """Random numbers that span the full range of available bits."""
def rand_default(rng, scale: int = 3): ...
def rand_nonzero(rng): ...
def rand_positive(rng): ...
def rand_small(rng): ...
def rand_not_small(rng, offset: float = 10.0): ...
def rand_small_positive(rng): ...
def rand_uniform(rng, low: float = 0.0, high: float = 1.0): ...
def rand_some_equal(rng): ...
def rand_some_inf(rng):
    """Return a random sampler that produces infinities in floating types."""
def rand_some_nan(rng):
    """Return a random sampler that produces nans in floating types."""
def rand_some_inf_and_nan(rng):
    """Return a random sampler that produces infinities in floating types."""
def rand_some_zero(rng):
    """Return a random sampler that produces some zeros."""
def rand_int(rng, low: int = 0, high: Incomplete | None = None): ...
def rand_unique_int(rng, high: Incomplete | None = None): ...
def rand_bool(rng): ...
def check_raises(thunk, err_type, msg) -> None: ...
def check_raises_regexp(thunk, err_type, pattern) -> None: ...
def iter_eqns(jaxpr) -> Generator[Incomplete, Incomplete, None]: ...
def assert_dot_precision(expected_precision, fun, *args) -> None: ...
def assert_dot_preferred_element_type(expected, fun, *args, **kwargs) -> None: ...
def cases_from_gens(*gens) -> Generator[Incomplete, None, None]: ...
def named_cases_from_sampler(gen) -> Generator[Incomplete, None, Incomplete]: ...
def sample_product_testcases(*args, **kw):
    """Non-decorator form of sample_product."""
def sample_product(*args, **kw):
    """Decorator that samples from a cartesian product of test cases.

  Similar to absltest.parameterized.product(), except that it samples from the
  cartesian product rather than returning the whole thing.

  Arguments:
    *args: each positional argument is a list of dictionaries. The entries
      in a dictionary correspond to name=value argument pairs; one dictionary
      will be chosen for each test case. This allows multiple parameters to be
      correlated.
    **kw: each keyword argument is a list of values. One value will be chosen
      for each test case.
  """

class JaxTestLoader(absltest.TestLoader):
    def getTestCaseNames(self, testCaseClass): ...

def with_config(**kwds):
    """Test case decorator for subclasses of JaxTestCase"""
def promote_like_jnp(fun, inexact: bool = False):
    """Decorator that promotes the arguments of `fun` to `jnp.result_type(*args)`.

  jnp and np have different type promotion semantics; this decorator allows
  tests make an np reference implementation act more like an jnp
  implementation.
  """

class JaxTestCase(parameterized.TestCase):
    """Base class for JAX tests including numerical checks and boilerplate."""
    def setUp(self) -> None: ...
    def tearDown(self) -> None: ...
    @classmethod
    def setUpClass(cls): ...
    @classmethod
    def tearDownClass(cls) -> None: ...
    def rng(self): ...
    def assertArraysEqual(self, x, y, *, check_dtypes: bool = True, err_msg: str = '') -> None:
        """Assert that x and y arrays are exactly equal."""
    def assertArraysAllClose(self, x, y, *, check_dtypes: bool = True, atol: Incomplete | None = None, rtol: Incomplete | None = None, err_msg: str = '') -> None:
        """Assert that x and y are close (up to numerical tolerances)."""
    def assertDtypesMatch(self, x, y, *, canonicalize_dtypes: bool = True) -> None: ...
    def assertAllClose(self, x, y, *, check_dtypes: bool = True, atol: Incomplete | None = None, rtol: Incomplete | None = None, canonicalize_dtypes: bool = True, err_msg: str = '') -> None:
        """Assert that x and y, either arrays or nested tuples/lists, are close."""
    def assertMultiLineStrippedEqual(self, expected, what) -> None:
        """Asserts two strings are equal, after dedenting and stripping each line."""
    def assertNoWarnings(self) -> Generator[None, None, None]: ...

JIT_IMPLEMENTATION: Incomplete

class BufferDonationTestCase(JaxTestCase):
    assertDeleted: Incomplete
    assertNotDeleted: Incomplete

def ignore_warning(**kw) -> Generator[None, None, None]: ...
MeshSpec = list[tuple[str, int]]

def with_mesh(named_shape: MeshSpec) -> Generator[None, None, None]:
    """Test utility for setting up meshes given mesh data from `schedules`."""
def with_mesh_from_kwargs(f): ...
def with_and_without_mesh(f): ...

old_spmd_lowering_flag: Incomplete

def set_spmd_lowering_flag(val: bool): ...
def restore_spmd_lowering_flag() -> None: ...

old_spmd_manual_lowering_flag: Incomplete

def set_spmd_manual_lowering_flag(val: bool): ...
def restore_spmd_manual_lowering_flag() -> None: ...
def create_global_mesh(mesh_shape, axis_names): ...

class _cached_property:
    null: Incomplete
    def __init__(self, method) -> None: ...
    def __get__(self, obj, cls): ...

class _LazyDtypes:
    """A class that unifies lists of supported dtypes.

  These could be module-level constants, but device_under_test() is not always
  known at import time, so we need to define these lists lazily.
  """
    def supported(self, dtypes): ...
    def custom_floats(self): ...
    def floating(self): ...
    def all_floating(self): ...
    def integer(self): ...
    def all_integer(self): ...
    def unsigned(self): ...
    def all_unsigned(self): ...
    def complex(self): ...
    def boolean(self): ...
    def inexact(self): ...
    def all_inexact(self): ...
    def numeric(self): ...
    def all(self): ...

dtypes: Incomplete

def strict_promotion_if_dtypes_match(dtypes):
    """
  Context manager to enable strict promotion if all dtypes match,
  and enable standard dtype promotion otherwise.
  """
def numpy_version(): ...
def parameterized_filterable(*, kwargs: Sequence[dict[str, Any]], testcase_name: Callable[[dict[str, Any]], str] | None = None, one_containing: str | None = None):
    """
  Decorator for named parameterized tests, with filtering.

  Works like parameterized.named_parameters, except that it supports the
  `one_containing` option. This is useful to select only one of the tests,
  and to leave the test name unchanged (helps with specifying the desired test
  when debugging).

  Args:
    kwargs: Each entry is a set of kwargs to be passed to the test function.
    testcase_name: Optionally, a function to construct the testcase_name from
      one kwargs dict. If not given then kwarg may contain `testcase_name` and
      if not, the test case name is constructed as `str(kwarg)`.
      We sanitize the test names to work with -k test filters. See
      `sanitize_test_name`.
    one_containing: If given, then leave the test name unchanged, and use
      only one `kwargs` whose `testcase_name` includes `one_containing`.
  """
def register_event_duration_listener(callback) -> Generator[None, None, None]:
    """Manages registering/unregistering an event duration listener callback."""
def set_env(**kwargs) -> Generator[None, None, None]:
    '''Context manager to temporarily set/unset one or more environment variables.

  Example:

    >>> import os
    >>> os.environ[\'my_var\'] = \'original\'

    >>> with set_env(my_var=None, other_var=\'some_value\'):
    ...   print("my_var is set:", \'my_var\' in os.environ)
    ...   print("other_var =", os.environ[\'other_var\'])
    ...
    my_var is set: False
    other_var = some_value

    >>> os.environ[\'my_var\']
    \'original\'
    >>> \'other_var\' in os.environ
    False
  '''
def fwd_bwd_jaxprs(f, *example_args): ...
