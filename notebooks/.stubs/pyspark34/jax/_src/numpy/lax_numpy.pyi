import numpy as np
from _typeshed import Incomplete
from collections.abc import Sequence
from jax import errors as errors, jit as jit, lax as lax
from jax._src import api_util as api_util, core as core, dispatch as dispatch, dtypes as dtypes
from jax._src.array import ArrayImpl as ArrayImpl
from jax._src.core import ConcreteArray as ConcreteArray, ShapedArray as ShapedArray
from jax._src.lax.lax import PrecisionLike as PrecisionLike
from jax._src.lib import xla_client as xla_client
from jax._src.numpy import reductions as reductions, ufuncs as ufuncs, util as util
from jax._src.numpy.vectorize import vectorize as vectorize
from jax._src.typing import Array as Array, ArrayLike as ArrayLike, DType as DType, DTypeLike as DTypeLike, DimSize as DimSize, DuckTypedArray as DuckTypedArray, Shape as Shape
from jax._src.util import NumpyComplexWarning as NumpyComplexWarning, ceil_of_ratio as ceil_of_ratio, partition_list as partition_list, safe_zip as safe_zip, subvals as subvals, unzip2 as unzip2
from jax.tree_util import tree_flatten as tree_flatten, tree_leaves as tree_leaves, tree_map as tree_map
from typing import Any, Callable, Literal, NamedTuple, Protocol, TypeVar, overload

newaxis: Incomplete
T = TypeVar('T')

def canonicalize_shape(shape: Any, context: str = '') -> core.Shape: ...

pi: Incomplete
e: Incomplete
euler_gamma: Incomplete
inf: Incomplete
nan: Incomplete
get_printoptions = np.get_printoptions
printoptions = np.printoptions
set_printoptions = np.set_printoptions

def iscomplexobj(x: Any) -> bool: ...
shape = np.shape
ndim = np.ndim
size = np.size

class _ScalarMeta(type):
    dtype: np.dtype
    def __hash__(self) -> int: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __call__(self, x: Any) -> Array: ...
    def __instancecheck__(self, instance: Any) -> bool: ...

bool_: Incomplete
uint4: Incomplete
uint8: Incomplete
uint16: Incomplete
uint32: Incomplete
uint64: Incomplete
int4: Incomplete
int8: Incomplete
int16: Incomplete
int32: Incomplete
int64: Incomplete
float8_e4m3fn: Incomplete
float8_e4m3fnuz: Incomplete
float8_e5m2: Incomplete
float8_e5m2fnuz: Incomplete
float8_e4m3b11fnuz: Incomplete
bfloat16: Incomplete
float16: Incomplete
float32: Incomplete
single: Incomplete
float64: Incomplete
double: Incomplete
complex64: Incomplete
csingle: Incomplete
complex128: Incomplete
cdouble: Incomplete
int_: Incomplete
uint: Incomplete
float_: Any
complex_: Incomplete
generic = np.generic
number = np.number
inexact = np.inexact
complexfloating = np.complexfloating
floating = np.floating
integer = np.integer
signedinteger = np.signedinteger
unsignedinteger = np.unsignedinteger
flexible = np.flexible
character = np.character
object_ = np.object_
iinfo: Incomplete
finfo: Incomplete
dtype = np.dtype
can_cast: Incomplete
promote_types: Incomplete
ComplexWarning = NumpyComplexWarning
array_str = np.array_str
array_repr = np.array_repr
save = np.save
savez = np.savez

def load(*args: Any, **kwargs: Any) -> Array: ...
def fmin(x1: ArrayLike, x2: ArrayLike) -> Array: ...
def fmax(x1: ArrayLike, x2: ArrayLike) -> Array: ...
def issubdtype(arg1: DTypeLike, arg2: DTypeLike) -> bool: ...
def isscalar(element: Any) -> bool: ...
iterable = np.iterable

def result_type(*args: Any) -> DType: ...
def trapz(y: ArrayLike, x: ArrayLike | None = None, dx: ArrayLike = 1.0, axis: int = -1) -> Array: ...
def trunc(x: ArrayLike) -> Array: ...
def convolve(a: ArrayLike, v: ArrayLike, mode: str = 'full', *, precision: PrecisionLike = None, preferred_element_type: dtype | None = None) -> Array: ...
def correlate(a: ArrayLike, v: ArrayLike, mode: str = 'valid', *, precision: PrecisionLike = None, preferred_element_type: dtype | None = None) -> Array: ...
def histogram_bin_edges(a: ArrayLike, bins: ArrayLike = 10, range: None | Array | Sequence[ArrayLike] = None, weights: ArrayLike | None = None) -> Array: ...
def histogram(a: ArrayLike, bins: ArrayLike = 10, range: Sequence[ArrayLike] | None = None, weights: ArrayLike | None = None, density: bool | None = None) -> tuple[Array, Array]: ...
def histogram2d(x: ArrayLike, y: ArrayLike, bins: ArrayLike | list[ArrayLike] = 10, range: Sequence[None | Array | Sequence[ArrayLike]] | None = None, weights: ArrayLike | None = None, density: bool | None = None) -> tuple[Array, Array, Array]: ...
def histogramdd(sample: ArrayLike, bins: ArrayLike | list[ArrayLike] = 10, range: Sequence[None | Array | Sequence[ArrayLike]] | None = None, weights: ArrayLike | None = None, density: bool | None = None) -> tuple[Array, list[Array]]: ...
def transpose(a: ArrayLike, axes: Sequence[int] | None = None) -> Array: ...
def matrix_transpose(x: ArrayLike) -> Array:
    """Transposes the last two dimensions of x.

  Parameters
  ----------
  x : array_like
      Input array. Must have ``x.ndim >= 2``.

  Returns
  -------
  xT : Array
      Transposed array.
  """
def rot90(m: ArrayLike, k: int = 1, axes: tuple[int, int] = (0, 1)) -> Array: ...
def flip(m: ArrayLike, axis: int | Sequence[int] | None = None) -> Array: ...
def fliplr(m: ArrayLike) -> Array: ...
def flipud(m: ArrayLike) -> Array: ...
def iscomplex(x: ArrayLike) -> Array: ...
def isreal(x: ArrayLike) -> Array: ...
def angle(z: ArrayLike, deg: bool = False) -> Array: ...
def diff(a: ArrayLike, n: int = 1, axis: int = -1, prepend: ArrayLike | None = None, append: ArrayLike | None = None) -> Array: ...
def ediff1d(ary: ArrayLike, to_end: ArrayLike | None = None, to_begin: ArrayLike | None = None) -> Array: ...
def gradient(f: ArrayLike, *varargs: ArrayLike, axis: int | Sequence[int] | None = None, edge_order: int | None = None) -> Array | list[Array]: ...
def isrealobj(x: Any) -> bool: ...
def reshape(a: ArrayLike, newshape: DimSize | Shape, order: str = 'C') -> Array: ...
def ravel(a: ArrayLike, order: str = 'C') -> Array: ...
def ravel_multi_index(multi_index: Sequence[ArrayLike], dims: Sequence[int], mode: str = 'raise', order: str = 'C') -> Array: ...
def unravel_index(indices: ArrayLike, shape: Shape) -> tuple[Array, ...]: ...
def resize(a: ArrayLike, new_shape: Shape) -> Array: ...
def squeeze(a: ArrayLike, axis: int | Sequence[int] | None = None) -> Array: ...
def expand_dims(a: ArrayLike, axis: int | Sequence[int]) -> Array: ...
def swapaxes(a: ArrayLike, axis1: int, axis2: int) -> Array: ...
def moveaxis(a: ArrayLike, source: int | Sequence[int], destination: int | Sequence[int]) -> Array: ...
def isclose(a: ArrayLike, b: ArrayLike, rtol: ArrayLike = 1e-05, atol: ArrayLike = 1e-08, equal_nan: bool = False) -> Array: ...
def interp(x: ArrayLike, xp: ArrayLike, fp: ArrayLike, left: ArrayLike | str | None = None, right: ArrayLike | str | None = None, period: ArrayLike | None = None) -> Array: ...
@overload
def where(condition: ArrayLike, x: Literal[None] = None, y: Literal[None] = None, *, size: int | None = None, fill_value: None | ArrayLike | tuple[ArrayLike, ...] = None) -> tuple[Array, ...]: ...
@overload
def where(condition: ArrayLike, x: ArrayLike, y: ArrayLike, *, size: int | None = None, fill_value: None | ArrayLike | tuple[ArrayLike, ...] = None) -> Array: ...
@overload
def where(condition: ArrayLike, x: ArrayLike | None = None, y: ArrayLike | None = None, *, size: int | None = None, fill_value: None | ArrayLike | tuple[ArrayLike, ...] = None) -> Array | tuple[Array, ...]: ...
def select(condlist: Sequence[ArrayLike], choicelist: Sequence[ArrayLike], default: ArrayLike = 0) -> Array: ...
def bincount(x: ArrayLike, weights: ArrayLike | None = None, minlength: int = 0, *, length: int | None = None) -> Array: ...
@overload
def broadcast_shapes(*shapes: Sequence[int]) -> tuple[int, ...]: ...
@overload
def broadcast_shapes(*shapes: Sequence[int | core.Tracer]) -> tuple[int | core.Tracer, ...]: ...
def broadcast_arrays(*args: ArrayLike) -> list[Array]: ...
def broadcast_to(array: ArrayLike, shape: Shape) -> Array: ...
def split(ary: ArrayLike, indices_or_sections: int | Sequence[int] | ArrayLike, axis: int = 0) -> list[Array]: ...

vsplit: Incomplete
hsplit: Incomplete
dsplit: Incomplete

def array_split(ary: ArrayLike, indices_or_sections: int | Sequence[int] | ArrayLike, axis: int = 0) -> list[Array]: ...
def clip(a: ArrayLike, a_min: ArrayLike | None = None, a_max: ArrayLike | None = None, out: None = None) -> Array: ...
def round(a: ArrayLike, decimals: int = 0, out: None = None) -> Array: ...
around = round
round_ = round

def fix(x: ArrayLike, out: None = None) -> Array: ...
def nan_to_num(x: ArrayLike, copy: bool = True, nan: ArrayLike = 0.0, posinf: ArrayLike | None = None, neginf: ArrayLike | None = None) -> Array: ...
def allclose(a: ArrayLike, b: ArrayLike, rtol: ArrayLike = 1e-05, atol: ArrayLike = 1e-08, equal_nan: bool = False) -> Array: ...
def nonzero(a: ArrayLike, *, size: int | None = None, fill_value: None | ArrayLike | tuple[ArrayLike, ...] = None) -> tuple[Array, ...]: ...
def flatnonzero(a: ArrayLike, *, size: int | None = None, fill_value: None | ArrayLike | tuple[ArrayLike] = None) -> Array: ...
def unwrap(p: ArrayLike, discont: ArrayLike | None = None, axis: int = -1, period: ArrayLike = ...) -> Array: ...
PadValueLike = T | Sequence[T] | Sequence[Sequence[T]]
PadValue = tuple[tuple[T, T], ...]

class PadStatFunc(Protocol):
    def __call__(self, array: ArrayLike, *, axis: int | None = None, keepdims: bool = False) -> Array: ...

def pad(array: ArrayLike, pad_width: PadValueLike[int | Array | np.ndarray], mode: str | Callable[..., Any] = 'constant', **kwargs) -> Array: ...
def stack(arrays: np.ndarray | Array | Sequence[ArrayLike], axis: int = 0, out: None = None, dtype: DTypeLike | None = None) -> Array: ...
def tile(A: ArrayLike, reps: DimSize | Sequence[DimSize]) -> Array: ...
def concatenate(arrays: np.ndarray | Array | Sequence[ArrayLike], axis: int | None = 0, dtype: DTypeLike | None = None) -> Array: ...
def vstack(tup: np.ndarray | Array | Sequence[ArrayLike], dtype: DTypeLike | None = None) -> Array: ...
def hstack(tup: np.ndarray | Array | Sequence[ArrayLike], dtype: DTypeLike | None = None) -> Array: ...
def dstack(tup: np.ndarray | Array | Sequence[ArrayLike], dtype: DTypeLike | None = None) -> Array: ...
def column_stack(tup: np.ndarray | Array | Sequence[ArrayLike]) -> Array: ...
def choose(a: ArrayLike, choices: Sequence[ArrayLike], out: None = None, mode: str = 'raise') -> Array: ...
def block(arrays: ArrayLike | list[ArrayLike]) -> Array: ...
def atleast_1d(*arys: ArrayLike) -> Array | list[Array]: ...
def atleast_2d(*arys: ArrayLike) -> Array | list[Array]: ...
def atleast_3d(*arys: ArrayLike) -> Array | list[Array]: ...
def array(object: Any, dtype: DTypeLike | None = None, copy: bool = True, order: str | None = 'K', ndmin: int = 0) -> Array: ...
def asarray(a: Any, dtype: DTypeLike | None = None, order: str | None = None) -> Array: ...
def copy(a: ArrayLike, order: str | None = None) -> Array: ...
def zeros_like(a: ArrayLike | DuckTypedArray, dtype: DTypeLike | None = None, shape: Any = None) -> Array: ...
def ones_like(a: ArrayLike | DuckTypedArray, dtype: DTypeLike | None = None, shape: Any = None) -> Array: ...
def empty_like(prototype: ArrayLike | DuckTypedArray, dtype: DTypeLike | None = None, shape: Any = None) -> Array: ...
def full(shape: Any, fill_value: ArrayLike, dtype: DTypeLike | None = None) -> Array: ...
def full_like(a: ArrayLike | DuckTypedArray, fill_value: ArrayLike, dtype: DTypeLike | None = None, shape: Any = None) -> Array: ...
def zeros(shape: Any, dtype: DTypeLike | None = None) -> Array: ...
def ones(shape: Any, dtype: DTypeLike | None = None) -> Array: ...
def empty(shape: Any, dtype: DTypeLike | None = None) -> Array: ...
def array_equal(a1: ArrayLike, a2: ArrayLike, equal_nan: bool = False) -> Array: ...
def array_equiv(a1: ArrayLike, a2: ArrayLike) -> Array: ...
def frombuffer(buffer: bytes | Any, dtype: DTypeLike = ..., count: int = -1, offset: int = 0) -> Array: ...
def fromfile(*args, **kwargs) -> None:
    """Unimplemented JAX wrapper for jnp.fromfile.

  This function is left deliberately unimplemented because it may be non-pure and thus
  unsafe for use with JIT and other JAX transformations. Consider using
  ``jnp.asarray(np.fromfile(...))`` instead, although care should be taken if ``np.fromfile``
  is used within jax transformations because of its potential side-effect of consuming the
  file object; for more information see `Common Gotchas: Pure Functions
  <https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#pure-functions>`_.
  """
def fromiter(*args, **kwargs) -> None:
    """Unimplemented JAX wrapper for jnp.fromiter.

  This function is left deliberately unimplemented because it may be non-pure and thus
  unsafe for use with JIT and other JAX transformations. Consider using
  ``jnp.asarray(np.fromiter(...))`` instead, although care should be taken if ``np.fromiter``
  is used within jax transformations because of its potential side-effect of consuming the
  iterable object; for more information see `Common Gotchas: Pure Functions
  <https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#pure-functions>`_.
  """
def from_dlpack(x: Any) -> Array: ...
def fromfunction(function: Callable[..., Array], shape: Any, *, dtype: DTypeLike = ..., **kwargs) -> Array: ...
def fromstring(string: str, dtype: DTypeLike = ..., count: int = -1, *, sep: str) -> Array: ...
def eye(N: DimSize, M: DimSize | None = None, k: int = 0, dtype: DTypeLike | None = None) -> Array: ...
def identity(n: DimSize, dtype: DTypeLike | None = None) -> Array: ...
def arange(start: DimSize, stop: DimSize | None = None, step: DimSize | None = None, dtype: DTypeLike | None = None) -> Array: ...
@overload
def linspace(start: ArrayLike, stop: ArrayLike, num: int = 50, endpoint: bool = True, retstep: Literal[False] = False, dtype: DTypeLike | None = None, axis: int = 0) -> Array: ...
@overload
def linspace(start: ArrayLike, stop: ArrayLike, num: int, endpoint: bool, retstep: Literal[True], dtype: DTypeLike | None = None, axis: int = 0) -> tuple[Array, Array]: ...
@overload
def linspace(start: ArrayLike, stop: ArrayLike, num: int = 50, endpoint: bool = True, *, retstep: Literal[True], dtype: DTypeLike | None = None, axis: int = 0) -> tuple[Array, Array]: ...
@overload
def linspace(start: ArrayLike, stop: ArrayLike, num: int = 50, endpoint: bool = True, retstep: bool = False, dtype: DTypeLike | None = None, axis: int = 0) -> Array | tuple[Array, Array]: ...
def logspace(start: ArrayLike, stop: ArrayLike, num: int = 50, endpoint: bool = True, base: ArrayLike = 10.0, dtype: DTypeLike | None = None, axis: int = 0) -> Array: ...
def geomspace(start: ArrayLike, stop: ArrayLike, num: int = 50, endpoint: bool = True, dtype: DTypeLike | None = None, axis: int = 0) -> Array: ...
def meshgrid(*xi: ArrayLike, copy: bool = True, sparse: bool = False, indexing: str = 'xy') -> list[Array]: ...
def i0(x: ArrayLike) -> Array: ...
def ix_(*args: ArrayLike) -> tuple[Array, ...]: ...
@overload
def indices(dimensions: Sequence[int], dtype: DTypeLike = ..., sparse: Literal[False] = False) -> Array: ...
@overload
def indices(dimensions: Sequence[int], dtype: DTypeLike = ..., *, sparse: Literal[True]) -> tuple[Array, ...]: ...
@overload
def indices(dimensions: Sequence[int], dtype: DTypeLike = ..., sparse: bool = False) -> Array | tuple[Array, ...]: ...
def repeat(a: ArrayLike, repeats: ArrayLike, axis: int | None = None, *, total_repeat_length: int | None = None) -> Array: ...
def tri(N: int, M: int | None = None, k: int = 0, dtype: DTypeLike = None) -> Array: ...
def tril(m: ArrayLike, k: int = 0) -> Array: ...
def triu(m: ArrayLike, k: int = 0) -> Array: ...
def trace(a: ArrayLike, offset: int = 0, axis1: int = 0, axis2: int = 1, dtype: DTypeLike | None = None, out: None = None) -> Array: ...

mask_indices: Incomplete

def triu_indices(n: int, k: int = 0, m: int | None = None) -> tuple[Array, Array]: ...
def tril_indices(n: int, k: int = 0, m: int | None = None) -> tuple[Array, Array]: ...
def triu_indices_from(arr: ArrayLike, k: int = 0) -> tuple[Array, Array]: ...
def tril_indices_from(arr: ArrayLike, k: int = 0) -> tuple[Array, Array]: ...
def diag_indices(n: int, ndim: int = 2) -> tuple[Array, ...]: ...
def diag_indices_from(arr: ArrayLike) -> tuple[Array, ...]: ...
def diagonal(a: ArrayLike, offset: int = 0, axis1: int = 0, axis2: int = 1) -> Array: ...
def diag(v: ArrayLike, k: int = 0) -> Array: ...
def diagflat(v: ArrayLike, k: int = 0) -> Array: ...
def trim_zeros(filt, trim: str = 'fb'): ...
def trim_zeros_tol(filt, tol, trim: str = 'fb'): ...
def append(arr: ArrayLike, values: ArrayLike, axis: int | None = None) -> Array: ...
def delete(arr: ArrayLike, obj: ArrayLike | slice, axis: int | None = None, *, assume_unique_indices: bool = False) -> Array: ...
def insert(arr: ArrayLike, obj: ArrayLike | slice, values: ArrayLike, axis: int | None = None) -> Array: ...
def apply_along_axis(func1d: Callable, axis: int, arr: ArrayLike, *args, **kwargs) -> Array: ...
def apply_over_axes(func: Callable[[ArrayLike, int], Array], a: ArrayLike, axes: Sequence[int]) -> Array: ...
def dot(a: ArrayLike, b: ArrayLike, *, precision: PrecisionLike = None, preferred_element_type: DTypeLike | None = None) -> Array: ...
def matmul(a: ArrayLike, b: ArrayLike, *, precision: PrecisionLike = None, preferred_element_type: DTypeLike | None = None) -> Array:
    """Matrix Multiply."""
def vdot(a: ArrayLike, b: ArrayLike, *, precision: PrecisionLike = None, preferred_element_type: DTypeLike | None = None) -> Array: ...
def tensordot(a: ArrayLike, b: ArrayLike, axes: int | Sequence[int] | Sequence[Sequence[int]] = 2, *, precision: PrecisionLike = None, preferred_element_type: DTypeLike | None = None) -> Array: ...
@overload
def einsum(subscript: str, *operands: ArrayLike, out: None = None, optimize: str = 'optimal', precision: PrecisionLike = None, preferred_element_type: DTypeLike | None = None, _use_xeinsum: bool = False, _dot_general: Callable[..., Array] = ...) -> Array: ...
@overload
def einsum(arr: ArrayLike, axes: Sequence[Any], *operands: ArrayLike | Sequence[Any], out: None = None, optimize: str = 'optimal', precision: PrecisionLike = None, preferred_element_type: DTypeLike | None = None, _use_xeinsum: bool = False, _dot_general: Callable[..., Array] = ...) -> Array: ...
def einsum_path(subscripts, *operands, optimize: str = 'greedy'): ...
def inner(a: ArrayLike, b: ArrayLike, *, precision: PrecisionLike = None, preferred_element_type: DType | None = None) -> Array: ...
def outer(a: ArrayLike, b: ArrayLike, out: None = None) -> Array: ...
def cross(a, b, axisa: int = -1, axisb: int = -1, axisc: int = -1, axis: int | None = None): ...
def kron(a: ArrayLike, b: ArrayLike) -> Array: ...
def vander(x: ArrayLike, N: int | None = None, increasing: bool = False) -> Array: ...
def argwhere(a: ArrayLike, *, size: int | None = None, fill_value: ArrayLike | None = None) -> Array: ...
def argmax(a: ArrayLike, axis: int | None = None, out: None = None, keepdims: bool | None = None) -> Array: ...
def argmin(a: ArrayLike, axis: int | None = None, out: None = None, keepdims: bool | None = None) -> Array: ...
def nanargmax(a: ArrayLike, axis: int | None = None, out: None = None, keepdims: bool | None = None) -> Array: ...
def nanargmin(a: ArrayLike, axis: int | None = None, out: None = None, keepdims: bool | None = None) -> Array: ...
def sort(a: ArrayLike, axis: int | None = -1, kind: str = 'quicksort', order: None = None) -> Array: ...
def sort_complex(a: ArrayLike) -> Array: ...
def lexsort(keys: Array | np.ndarray | Sequence[ArrayLike], axis: int = -1) -> Array: ...
def argsort(a: ArrayLike, axis: int | None = -1, kind: str = 'stable', order: None = None) -> Array: ...
def partition(a: ArrayLike, kth: int, axis: int = -1) -> Array: ...
def argpartition(a: ArrayLike, kth: int, axis: int = -1) -> Array: ...
def roll(a: ArrayLike, shift: ArrayLike | Sequence[int], axis: int | Sequence[int] | None = None) -> Array: ...
def rollaxis(a: ArrayLike, axis: int, start: int = 0) -> Array: ...
def packbits(a: ArrayLike, axis: int | None = None, bitorder: str = 'big') -> Array: ...
def unpackbits(a: ArrayLike, axis: int | None = None, count: int | None = None, bitorder: str = 'big') -> Array: ...
def take(a: ArrayLike, indices: ArrayLike, axis: int | None = None, out: None = None, mode: str | None = None, unique_indices: bool = False, indices_are_sorted: bool = False, fill_value: ArrayLike | None = None) -> Array: ...

TAKE_ALONG_AXIS_DOC: str

def take_along_axis(arr: ArrayLike, indices: ArrayLike, axis: int | None, mode: str | lax.GatherScatterMode | None = None) -> Array: ...

class _Indexer(NamedTuple):
    slice_shape: Sequence[int]
    gather_slice_shape: Sequence[int]
    gather_indices: ArrayLike
    dnums: lax.GatherDimensionNumbers
    unique_indices: bool
    indices_are_sorted: bool
    reversed_y_dims: Sequence[int]
    newaxis_dims: Sequence[int]

def blackman(M: int) -> Array: ...
def bartlett(M: int) -> Array: ...
def hamming(M: int) -> Array: ...
def hanning(M: int) -> Array: ...
def kaiser(M: int, beta: ArrayLike) -> Array: ...
def gcd(x1: ArrayLike, x2: ArrayLike) -> Array: ...
def lcm(x1: ArrayLike, x2: ArrayLike) -> Array: ...
def extract(condition: ArrayLike, arr: ArrayLike) -> Array: ...
def compress(condition: ArrayLike, a: ArrayLike, axis: int | None = None, out: None = None) -> Array: ...
def cov(m: ArrayLike, y: ArrayLike | None = None, rowvar: bool = True, bias: bool = False, ddof: int | None = None, fweights: ArrayLike | None = None, aweights: ArrayLike | None = None) -> Array: ...
def corrcoef(x: ArrayLike, y: ArrayLike | None = None, rowvar: bool = True) -> Array: ...
def searchsorted(a: ArrayLike, v: ArrayLike, side: str = 'left', sorter: None = None, *, method: str = 'scan') -> Array: ...
def digitize(x: ArrayLike, bins: ArrayLike, right: bool = False) -> Array: ...
def piecewise(x: ArrayLike, condlist: Array | Sequence[ArrayLike], funclist: list[ArrayLike | Callable[..., Array]], *args, **kw) -> Array: ...
def place(arr: ArrayLike, mask: ArrayLike, vals: ArrayLike, *, inplace: bool = True) -> Array: ...
def put(a: ArrayLike, ind: ArrayLike, v: ArrayLike, mode: str | None = None, *, inplace: bool = True) -> Array: ...
