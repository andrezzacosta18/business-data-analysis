from _typeshed import Incomplete
from jax._src import core as core, dtypes as dtypes
from jax._src.api import jit as jit
from jax._src.custom_derivatives import custom_jvp as custom_jvp
from jax._src.lax import lax as lax
from jax._src.numpy.util import check_arraylike as check_arraylike, check_no_float0s as check_no_float0s, promote_args as promote_args, promote_args_inexact as promote_args_inexact, promote_args_numeric as promote_args_numeric, promote_dtypes_inexact as promote_dtypes_inexact, promote_dtypes_numeric as promote_dtypes_numeric, promote_shapes as promote_shapes
from jax._src.typing import Array as Array, ArrayLike as ArrayLike
from typing import Callable

UnOp = Callable[[ArrayLike], Array]
BinOp = Callable[[ArrayLike, ArrayLike], Array]
fabs: Incomplete
bitwise_not: Incomplete
invert: Incomplete
negative: Incomplete
positive: Incomplete
floor: Incomplete
ceil: Incomplete
exp: Incomplete
log: Incomplete
expm1: Incomplete
log1p: Incomplete
sin: Incomplete
cos: Incomplete
tan: Incomplete
arcsin: Incomplete
arccos: Incomplete
arctan: Incomplete
sinh: Incomplete
cosh: Incomplete
arcsinh: Incomplete
tanh: Incomplete
arctanh: Incomplete
sqrt: Incomplete
cbrt: Incomplete
add: Incomplete
bitwise_and: Incomplete
bitwise_or: Incomplete
bitwise_xor: Incomplete
left_shift: Incomplete
equal: Incomplete
multiply: Incomplete
not_equal: Incomplete
subtract: Incomplete
arctan2: Incomplete
minimum: Incomplete
maximum: Incomplete
float_power: Incomplete
nextafter: Incomplete
greater_equal: Incomplete
greater: Incomplete
less_equal: Incomplete
less: Incomplete
logical_and: BinOp
logical_not: UnOp
logical_or: BinOp
logical_xor: BinOp

def arccosh(x: ArrayLike) -> Array: ...
def right_shift(x1: ArrayLike, x2: ArrayLike) -> Array: ...
def absolute(x: ArrayLike) -> Array: ...

abs: Incomplete

def rint(x: ArrayLike) -> Array: ...
def sign(x: ArrayLike) -> Array: ...
def copysign(x1: ArrayLike, x2: ArrayLike) -> Array: ...
def true_divide(x1: ArrayLike, x2: ArrayLike) -> Array: ...
divide = true_divide

def floor_divide(x1: ArrayLike, x2: ArrayLike) -> Array: ...
def divmod(x1: ArrayLike, x2: ArrayLike) -> tuple[Array, Array]: ...
def power(x1: ArrayLike, x2: ArrayLike) -> Array: ...
def logaddexp(x1: ArrayLike, x2: ArrayLike) -> Array: ...
def logaddexp2(x1: ArrayLike, x2: ArrayLike) -> Array: ...
def log2(x: ArrayLike) -> Array: ...
def log10(x: ArrayLike) -> Array: ...
def exp2(x: ArrayLike) -> Array: ...
def signbit(x: ArrayLike) -> Array: ...
def ldexp(x1: ArrayLike, x2: ArrayLike) -> Array: ...
def frexp(x: ArrayLike) -> tuple[Array, Array]: ...
def remainder(x1: ArrayLike, x2: ArrayLike) -> Array: ...

mod: Incomplete

def fmod(x1: ArrayLike, x2: ArrayLike) -> Array: ...
def square(x: ArrayLike) -> Array: ...
def deg2rad(x: ArrayLike) -> Array: ...
def rad2deg(x: ArrayLike) -> Array: ...
degrees = rad2deg
radians = deg2rad

def conjugate(x: ArrayLike) -> Array: ...
conj = conjugate

def imag(val: ArrayLike) -> Array: ...
def real(val: ArrayLike) -> Array: ...
def modf(x: ArrayLike, out: Incomplete | None = None) -> tuple[Array, Array]: ...
def isfinite(x: ArrayLike) -> Array: ...
def isinf(x: ArrayLike) -> Array: ...

isposinf: UnOp
isneginf: UnOp

def isnan(x: ArrayLike) -> Array: ...
def heaviside(x1: ArrayLike, x2: ArrayLike) -> Array: ...
def hypot(x1: ArrayLike, x2: ArrayLike) -> Array: ...
def reciprocal(x: ArrayLike) -> Array: ...
def sinc(x: ArrayLike) -> Array: ...
