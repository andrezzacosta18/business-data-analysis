from jax import custom_jvp as custom_jvp, jit as jit, lax as lax
from jax._src.numpy import reductions as reductions, ufuncs as ufuncs
from jax._src.numpy.util import check_arraylike as check_arraylike, promote_dtypes_inexact as promote_dtypes_inexact
from jax._src.typing import Array as Array, ArrayLike as ArrayLike
from jax._src.util import canonicalize_axis as canonicalize_axis
from typing import Literal, overload

def cholesky(a: ArrayLike) -> Array: ...
@overload
def svd(a: ArrayLike, full_matrices: bool = True, *, compute_uv: Literal[True], hermitian: bool = False) -> tuple[Array, Array, Array]: ...
@overload
def svd(a: ArrayLike, full_matrices: bool, compute_uv: Literal[True], hermitian: bool = False) -> tuple[Array, Array, Array]: ...
@overload
def svd(a: ArrayLike, full_matrices: bool = True, *, compute_uv: Literal[False], hermitian: bool = False) -> Array: ...
@overload
def svd(a: ArrayLike, full_matrices: bool, compute_uv: Literal[False], hermitian: bool = False) -> Array: ...
@overload
def svd(a: ArrayLike, full_matrices: bool = True, compute_uv: bool = True, hermitian: bool = False) -> Array | tuple[Array, Array, Array]: ...
def matrix_power(a: ArrayLike, n: int) -> Array: ...
def matrix_rank(M: ArrayLike, tol: ArrayLike | None = None) -> Array: ...
def slogdet(a: ArrayLike, *, method: str | None = None) -> tuple[Array, Array]: ...
def det(a: ArrayLike) -> Array: ...
def eig(a: ArrayLike) -> tuple[Array, Array]: ...
def eigvals(a: ArrayLike) -> Array: ...
def eigh(a: ArrayLike, UPLO: str | None = None, symmetrize_input: bool = True) -> tuple[Array, Array]: ...
def eigvalsh(a: ArrayLike, UPLO: str | None = 'L') -> Array: ...
def pinv(a: ArrayLike, rcond: ArrayLike | None = None, hermitian: bool = False) -> Array: ...
def inv(a: ArrayLike) -> Array: ...
def norm(x: ArrayLike, ord: int | str | None = None, axis: None | tuple[int, ...] | int = None, keepdims: bool = False) -> Array: ...
@overload
def qr(a: ArrayLike, mode: Literal['r']) -> Array: ...
@overload
def qr(a: ArrayLike, mode: str = 'reduced') -> Array | tuple[Array, Array]: ...
def solve(a: ArrayLike, b: ArrayLike) -> Array: ...
def lstsq(a: ArrayLike, b: ArrayLike, rcond: float | None = None, *, numpy_resid: bool = False) -> tuple[Array, Array, Array, Array]: ...
