from jax import jit as jit, lax as lax
from jax._src import core as core, dtypes as dtypes
from jax._src.numpy import linalg as linalg
from jax._src.numpy.lax_numpy import arange as arange, argmin as argmin, array as array, asarray as asarray, atleast_1d as atleast_1d, concatenate as concatenate, convolve as convolve, diag as diag, dot as dot, finfo as finfo, full as full, ones as ones, outer as outer, roll as roll, trim_zeros as trim_zeros, trim_zeros_tol as trim_zeros_tol, vander as vander, zeros as zeros
from jax._src.numpy.reductions import all as all
from jax._src.numpy.ufuncs import maximum as maximum, sqrt as sqrt, true_divide as true_divide
from jax._src.numpy.util import check_arraylike as check_arraylike, promote_dtypes as promote_dtypes, promote_dtypes_inexact as promote_dtypes_inexact
from jax._src.typing import Array as Array, ArrayLike as ArrayLike

def roots(p: ArrayLike, *, strip_zeros: bool = True) -> Array: ...
def polyfit(x: Array, y: Array, deg: int, rcond: float | None = None, full: bool = False, w: Array | None = None, cov: bool = False) -> Array | tuple[Array, ...]: ...
def poly(seq_of_zeros: Array) -> Array: ...
def polyval(p: Array, x: Array, *, unroll: int = 16) -> Array: ...
def polyadd(a1: Array, a2: Array) -> Array: ...
def polyint(p: Array, m: int = 1, k: int | None = None) -> Array: ...
def polyder(p: Array, m: int = 1) -> Array: ...
def polymul(a1: ArrayLike, a2: ArrayLike, *, trim_leading_zeros: bool = False) -> Array: ...
def polydiv(u: ArrayLike, v: ArrayLike, *, trim_leading_zeros: bool = False) -> tuple[Array, Array]: ...
def polysub(a1: Array, a2: Array) -> Array: ...
