from jax import jit as jit, lax as lax
from jax._src import core as core, dtypes as dtypes
from jax._src.numpy.lax_numpy import append as append, arange as arange, array as array, asarray as asarray, concatenate as concatenate, diff as diff, empty as empty, full_like as full_like, lexsort as lexsort, moveaxis as moveaxis, nonzero as nonzero, ones as ones, ravel as ravel, sort as sort, where as where, zeros as zeros
from jax._src.numpy.reductions import any as any, cumsum as cumsum
from jax._src.numpy.ufuncs import isnan as isnan
from jax._src.numpy.util import check_arraylike as check_arraylike
from jax._src.typing import Array as Array, ArrayLike as ArrayLike

def in1d(ar1: ArrayLike, ar2: ArrayLike, assume_unique: bool = False, invert: bool = False) -> Array: ...
def setdiff1d(ar1: ArrayLike, ar2: ArrayLike, assume_unique: bool = False, *, size: int | None = None, fill_value: ArrayLike | None = None) -> Array: ...
def union1d(ar1: ArrayLike, ar2: ArrayLike, *, size: int | None = None, fill_value: ArrayLike | None = None) -> Array: ...
def setxor1d(ar1: ArrayLike, ar2: ArrayLike, assume_unique: bool = False) -> Array: ...
def intersect1d(ar1: ArrayLike, ar2: ArrayLike, assume_unique: bool = False, return_indices: bool = False) -> Array | tuple[Array, Array, Array]: ...
def isin(element: ArrayLike, test_elements: ArrayLike, assume_unique: bool = False, invert: bool = False) -> Array: ...

UNIQUE_SIZE_HINT: str

def unique(ar: ArrayLike, return_index: bool = False, return_inverse: bool = False, return_counts: bool = False, axis: int | None = None, *, size: int | None = None, fill_value: ArrayLike | None = None): ...
