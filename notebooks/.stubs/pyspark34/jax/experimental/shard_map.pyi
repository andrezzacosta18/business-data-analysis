from _typeshed import Incomplete
from collections.abc import Hashable, Sequence
from jax._src import ad_util as ad_util, array as array, callback as callback, core as core, custom_derivatives as custom_derivatives, debugging as debugging, dispatch as dispatch, dtypes as dtypes, linear_util as lu, ops as ops, pjit as pjit, prng as prng, sharding_impls as sharding_impls, source_info_util as source_info_util, traceback_util as traceback_util, util as util
from jax._src.core import Tracer as Tracer
from jax._src.interpreters import batching as batching, mlir as mlir, pxla as pxla
from jax._src.lax import control_flow as control_flow, fft as fft, lax as lax, linalg as linalg, slicing as slicing, windowed_reductions as windowed_reductions
from jax._src.tree_util import KeyPath as KeyPath, PyTreeDef as PyTreeDef, broadcast_prefix as broadcast_prefix, generate_key_paths as generate_key_paths, prefix_errors as prefix_errors
from jax._src.util import HashableFunction as HashableFunction, HashablePartial as HashablePartial, as_hashable_function as as_hashable_function, memoize as memoize, merge_lists as merge_lists, partition_list as partition_list, split_list as split_list, unzip2 as unzip2, unzip3 as unzip3
from jax.api_util import flatten_fun_nokwargs as flatten_fun_nokwargs, shaped_abstractify as shaped_abstractify
from jax.experimental.multihost_utils import global_array_to_host_local_array as global_array_to_host_local_array, host_local_array_to_global_array as host_local_array_to_global_array
from jax.interpreters import ad as ad
from jax.sharding import Mesh as Mesh, NamedSharding as NamedSharding, PartitionSpec as PartitionSpec
from jax.tree_util import keystr as keystr, tree_flatten as tree_flatten, tree_leaves as tree_leaves, tree_map as tree_map, tree_structure as tree_structure, tree_unflatten as tree_unflatten
from typing import Any, Callable, TypeVar

P = PartitionSpec
map: Incomplete
unsafe_map: Incomplete
zip: Incomplete
unsafe_zip: Incomplete
Specs = Any
AxisName = Hashable

def shard_map(f: Callable, mesh: Mesh, in_specs: Specs, out_specs: Specs, check_rep: bool = True, auto: frozenset[AxisName] = ...): ...
AxisNames = dict[int, tuple[AxisName, ...]]
SpecErrorType: Incomplete

class NoFail: ...

no_fail: Incomplete
T = TypeVar('T')
JaxType = Any
MaybeTracer = JaxType | Tracer

class ShardMapPrimitive(core.Primitive):
    multiple_results: bool
    def bind(self, fun: lu.WrappedFun, *args: MaybeTracer, mesh: Mesh, in_names: tuple[AxisNames, ...], out_names_thunk: Callable[[], tuple[AxisNames, ...]], check_rep: bool, rewrite: bool, auto: frozenset[AxisName]) -> Sequence[MaybeTracer]: ...
    def get_bind_params(self, params): ...

shard_map_p: Incomplete

def process_env_traces(level: int, mesh, in_names, out_names_thunk, check_rep, rewrite, auto, *args: Any): ...
Val = Any

class _SpecError(Exception): ...
class _RepError(Exception): ...

class ShardMapTrace(core.Trace):
    mesh: Mesh
    check: bool
    def __init__(self, *args, mesh, check) -> None: ...
    def pure(self, val): ...
    def sublift(self, tracer): ...
    def process_primitive(self, prim, tracers, params): ...
    def process_call(self, call_primitive, fun, tracers, params) -> None: ...
    def process_map(self, map_primitive, fun, tracers, params) -> None: ...
    def process_custom_jvp_call(self, prim, fun, jvp, tracers, *, symbolic_zeros) -> None: ...
    def post_process_custom_jvp_call(self, out_tracers, _) -> None: ...
    def process_custom_vjp_call(self, prim, fun, fwd, bwd, tracers, out_trees, symbolic_zeros) -> None: ...
    def post_process_custom_vjp_call(self, out_tracers, _) -> None: ...
    def process_axis_index(self, frame) -> None: ...

class ShardMapTracer(core.Tracer):
    rep: set[AxisName]
    val: JaxType
    def __init__(self, trace, rep, val) -> None: ...
    @property
    def aval(self): ...
    def full_lower(self) -> ShardMapTracer: ...

eager_rules: dict[core.Primitive, Callable]
psum2_p: Incomplete

def pbroadcast(x, axis_name): ...

pbroadcast_p: Incomplete
register_rewrite: Incomplete
register_standard_rewrite: Incomplete
register_norewrite: Incomplete
register_check: Incomplete
register_standard_check: Incomplete

def register_standard_collective(prim) -> None: ...
def pmap(f, axis_name: Incomplete | None = None, *, in_axes: int = 0, out_axes: int = 0, static_broadcasted_argnums=(), devices: Incomplete | None = None, backend: Incomplete | None = None, axis_size: Incomplete | None = None, donate_argnums=(), global_arg_shapes: Incomplete | None = None): ...

class RewriteTracer(core.Tracer):
    rep: set[AxisName]
    val: Val
    def __init__(self, trace, rep, val) -> None: ...
    @property
    def aval(self) -> core.AbstractValue: ...
    def full_lower(self) -> RewriteTracer: ...

class RewriteTrace(core.Trace):
    mesh: Mesh
    dyna: int
    def __init__(self, *args, mesh, dyna) -> None: ...
    def pure(self, val) -> RewriteTracer: ...
    def lift(self, tracer: core.Tracer) -> RewriteTracer: ...
    def sublift(self, tracer: core.Tracer) -> RewriteTracer: ...
    def process_primitive(self, prim, in_tracers, params): ...
    def process_call(self, call_primitive, f, in_tracers, params): ...
    def post_process_call(self, call_primitive, out_tracers, params) -> None: ...
    def process_custom_jvp_call(self, prim, fun, jvp, tracers, *, symbolic_zeros): ...
    def post_process_custom_jvp_call(self, out_tracers, jvp_was_run) -> None: ...
    def process_custom_vjp_call(self, prim, fun, fwd, bwd, tracers, out_trees, symbolic_zeros): ...
    def post_process_custom_vjp_call(self, out_tracers, _) -> None: ...
