from _typeshed import Incomplete
from collections.abc import Generator

class _NormalizerMeta(type):
    def __new__(cls, name, bases, dct): ...

class Normalizer(metaclass=_NormalizerMeta):
    grammar: Incomplete
    issues: Incomplete
    def __init__(self, grammar, config) -> None: ...
    def walk(self, node): ...
    def visit(self, node): ...
    def visit_node(self, node) -> Generator[None, None, None]: ...
    def visit_leaf(self, leaf): ...
    def initialize(self, node) -> None: ...
    def finalize(self) -> None: ...
    def add_issue(self, node, code, message): ...
    @classmethod
    def register_rule(cls, *, value: Incomplete | None = None, values=(), type: Incomplete | None = None, types=()):
        """
        Use it as a class decorator::

            normalizer = Normalizer('grammar', 'config')
            @normalizer.register_rule(value='foo')
            class MyRule(Rule):
                error_code = 42
        """

class NormalizerConfig:
    normalizer_class = Normalizer
    def create_normalizer(self, grammar): ...

class Issue:
    code: Incomplete
    message: Incomplete
    start_pos: Incomplete
    end_pos: Incomplete
    def __init__(self, node, code, message) -> None: ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __hash__(self): ...

class Rule:
    code: int
    message: str
    def __init__(self, normalizer) -> None: ...
    def is_issue(self, node) -> None: ...
    def get_node(self, node): ...
    def add_issue(self, node, code: Incomplete | None = None, message: Incomplete | None = None) -> None: ...
    def feed_node(self, node) -> None: ...

class RefactoringNormalizer(Normalizer):
    def __init__(self, node_to_str_map) -> None: ...
    def visit(self, node): ...
    def visit_leaf(self, leaf): ...
