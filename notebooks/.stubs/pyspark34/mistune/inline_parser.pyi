from .core import InlineState as InlineState, Parser as Parser
from .helpers import HTML_ATTRIBUTES as HTML_ATTRIBUTES, HTML_TAGNAME as HTML_TAGNAME, PREVENT_BACKSLASH as PREVENT_BACKSLASH, PUNCTUATION as PUNCTUATION, parse_link as parse_link, parse_link_label as parse_link_label, parse_link_text as parse_link_text, unescape_char as unescape_char
from .util import escape as escape, escape_url as escape_url, unikey as unikey
from _typeshed import Incomplete
from typing import Any, Dict, List, Match

PAREN_END_RE: Incomplete
AUTO_EMAIL: str
INLINE_HTML: Incomplete
EMPHASIS_END_RE: Incomplete

class InlineParser(Parser):
    sc_flag: int
    state_cls = InlineState
    STD_LINEBREAK: str
    HARD_LINEBREAK: str
    SPECIFICATION: Incomplete
    DEFAULT_RULES: Incomplete
    hard_wrap: Incomplete
    def __init__(self, hard_wrap: bool = False) -> None: ...
    def parse_escape(self, m: Match, state: InlineState) -> int: ...
    def parse_link(self, m: Match, state: InlineState) -> int | None: ...
    def parse_auto_link(self, m: Match, state: InlineState) -> int: ...
    def parse_auto_email(self, m: Match, state: InlineState) -> int: ...
    def parse_emphasis(self, m: Match, state: InlineState) -> int: ...
    def parse_codespan(self, m: Match, state: InlineState) -> int: ...
    def parse_linebreak(self, m: Match, state: InlineState) -> int: ...
    def parse_softbreak(self, m: Match, state: InlineState) -> int: ...
    def parse_inline_html(self, m: Match, state: InlineState) -> int: ...
    def process_text(self, text: str, state: InlineState): ...
    def parse(self, state: InlineState) -> List[Dict[str, Any]]: ...
    def precedence_scan(self, m: Match, state: InlineState, end_pos: int, rules: Incomplete | None = None): ...
    def render(self, state: InlineState): ...
    def __call__(self, s, env): ...
