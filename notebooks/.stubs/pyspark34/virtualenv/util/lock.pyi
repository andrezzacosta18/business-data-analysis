from _typeshed import Incomplete
from abc import ABCMeta, abstractmethod
from collections.abc import Generator
from filelock import FileLock, Timeout as Timeout

__all__ = ['NoOpFileLock', 'ReentrantFileLock', 'Timeout']

class _CountedFileLock(FileLock):
    count: int
    thread_safe: Incomplete
    def __init__(self, lock_file) -> None: ...
    def acquire(self, timeout: Incomplete | None = None, poll_interval: float = 0.05) -> None: ...
    def release(self, force: bool = False) -> None: ...

class PathLockBase(metaclass=ABCMeta):
    path: Incomplete
    def __init__(self, folder) -> None: ...
    def __div__(self, other): ...
    def __truediv__(self, other): ...
    @abstractmethod
    def __enter__(self): ...
    @abstractmethod
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None): ...
    @abstractmethod
    def lock_for_key(self, name, no_block: bool = False): ...
    @abstractmethod
    def non_reentrant_lock_for_key(self, name): ...

class ReentrantFileLock(PathLockBase):
    def __init__(self, folder) -> None: ...
    def __del__(self) -> None: ...
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None) -> None: ...
    def lock_for_key(self, name, no_block: bool = False) -> Generator[None, None, None]: ...
    def non_reentrant_lock_for_key(self, name) -> Generator[None, None, None]: ...

class NoOpFileLock(PathLockBase):
    def __enter__(self) -> None: ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None) -> None: ...
    def lock_for_key(self, name, no_block: bool = False) -> Generator[None, None, None]: ...
    def non_reentrant_lock_for_key(self, name) -> Generator[None, None, None]: ...
