import io
import os
import typing as t
from _typeshed import Incomplete

CYGWIN: Incomplete
WIN: Incomplete
auto_wrap_for_ansi: t.Callable[[t.TextIO], t.TextIO] | None

def is_ascii_encoding(encoding: str) -> bool:
    """Checks if a given encoding is ascii."""
def get_best_encoding(stream: t.IO[t.Any]) -> str:
    """Returns the default stream encoding if not found."""

class _NonClosingTextIOWrapper(io.TextIOWrapper):
    def __init__(self, stream: t.BinaryIO, encoding: str | None, errors: str | None, force_readable: bool = False, force_writable: bool = False, **extra: t.Any) -> None: ...
    def __del__(self) -> None: ...
    def isatty(self) -> bool: ...

class _FixupStream:
    """The new io interface needs more from streams than streams
    traditionally implement.  As such, this fix-up code is necessary in
    some circumstances.

    The forcing of readable and writable flags are there because some tools
    put badly patched objects on sys (one such offender are certain version
    of jupyter notebook).
    """
    def __init__(self, stream: t.BinaryIO, force_readable: bool = False, force_writable: bool = False) -> None: ...
    def __getattr__(self, name: str) -> t.Any: ...
    def read1(self, size: int) -> bytes: ...
    def readable(self) -> bool: ...
    def writable(self) -> bool: ...
    def seekable(self) -> bool: ...

def get_binary_stdin() -> t.BinaryIO: ...
def get_binary_stdout() -> t.BinaryIO: ...
def get_binary_stderr() -> t.BinaryIO: ...
def get_text_stdin(encoding: str | None = None, errors: str | None = None) -> t.TextIO: ...
def get_text_stdout(encoding: str | None = None, errors: str | None = None) -> t.TextIO: ...
def get_text_stderr(encoding: str | None = None, errors: str | None = None) -> t.TextIO: ...
def open_stream(filename: str | os.PathLike[str], mode: str = 'r', encoding: str | None = None, errors: str | None = 'strict', atomic: bool = False) -> t.Tuple[t.IO[t.Any], bool]: ...

class _AtomicFile:
    closed: bool
    def __init__(self, f: t.IO[t.Any], tmp_filename: str, real_filename: str) -> None: ...
    @property
    def name(self) -> str: ...
    def close(self, delete: bool = False) -> None: ...
    def __getattr__(self, name: str) -> t.Any: ...
    def __enter__(self) -> _AtomicFile: ...
    def __exit__(self, exc_type: t.Type[BaseException] | None, *_: t.Any) -> None: ...

def strip_ansi(value: str) -> str: ...
def should_strip_ansi(stream: t.IO[t.Any] | None = None, color: bool | None = None) -> bool: ...
def term_len(x: str) -> int: ...
def isatty(stream: t.IO[t.Any]) -> bool: ...

binary_streams: t.Mapping[str, t.Callable[[], t.BinaryIO]]
text_streams: t.Mapping[str, t.Callable[[str | None, str | None], t.TextIO]]
