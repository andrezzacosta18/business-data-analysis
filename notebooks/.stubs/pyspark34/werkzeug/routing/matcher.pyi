import typing as t
from .converters import ValidationError as ValidationError
from .exceptions import NoMatch as NoMatch, RequestAliasRedirect as RequestAliasRedirect, RequestPath as RequestPath
from .rules import Rule as Rule, RulePart as RulePart
from _typeshed import Incomplete
from dataclasses import dataclass

class SlashRequired(Exception): ...

@dataclass
class State:
    """A representation of a rule state.

    This includes the *rules* that correspond to the state and the
    possible *static* and *dynamic* transitions to the next state.
    """
    dynamic: list[tuple[RulePart, State]] = ...
    rules: list[Rule] = ...
    static: dict[str, State] = ...
    def __init__(self, dynamic, rules, static) -> None: ...

class StateMachineMatcher:
    merge_slashes: Incomplete
    def __init__(self, merge_slashes: bool) -> None: ...
    def add(self, rule: Rule) -> None: ...
    def update(self) -> None: ...
    def match(self, domain: str, path: str, method: str, websocket: bool) -> tuple[Rule, t.MutableMapping[str, t.Any]]: ...
