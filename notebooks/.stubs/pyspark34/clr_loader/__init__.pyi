from .types import Assembly as Assembly, Runtime as Runtime, RuntimeInfo as RuntimeInfo
from .util import StrOrPath
from .util.find import find_dotnet_root as find_dotnet_root, find_libmono as find_libmono, find_runtimes as find_runtimes
from .util.runtime_spec import DotnetCoreRuntimeSpec as DotnetCoreRuntimeSpec
from typing import Dict, Sequence

__all__ = ['get_mono', 'get_netfx', 'get_coreclr', 'find_dotnet_root', 'find_libmono', 'find_runtimes', 'Runtime', 'Assembly', 'RuntimeInfo', 'DotnetCoreRuntimeSpec']

def get_mono(*, config_file: StrOrPath | None = None, global_config_file: StrOrPath | None = None, libmono: StrOrPath | None = None, sgen: bool = True, debug: bool = False, jit_options: Sequence[str] | None = None, assembly_dir: str | None = None, config_dir: str | None = None, set_signal_chaining: bool = False) -> Runtime:
    '''Get a Mono runtime instance

    :param config_file:
        Path to the domain configuration file
    :param global_config_file:
        Path to the global configuration file to load (defaults to, e.g.,
        ``/etc/mono/config``)
    :param libmono:
        Path to the Mono runtime dll/so/dylib. If this is not specified, we try
        to discover a globally installed instance using :py:func:`find_libmono`
    :param sgen:
        If ``libmono`` is not specified, this is passed to
        :py:func:`find_libmono`
    :param debug:
        Whether to initialise Mono debugging
    :param jit_options:
        "Command line options" passed to Mono\'s ``mono_jit_parse_options``
    :param assembly_dir:
        The base directory for assemblies, passed to ``mono_set_dirs``
    :param config_dir:
        The base directory for configuration files, passed to ``mono_set_dirs``
    :param set_signal_chaining:
        Whether to enable signal chaining, passed to ``mono_set_signal_chaining``.
        If it is enabled, the runtime saves the original signal handlers before
        installing its own, and calls the original ones in the following cases:
            - SIGSEGV/SIGABRT while executing native code
            - SIGPROF
            - SIGFPE
            - SIGQUIT
            - SIGUSR2
        This currently only works on POSIX platforms
    '''
def get_coreclr(*, runtime_config: StrOrPath | None = None, dotnet_root: StrOrPath | None = None, properties: Dict[str, str] | None = None, runtime_spec: DotnetCoreRuntimeSpec | None = None) -> Runtime:
    """Get a CoreCLR (.NET Core) runtime instance

    The returned ``DotnetCoreRuntime`` also acts as a mapping of the config
    properties. They can be retrieved using the index operator and can be
    written until the runtime is initialized. The runtime is initialized when
    the first function object is retrieved.

    :param runtime_config:
        Pass to a ``runtimeconfig.json`` as generated by
        ``dotnet publish``. If this parameter is not given, a temporary runtime
        config will be generated.
    :param dotnet_root:
        The root directory of the .NET Core installation. If this is not
        specified, we try to discover it using :py:func:`find_dotnet_root`.
    :param properties:
        Additional runtime properties. These can also be passed using the
        ``configProperties`` section in the runtime config.
    :param runtime_spec:
        If the ``runtime_config`` is not specified, the concrete runtime to use
        can be controlled by passing this parameter. Possible values can be
        retrieved using :py:func:`find_runtimes`."""
def get_netfx(*, domain: str | None = None, config_file: StrOrPath | None = None) -> Runtime:
    """Get a .NET Framework runtime instance

    :param domain:
        Name of the domain to create. If no value is passed, assemblies will be
        loaded into the root domain.
    :param config_file:
        Configuration file to use to initialize the ``AppDomain``. This will
        only be used for non-root-domains as we can not control the
        configuration of the implicitly loaded root domain.
    """
