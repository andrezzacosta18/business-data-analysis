import abc
import ast
from _typeshed import Incomplete
from collections.abc import Generator
from pasta.base import ast_constants as ast_constants, ast_utils as ast_utils, token_generator as token_generator

def expression(f):
    """Decorates a function where the node is an expression."""
def fstring_expression(f):
    """Decorates a function where the node is a FormattedValue in an fstring."""
def space_around(f):
    """Decorates a function where the node has whitespace prefix and suffix."""
def space_left(f):
    """Decorates a function where the node has whitespace prefix."""
def statement(f):
    """Decorates a function where the node is a statement."""
def module(f):
    """Special decorator for the module node."""
def block_statement(f):
    """Decorates a function where the node is a statement with children."""

class BaseVisitor(ast.NodeVisitor, metaclass=abc.ABCMeta):
    """Walks a syntax tree in the order it appears in code.

  This class has a dual-purpose. It is implemented (in this file) for annotating
  an AST with formatting information needed to reconstruct the source code, but
  it also is implemented in pasta.base.codegen to reconstruct the source code.

  Each visit method in this class specifies the order in which both child nodes
  and syntax tokens appear, plus where to account for whitespace, commas,
  parentheses, etc.
  """
    __metaclass__ = abc.ABCMeta
    def __init__(self) -> None: ...
    def visit(self, node) -> None: ...
    def prefix(self, node, default: str = ''):
        """Account for some amount of whitespace as the prefix to a node."""
    def suffix(self, node, max_lines: Incomplete | None = None, semicolon: bool = False, comment: bool = False, default: str = ''):
        """Account for some amount of whitespace as the suffix to a node."""
    def indented(self, node, children_attr) -> Generator[Incomplete, None, None]: ...
    def set_default_indent_diff(self, indent) -> None: ...
    def scope(self, node, attr: Incomplete | None = None, trailing_comma: bool = False, default_parens: bool = False) -> Generator[None, None, None]:
        """Context manager to handle a parenthesized scope.

    Arguments:
      node: (ast.AST) Node to store the scope prefix and suffix on.
      attr: (string, optional) Attribute of the node contained in the scope, if
        any. For example, as `None`, the scope would wrap the entire node, but
        as 'bases', the scope might wrap only the bases of a class.
      trailing_comma: (boolean) If True, allow a trailing comma at the end.
      default_parens: (boolean) If True and no formatting information is
        present, the scope would be assumed to be parenthesized.
    """
    def token(self, token_val) -> None:
        """Account for a specific token."""
    def attr(self, node, attr_name, attr_vals, deps: Incomplete | None = None, default: Incomplete | None = None) -> None:
        """Handles an attribute on the given node."""
    def ws(self, max_lines: Incomplete | None = None, semicolon: bool = False, comment: bool = True):
        """Account for some amount of whitespace.

    Arguments:
      max_lines: (int) Maximum number of newlines to consider.
      semicolon: (boolean) If True, parse up to the next semicolon (if present).
      comment: (boolean) If True, look for a trailing comment even when not in
        a parenthesized scope.
    """
    def dots(self, num_dots):
        """Account for a number of dots."""
    def ws_oneline(self):
        """Account for up to one line of whitespace."""
    def optional_token(self, node, attr_name, token_val, default: bool = False) -> None:
        """Account for a suffix that may or may not occur."""
    def one_of_symbols(self, *symbols):
        """Account for one of the given symbols."""
    def visit_Module(self, node) -> None: ...
    def visit_If(self, node) -> None: ...
    @abc.abstractmethod
    def check_is_elif(self, node):
        """Return True if the node continues a previous `if` statement as `elif`.

    In python 2.x, `elif` statments get parsed as If nodes. E.g, the following
    two syntax forms are indistinguishable in the ast in python 2.

    if a:
      do_something()
    elif b:
      do_something_else()

    if a:
      do_something()
    else:
      if b:
        do_something_else()

    This method should return True for the 'if b' node if it has the first form.
    """
    def visit_While(self, node) -> None: ...
    def visit_For(self, node) -> None: ...
    def visit_AsyncFor(self, node): ...
    def visit_With(self, node): ...
    def visit_AsyncWith(self, node): ...
    @abc.abstractmethod
    def check_is_continued_try(self, node): ...
    @abc.abstractmethod
    def check_is_continued_with(self, node):
        """Return True if the node continues a previous `with` statement.

    In python 2.x, `with` statments with many context expressions get parsed as
    a tree of With nodes. E.g, the following two syntax forms are
    indistinguishable in the ast in python 2.

    with a, b, c:
      do_something()

    with a:
      with b:
        with c:
          do_something()

    This method should return True for the `with b` and `with c` nodes.
    """
    def visit_With_3(self, node) -> None: ...
    def visit_withitem(self, node) -> None: ...
    def visit_ClassDef(self, node) -> None: ...
    def visit_FunctionDef(self, node) -> None: ...
    def visit_AsyncFunctionDef(self, node): ...
    def visit_TryFinally(self, node) -> None: ...
    def visit_TryExcept(self, node) -> None: ...
    def visit_Try(self, node) -> None: ...
    def visit_ExceptHandler(self, node) -> None: ...
    def visit_Raise(self, node): ...
    def visit_Raise_3(self, node) -> None: ...
    def visit_Assert(self, node) -> None: ...
    def visit_Assign(self, node) -> None: ...
    def visit_AugAssign(self, node) -> None: ...
    def visit_AnnAssign(self, node) -> None: ...
    def visit_Await(self, node) -> None: ...
    def visit_Break(self, node) -> None: ...
    def visit_Continue(self, node) -> None: ...
    def visit_Delete(self, node) -> None: ...
    def visit_Exec(self, node) -> None: ...
    def visit_Expr(self, node) -> None: ...
    def visit_Global(self, node) -> None: ...
    def visit_Import(self, node) -> None: ...
    def visit_ImportFrom(self, node) -> None: ...
    def visit_NamedExpr(self, node) -> None: ...
    def visit_Nonlocal(self, node) -> None: ...
    def visit_Pass(self, node) -> None: ...
    def visit_Print(self, node) -> None: ...
    def visit_Return(self, node) -> None: ...
    def visit_Yield(self, node) -> None: ...
    def visit_YieldFrom(self, node) -> None: ...
    def visit_Attribute(self, node) -> None: ...
    def visit_BinOp(self, node) -> None: ...
    def visit_BoolOp(self, node) -> None: ...
    def visit_Call(self, node) -> None: ...
    def visit_Call_arguments(self, node): ...
    def visit_Call_arguments35(self, node): ...
    def visit_Starred(self, node) -> None: ...
    def visit_Compare(self, node) -> None: ...
    def visit_Dict(self, node) -> None: ...
    def visit_DictComp(self, node) -> None: ...
    def visit_GeneratorExp(self, node) -> None: ...
    def visit_IfExp(self, node) -> None: ...
    def visit_Lambda(self, node) -> None: ...
    def visit_List(self, node) -> None: ...
    def visit_ListComp(self, node) -> None: ...
    def visit_Name(self, node) -> None: ...
    def visit_NameConstant(self, node) -> None: ...
    def visit_Repr(self, node) -> None: ...
    def visit_Set(self, node) -> None: ...
    def visit_SetComp(self, node) -> None: ...
    def visit_Subscript(self, node) -> None: ...
    def visit_Tuple(self, node) -> None: ...
    def visit_UnaryOp(self, node) -> None: ...
    def visit_Ellipsis(self, node) -> None: ...
    def visit_Add(self, node) -> None: ...
    def visit_Sub(self, node) -> None: ...
    def visit_Mult(self, node) -> None: ...
    def visit_Div(self, node) -> None: ...
    def visit_Mod(self, node) -> None: ...
    def visit_Pow(self, node) -> None: ...
    def visit_LShift(self, node) -> None: ...
    def visit_RShift(self, node) -> None: ...
    def visit_BitAnd(self, node) -> None: ...
    def visit_BitOr(self, node) -> None: ...
    def visit_BitXor(self, node) -> None: ...
    def visit_FloorDiv(self, node) -> None: ...
    def visit_Invert(self, node) -> None: ...
    def visit_Not(self, node) -> None: ...
    def visit_UAdd(self, node) -> None: ...
    def visit_USub(self, node) -> None: ...
    def visit_Eq(self, node) -> None: ...
    def visit_NotEq(self, node) -> None: ...
    def visit_Lt(self, node) -> None: ...
    def visit_LtE(self, node) -> None: ...
    def visit_Gt(self, node) -> None: ...
    def visit_GtE(self, node) -> None: ...
    def visit_Is(self, node) -> None: ...
    def visit_IsNot(self, node) -> None: ...
    def visit_In(self, node) -> None: ...
    def visit_NotIn(self, node) -> None: ...
    def visit_alias(self, node) -> None: ...
    def visit_arg(self, node) -> None: ...
    def visit_arguments(self, node) -> None: ...
    def visit_comprehension(self, node) -> None: ...
    def visit_keyword(self, node) -> None: ...
    def visit_Index(self, node) -> None: ...
    def visit_ExtSlice(self, node) -> None: ...
    def visit_Slice(self, node) -> None: ...
    def check_slice_includes_step(self, node):
        """Helper function for Slice node to determine whether to visit its step."""
    def visit_FormattedValue(self, node) -> None: ...

class AnnotationError(Exception):
    """An exception for when we failed to annotate the tree."""

class AstAnnotator(BaseVisitor):
    tokens: Incomplete
    def __init__(self, source) -> None: ...
    def visit(self, node) -> None: ...
    def indented(self, node, children_attr) -> Generator[Incomplete, None, Incomplete]:
        """Generator which annotates child nodes with their indentation level."""
    def visit_Num(self, node):
        """Annotate a Num node with the exact number format."""
    def visit_Str(self, node) -> None:
        """Annotate a Str node with the exact string format."""
    def visit_JoinedStr(self, node):
        """Annotate a JoinedStr node with the fstr formatting metadata."""
    def visit_Bytes(self, node) -> None:
        """Annotate a Bytes node with the exact string format."""
    def visit_Ellipsis(self, node) -> None: ...
    def check_is_elif(self, node):
        """Return True iff the If node is an `elif` in the source."""
    def check_is_continued_try(self, node):
        """Return True iff the TryExcept node is a continued `try` in the source."""
    def check_is_continued_with(self, node):
        """Return True iff the With node is a continued `with` in the source."""
    def check_slice_includes_step(self, node):
        """Helper function for Slice node to determine whether to visit its step."""
    def ws(self, max_lines: Incomplete | None = None, semicolon: bool = False, comment: bool = True):
        """Parse some whitespace from the source tokens and return it."""
    def dots(self, num_dots):
        """Parse a number of dots."""
    def block_suffix(self, node, indent_level) -> None: ...
    def token(self, token_val):
        """Parse a single token with exactly the given value."""
    def optional_token(self, node, attr_name, token_val, allow_whitespace_prefix: bool = False, default: bool = False) -> None:
        """Try to parse a token and attach it to the node."""
    def one_of_symbols(self, *symbols):
        """Account for one of the given symbols."""
    def attr(self, node, attr_name, attr_vals, deps: Incomplete | None = None, default: Incomplete | None = None) -> None:
        """Parses some source and sets an attribute on the given node.

    Stores some arbitrary formatting information on the node. This takes a list
    attr_vals which tell what parts of the source to parse. The result of each
    function is concatenated onto the formatting data, and strings in this list
    are a shorthand to look for an exactly matching token.

    For example:
      self.attr(node, 'foo', ['(', self.ws, 'Hello, world!', self.ws, ')'],
                deps=('s',), default=node.s)

    is a rudimentary way to parse a parenthesized string. After running this,
    the matching source code for this node will be stored in its formatting
    dict under the key 'foo'. The result might be `(
  'Hello, world!'
)`.

    This also keeps track of the current value of each of the dependencies.
    In the above example, we would have looked for the string 'Hello, world!'
    because that's the value of node.s, however, when we print this back, we
    want to know if the value of node.s has changed since this time. If any of
    the dependent values has changed, the default would be used instead.

    Arguments:
      node: (ast.AST) An AST node to attach formatting information to.
      attr_name: (string) Name to store the formatting information under.
      attr_vals: (list of functions/strings) Each item is either a function
        that parses some source and return a string OR a string to match
        exactly (as a token).
      deps: (optional, set of strings) Attributes of the node which attr_vals
        depends on.
      default: (string) Unused here.
    """
    def scope(self, node, attr: Incomplete | None = None, trailing_comma: bool = False, default_parens: bool = False):
        """Return a context manager to handle a parenthesized scope.

    Arguments:
      node: (ast.AST) Node to store the scope prefix and suffix on.
      attr: (string, optional) Attribute of the node contained in the scope, if
        any. For example, as `None`, the scope would wrap the entire node, but
        as 'bases', the scope might wrap only the bases of a class.
      trailing_comma: (boolean) If True, allow a trailing comma at the end.
      default_parens: (boolean) If True and no formatting information is
        present, the scope would be assumed to be parenthesized.
    """
