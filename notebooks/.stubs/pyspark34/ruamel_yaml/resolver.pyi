from ruamel_yaml.error import *
from _typeshed import Incomplete
from ruamel_yaml.compat import VersionType
from typing import Any, Dict, Text

__all__ = ['BaseResolver', 'Resolver', 'VersionedResolver']

class ResolverError(YAMLError): ...

class BaseResolver:
    DEFAULT_SCALAR_TAG: str
    DEFAULT_SEQUENCE_TAG: str
    DEFAULT_MAPPING_TAG: str
    yaml_implicit_resolvers: Dict[Any, Any]
    yaml_path_resolvers: Dict[Any, Any]
    loadumper: Incomplete
    resolver_exact_paths: Incomplete
    resolver_prefix_paths: Incomplete
    def __init__(self, loadumper: Any = None) -> None: ...
    @property
    def parser(self) -> Any: ...
    @classmethod
    def add_implicit_resolver_base(cls, tag: Any, regexp: Any, first: Any) -> None: ...
    @classmethod
    def add_implicit_resolver(cls, tag: Any, regexp: Any, first: Any) -> None: ...
    @classmethod
    def add_path_resolver(cls, tag: Any, path: Any, kind: Any = None) -> None: ...
    def descend_resolver(self, current_node: Any, current_index: Any) -> None: ...
    def ascend_resolver(self) -> None: ...
    def check_resolver_prefix(self, depth: int, path: Text, kind: Any, current_node: Any, current_index: Any) -> bool: ...
    def resolve(self, kind: Any, value: Any, implicit: Any) -> Any: ...
    @property
    def processing_version(self) -> Any: ...

class Resolver(BaseResolver): ...

class VersionedResolver(BaseResolver):
    '''
    contrary to the "normal" resolver, the smart resolver delays loading
    the pattern matching rules. That way it can decide to load 1.1 rules
    or the (default) 1.2 rules, that no longer support octal without 0o, sexagesimals
    and Yes/No/On/Off booleans.
    '''
    def __init__(self, version: VersionType | None = None, loader: Any = None, loadumper: Any = None) -> None: ...
    def add_version_implicit_resolver(self, version: VersionType, tag: Any, regexp: Any, first: Any) -> None: ...
    def get_loader_version(self, version: VersionType | None) -> Any: ...
    @property
    def versioned_resolver(self) -> Any:
        """
        select the resolver based on the version we are parsing
        """
    def resolve(self, kind: Any, value: Any, implicit: Any) -> Any: ...
    @property
    def processing_version(self) -> Any: ...
