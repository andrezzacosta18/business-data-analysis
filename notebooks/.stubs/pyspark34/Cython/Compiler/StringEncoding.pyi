from _typeshed import Incomplete

IS_PYTHON3: bool
empty_bytes: Incomplete
empty_unicode: Incomplete
join_bytes: Incomplete

class UnicodeLiteralBuilder:
    """Assemble a unicode string.
    """
    chars: Incomplete
    def __init__(self) -> None: ...
    def append(self, characters) -> None: ...
    def append_charval(self, char_number) -> None: ...
    def append_charval(self, char_number) -> None: ...
    def append_uescape(self, char_number, escape_string) -> None: ...
    def getstring(self): ...
    def getstrings(self): ...

class BytesLiteralBuilder:
    """Assemble a byte string or char value.
    """
    chars: Incomplete
    target_encoding: Incomplete
    def __init__(self, target_encoding) -> None: ...
    def append(self, characters) -> None: ...
    def append_charval(self, char_number) -> None: ...
    def append_uescape(self, char_number, escape_string) -> None: ...
    def getstring(self): ...
    def getchar(self): ...
    def getstrings(self): ...

class StrLiteralBuilder:
    """Assemble both a bytes and a unicode representation of a string.
    """
    def __init__(self, target_encoding) -> None: ...
    def append(self, characters) -> None: ...
    def append_charval(self, char_number) -> None: ...
    def append_uescape(self, char_number, escape_string) -> None: ...
    def getstrings(self): ...

class EncodedString(_unicode):
    encoding: Incomplete
    def __deepcopy__(self, memo): ...
    def byteencode(self): ...
    def utf8encode(self): ...
    @property
    def is_unicode(self): ...
    def contains_surrogates(self): ...
    def as_utf8_string(self): ...
    def as_c_string_literal(self): ...
    def isascii(self): ...

def string_contains_surrogates(ustring):
    """
    Check if the unicode string contains surrogate code points
    on a CPython platform with wide (UCS-4) or narrow (UTF-16)
    Unicode, i.e. characters that would be spelled as two
    separate code units on a narrow platform.
    """
def string_contains_lone_surrogates(ustring):
    """
    Check if the unicode string contains lone surrogate code points
    on a CPython platform with wide (UCS-4) or narrow (UTF-16)
    Unicode, i.e. characters that would be spelled as two
    separate code units on a narrow platform, but that do not form a pair.
    """

class BytesLiteral(_bytes):
    encoding: Incomplete
    def __deepcopy__(self, memo): ...
    def byteencode(self): ...
    def utf8encode(self) -> None: ...
    is_unicode: bool
    def as_c_string_literal(self): ...
    def isascii(self): ...

def bytes_literal(s, encoding): ...
def encoded_string(s, encoding): ...
def encoded_string_or_bytes_literal(s, encoding): ...

char_from_escape_sequence: Incomplete

def escape_char(c): ...
def escape_byte_string(s):
    """Escape a byte string so that it can be written into C code.
    Note that this returns a Unicode string instead which, when
    encoded as ISO-8859-1, will result in the correct byte sequence
    being written.
    """
def split_string_literal(s, limit: int = 2000): ...
def encode_pyunicode_string(s):
    """Create Py_UNICODE[] representation of a given unicode string.
    """
