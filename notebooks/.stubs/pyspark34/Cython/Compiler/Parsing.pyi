from . import Builtin as Builtin, ExprNodes as ExprNodes, Future as Future, Nodes as Nodes, Options as Options, StringEncoding as StringEncoding
from .. import Utils as Utils
from .Errors import error as error, warning as warning
from .ModuleNode import ModuleNode as ModuleNode
from .Scanning import FileSourceDescriptor as FileSourceDescriptor, PyrexScanner as PyrexScanner, tentatively_scan as tentatively_scan
from .StringEncoding import EncodedString as EncodedString, bytes_literal as bytes_literal
from _typeshed import Incomplete

class Ctx:
    level: str
    visibility: str
    cdef_flag: int
    typedef_flag: int
    api: int
    overridable: int
    nogil: int
    namespace: Incomplete
    templates: Incomplete
    allow_struct_enum_decorator: bool
    def __init__(self, **kwds) -> None: ...
    def __call__(self, **kwds): ...

def p_ident(s, message: str = 'Expected an identifier'): ...
def p_ident_list(s): ...
def p_binop_operator(s): ...
def p_binop_expr(s, ops, p_sub_expr): ...
def p_lambdef(s): ...
def p_test(s): ...
def p_test_allow_walrus_after(s): ...
def p_namedexpr_test(s): ...

COMMON_BINOP_MISTAKES: Incomplete

def p_or_test(s): ...
def p_rassoc_binop_expr(s, op, p_subexpr): ...
def p_and_test(s): ...
def p_not_test(s): ...
def p_comparison(s): ...
def p_test_or_starred_expr(s): ...
def p_namedexpr_test_or_starred_expr(s): ...
def p_starred_expr(s): ...
def p_cascaded_cmp(s): ...
def p_cmp_op(s): ...

comparison_ops: Incomplete

def p_bit_expr(s): ...
def p_xor_expr(s): ...
def p_and_expr(s): ...
def p_shift_expr(s): ...
def p_arith_expr(s): ...
def p_term(s): ...
def p_factor(s): ...
def p_typecast(s): ...
def p_sizeof(s): ...
def p_yield_expression(s): ...
def p_yield_statement(s): ...
def p_async_statement(s, ctx, decorators): ...
def p_power(s): ...
def p_new_expr(s): ...
def p_trailer(s, node1): ...
def p_call_parse_args(s, allow_genexp: bool = True): ...
def p_call_build_packed_args(pos, positional_args, keyword_args): ...
def p_call(s, function): ...
def p_index(s, base): ...
def p_subscript_list(s): ...
def p_subscript(s): ...
def p_slice_element(s, follow_set): ...
def expect_ellipsis(s) -> None: ...
def make_slice_nodes(pos, subscripts): ...
def make_slice_node(pos, start, stop: Incomplete | None = None, step: Incomplete | None = None): ...
def p_atom(s): ...
def p_int_literal(s): ...
def p_name(s, name): ...
def wrap_compile_time_constant(pos, value): ...
def p_cat_string_literal(s): ...
def p_opt_string_literal(s, required_type: str = 'u'): ...
def check_for_non_ascii_characters(string): ...
def p_string_literal(s, kind_override: Incomplete | None = None): ...
def p_f_string(s, unicode_value, pos, is_raw): ...
def p_f_string_expr(s, unicode_value, pos, starting_index, is_raw): ...
def p_list_maker(s): ...
def p_comp_iter(s, body): ...
def p_comp_for(s, body): ...
def p_comp_if(s, body): ...
def p_dict_or_set_maker(s): ...
def p_backquote_expr(s): ...
def p_simple_expr_list(s, expr: Incomplete | None = None): ...
def p_test_or_starred_expr_list(s, expr: Incomplete | None = None): ...
def p_namedexpr_test_or_starred_expr_list(s, expr: Incomplete | None = None): ...
def p_testlist(s): ...
def p_testlist_star_expr(s): ...
def p_testlist_comp(s): ...
def p_genexp(s, expr): ...

expr_terminators: Incomplete

def p_global_statement(s): ...
def p_nonlocal_statement(s): ...
def p_expression_or_assignment(s): ...
def p_print_statement(s): ...
def p_exec_statement(s): ...
def p_del_statement(s): ...
def p_pass_statement(s, with_newline: int = 0): ...
def p_break_statement(s): ...
def p_continue_statement(s): ...
def p_return_statement(s): ...
def p_raise_statement(s): ...
def p_import_statement(s): ...
def p_from_import_statement(s, first_statement: int = 0): ...
def p_imported_name(s): ...
def p_dotted_name(s, as_allowed): ...
def p_as_name(s): ...
def p_assert_statement(s): ...

statement_terminators: Incomplete

def p_if_statement(s): ...
def p_if_clause(s): ...
def p_else_clause(s): ...
def p_while_statement(s): ...
def p_for_statement(s, is_async: bool = False): ...
def p_for_bounds(s, allow_testlist: bool = True, is_async: bool = False): ...
def p_for_from_relation(s): ...
def p_for_from_step(s): ...

inequality_relations: Incomplete

def p_target(s, terminator): ...
def p_for_target(s): ...
def p_for_iterator(s, allow_testlist: bool = True, is_async: bool = False): ...
def p_try_statement(s): ...
def p_except_clause(s): ...
def p_include_statement(s, ctx): ...
def p_with_statement(s): ...
def p_with_items(s, is_async: bool = False):
    """
    Copied from CPython:
    | 'with' '(' a[asdl_withitem_seq*]=','.with_item+ ','? ')' ':' b=block {
        _PyAST_With(a, b, NULL, EXTRA) }
    | 'with' a[asdl_withitem_seq*]=','.with_item+ ':' tc=[TYPE_COMMENT] b=block {
        _PyAST_With(a, b, NEW_TYPE_COMMENT(p, tc), EXTRA) }
    Therefore the first thing to try is the bracket-enclosed
    version and if that fails try the regular version
    """
def p_with_items_list(s, is_async): ...
def p_with_item(s, is_async): ...
def p_with_template(s): ...
def p_simple_statement(s, first_statement: int = 0): ...
def p_simple_statement_list(s, ctx, first_statement: int = 0): ...
def p_compile_time_expr(s): ...
def p_DEF_statement(s): ...
def p_IF_statement(s, ctx): ...
def p_statement(s, ctx, first_statement: int = 0): ...
def p_statement_list(s, ctx, first_statement: int = 0): ...
def p_suite(s, ctx=...): ...
def p_suite_with_docstring(s, ctx, with_doc_only: bool = False): ...
def p_positional_and_keyword_args(s, end_sy_set, templates: Incomplete | None = None):
    """
    Parses positional and keyword arguments. end_sy_set
    should contain any s.sy that terminate the argument list.
    Argument expansion (* and **) are not allowed.

    Returns: (positional_args, keyword_args)
    """
def p_c_base_type(s, nonempty: bool = False, templates: Incomplete | None = None): ...
def p_calling_convention(s): ...

calling_convention_words: Incomplete

def p_c_complex_base_type(s, templates: Incomplete | None = None): ...
def p_c_simple_base_type(s, nonempty, templates: Incomplete | None = None): ...
def p_buffer_or_template(s, base_type_node, templates): ...
def p_bracketed_base_type(s, base_type_node, nonempty, empty): ...
def is_memoryviewslice_access(s): ...
def p_memoryviewslice_access(s, base_type_node): ...
def looking_at_name(s): ...
def looking_at_expr(s): ...
def looking_at_base_type(s): ...
def looking_at_dotted_name(s): ...

basic_c_type_names: Incomplete
special_basic_c_types: Incomplete
sign_and_longness_words: Incomplete
base_type_start_words: Incomplete
struct_enum_union: Incomplete

def p_sign_and_longness(s): ...
def p_opt_cname(s): ...
def p_c_declarator(s, ctx=..., empty: int = 0, is_type: int = 0, cmethod_flag: int = 0, assignable: int = 0, nonempty: int = 0, calling_convention_allowed: int = 0): ...
def p_c_array_declarator(s, base): ...
def p_c_func_declarator(s, pos, ctx, base, cmethod_flag): ...

supported_overloaded_operators: Incomplete

def p_c_simple_declarator(s, ctx, empty, is_type, cmethod_flag, assignable, nonempty): ...
def p_nogil(s): ...
def p_with_gil(s): ...
def p_exception_value_clause(s, is_extern):
    """
    Parse exception value clause.

    Maps clauses to exc_check / exc_value / exc_clause as follows:
     ______________________________________________________________________
    |                             |             |             |            |
    | Clause                      | exc_check   | exc_value   | exc_clause |
    | ___________________________ | ___________ | ___________ | __________ |
    |                             |             |             |            |
    | <nothing> (default func.)   | True        | None        | False      |
    | <nothing> (cdef extern)     | False       | None        | False      |
    | noexcept                    | False       | None        | True       |
    | except <val>                | False       | <val>       | True       |
    | except? <val>               | True        | <val>       | True       |
    | except *                    | True        | None        | True       |
    | except +                    | '+'         | None        | True       |
    | except +*                   | '+'         | '*'         | True       |
    | except +<PyErr>             | '+'         | <PyErr>     | True       |
    | ___________________________ | ___________ | ___________ | __________ |

    Note that the only reason we need `exc_clause` is to raise a
    warning when `'except'` or `'noexcept'` is placed after the
    `'nogil'` keyword.
    """

c_arg_list_terminators: Incomplete

def p_c_arg_list(s, ctx=..., in_pyfunc: int = 0, cmethod_flag: int = 0, nonempty_declarators: int = 0, kw_only: int = 0, annotated: int = 1): ...
def p_optional_ellipsis(s): ...
def p_c_arg_decl(s, ctx, in_pyfunc, cmethod_flag: int = 0, nonempty: int = 0, kw_only: int = 0, annotated: int = 1): ...
def p_api(s): ...
def p_cdef_statement(s, ctx): ...
def p_cdef_block(s, ctx): ...
def p_cdef_extern_block(s, pos, ctx): ...
def p_c_enum_definition(s, pos, ctx): ...
def p_c_enum_line(s, ctx, items) -> None: ...
def p_c_enum_item(s, ctx, items) -> None: ...
def p_c_struct_or_union_definition(s, pos, ctx): ...
def p_fused_definition(s, pos, ctx):
    """
    c(type)def fused my_fused_type:
        ...
    """
def p_struct_enum(s, pos, ctx): ...
def p_visibility(s, prev_visibility): ...
def p_c_modifiers(s): ...
def p_c_func_or_var_declaration(s, pos, ctx): ...
def p_ctypedef_statement(s, ctx): ...
def p_decorators(s): ...
def p_def_statement(s, decorators: Incomplete | None = None, is_async_def: bool = False): ...
def p_varargslist(s, terminator: str = ')', annotated: int = 1): ...
def p_py_arg_decl(s, annotated: int = 1): ...
def p_class_statement(s, decorators): ...
def p_c_class_definition(s, pos, ctx): ...
def p_c_class_options(s): ...
def p_property_decl(s): ...
def p_ignorable_statement(s):
    """
    Parses any kind of ignorable statement that is allowed in .pxd files.
    """
def p_doc_string(s): ...
def p_code(s, level: Incomplete | None = None, ctx=...): ...
def p_compiler_directive_comments(s): ...
def p_module(s, pxd, full_module_name, ctx=...): ...
def p_template_definition(s): ...
def p_cpp_class_definition(s, pos, ctx): ...
def p_cpp_class_attribute(s, ctx): ...
def print_parse_tree(f, node, level, key: Incomplete | None = None) -> None: ...
def p_annotation(s):
    '''An annotation just has the "test" syntax, but also stores the string it came from

    Note that the string is *allowed* to be changed/processed (although isn\'t here)
    so may not exactly match the string generated by Python, and if it doesn\'t
    then it is not a bug.
    '''
