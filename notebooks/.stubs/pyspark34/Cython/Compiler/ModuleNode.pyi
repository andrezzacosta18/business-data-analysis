from . import Annotate as Annotate, Code as Code, Future as Future, Naming as Naming, Nodes as Nodes, Options as Options, PyrexTypes as PyrexTypes, Pythran as Pythran, TypeSlots as TypeSlots
from ..Utils import build_hex_version as build_hex_version, decode_filename as decode_filename, is_cython_generated_file as is_cython_generated_file, open_new_file as open_new_file, replace_suffix as replace_suffix
from .Code import IncludeCode as IncludeCode, TempitaUtilityCode as TempitaUtilityCode, UtilityCode as UtilityCode
from .Errors import CompileError as CompileError, error as error, warning as warning
from .PyrexTypes import CPtrType as CPtrType, py_object_type as py_object_type
from .Pythran import has_np_pythran as has_np_pythran
from .StringEncoding import EncodedString as EncodedString, encoded_string_or_bytes_literal as encoded_string_or_bytes_literal
from _typeshed import Incomplete

def replace_suffix_encoded(path, newsuf): ...
def as_encoded_filename(path): ...
def check_c_declarations_pxd(module_node): ...
def check_c_declarations(module_node): ...
def generate_c_code_config(env, options): ...

TOTAL_ORDERING: Incomplete

class ModuleNode(Nodes.Node, Nodes.BlockNode):
    child_attrs: Incomplete
    directives: Incomplete
    pxd_stats: Incomplete
    utility_code_stats: Incomplete
    def merge_in(self, tree, scope, stage, merge_scope: bool = False) -> None: ...
    def with_compiler_directives(self): ...
    def analyse_declarations(self, env) -> None: ...
    def prepare_utility_code(self) -> None: ...
    referenced_modules: Incomplete
    def process_implementation(self, options, result) -> None: ...
    def has_imported_c_functions(self): ...
    def assure_safe_target(self, path, allow_failed: bool = False) -> None: ...
    def generate_h_code(self, env, options, result): ...
    def generate_public_declaration(self, entry, h_code, i_code) -> None: ...
    def api_name(self, prefix, env): ...
    def generate_api_code(self, env, options, result): ...
    def generate_cclass_header_code(self, type, h_code) -> None: ...
    def generate_cclass_include_code(self, type, i_code) -> None: ...
    def generate_c_code(self, env, options, result) -> None: ...
    def find_referenced_modules(self, env, module_list, modules_seen) -> None: ...
    def sort_types_by_inheritance(self, type_dict, type_order, getkey): ...
    def sort_type_hierarchy(self, module_list, env): ...
    def sort_cdef_classes(self, env) -> None: ...
    def generate_type_definitions(self, env, modules, vtab_list, vtabslot_list, code) -> None: ...
    def generate_declarations_for_modules(self, env, modules, globalstate) -> None: ...
    def generate_module_preamble(self, env, options, cimported_modules, metadata, code) -> None: ...
    def generate_extern_c_macro_definition(self, code, is_cpp) -> None: ...
    def generate_dl_import_macro(self, code) -> None: ...
    def generate_includes(self, env, cimported_modules, code, early: bool = True, late: bool = True) -> None: ...
    def generate_filename_table(self, code) -> None: ...
    def generate_type_predeclarations(self, env, code) -> None: ...
    def generate_type_header_code(self, type_entries, code) -> None: ...
    def generate_gcc33_hack(self, env, code) -> None: ...
    def generate_typedef(self, entry, code) -> None: ...
    def sue_predeclaration(self, type, kind, name): ...
    def generate_struct_union_predeclaration(self, entry, code) -> None: ...
    def sue_header_footer(self, type, kind, name): ...
    def generate_struct_union_definition(self, entry, code) -> None: ...
    def generate_cpp_class_definition(self, entry, code) -> None: ...
    def generate_enum_definition(self, entry, code) -> None: ...
    def generate_typeobj_predeclaration(self, entry, code) -> None: ...
    def generate_exttype_vtable_struct(self, entry, code) -> None: ...
    def generate_exttype_vtabptr_declaration(self, entry, code) -> None: ...
    def generate_exttype_final_methods_declaration(self, entry, code) -> None: ...
    def generate_objstruct_predeclaration(self, type, code) -> None: ...
    def generate_objstruct_definition(self, type, code) -> None: ...
    def generate_c_class_declarations(self, env, code, definition, globalstate) -> None: ...
    def generate_cvariable_declarations(self, env, code, definition) -> None: ...
    def generate_cfunction_declarations(self, env, code, definition) -> None: ...
    def generate_variable_definitions(self, env, code) -> None: ...
    def generate_typeobj_definitions(self, env, code) -> None: ...
    def generate_exttype_vtable(self, scope, code) -> None: ...
    def generate_self_cast(self, scope, code) -> None: ...
    def generate_new_function(self, scope, code, cclass_entry) -> None: ...
    def generate_del_function(self, scope, code) -> None: ...
    def generate_dealloc_function(self, scope, code) -> None: ...
    def generate_usr_dealloc_call(self, scope, code) -> None: ...
    def generate_traverse_function(self, scope, code, cclass_entry) -> None: ...
    def generate_clear_function(self, scope, code, cclass_entry) -> None: ...
    def generate_getitem_int_function(self, scope, code) -> None: ...
    def generate_ass_subscript_function(self, scope, code) -> None: ...
    def generate_guarded_basetype_call(self, base_type, substructure, slot, args, code) -> None: ...
    def generate_ass_slice_function(self, scope, code) -> None: ...
    def generate_richcmp_function(self, scope, code) -> None: ...
    def generate_binop_function(self, scope, slot, code, pos): ...
    def generate_getattro_function(self, scope, code): ...
    def generate_setattro_function(self, scope, code) -> None: ...
    def generate_descr_get_function(self, scope, code) -> None: ...
    def generate_descr_set_function(self, scope, code) -> None: ...
    def generate_property_accessors(self, cclass_scope, code) -> None: ...
    def generate_property_get_function(self, property_entry, code) -> None: ...
    def generate_property_set_function(self, property_entry, code) -> None: ...
    def generate_typeobj_spec(self, entry, code) -> None: ...
    def generate_typeobj_definition(self, modname, entry, code) -> None: ...
    def generate_method_table(self, env, code) -> None: ...
    def generate_dict_getter_function(self, scope, code) -> None: ...
    def generate_getset_table(self, env, code) -> None: ...
    def create_import_star_conversion_utility_code(self, env) -> None: ...
    def generate_import_star(self, env, code) -> None: ...
    def generate_module_state_start(self, env, code) -> None: ...
    def generate_module_state_end(self, env, modules, globalstate) -> None: ...
    def generate_module_state_defines(self, env, code) -> None: ...
    def generate_module_state_clear(self, env, code) -> None: ...
    def generate_module_state_traverse(self, env, code) -> None: ...
    def generate_module_init_func(self, imported_modules, env, code) -> None: ...
    cfunc_name: Incomplete
    description: Incomplete
    tempdecl_code: Incomplete
    call_code: Incomplete
    def mod_init_subfunction(self, pos, scope, orig_code):
        """
        Return a context manager that allows deviating the module init code generation
        into a separate function and instead inserts a call to it.

        Can be reused sequentially to create multiple functions.
        The functions get inserted at the point where the context manager was created.
        The call gets inserted where the context manager is used (on entry).
        """
    def generate_module_import_setup(self, env, code) -> None: ...
    def generate_module_cleanup_func(self, env, code) -> None: ...
    def generate_main_method(self, env, code) -> None: ...
    def punycode_module_name(self, prefix, name): ...
    def wrong_punycode_module_name(self, name): ...
    def mod_init_func_cname(self, prefix, env): ...
    def module_init_func_cname(self): ...
    def generate_pymoduledef_struct(self, env, code) -> None: ...
    def generate_module_creation_code(self, env, code) -> None: ...
    def generate_global_init_code(self, env, code) -> None: ...
    def generate_wrapped_entries_code(self, env, code) -> None: ...
    def generate_c_variable_export_code(self, env, code) -> None: ...
    def generate_c_function_export_code(self, env, code) -> None: ...
    def generate_type_import_code_for_module(self, module, env, code) -> None: ...
    def specialize_fused_types(self, pxd_env) -> None:
        """
        If fused c(p)def functions are defined in an imported pxd, but not
        used in this implementation file, we still have fused entries and
        not specialized ones. This method replaces any fused entries with their
        specialized ones.
        """
    def generate_c_variable_import_code_for_module(self, module, env, code) -> None: ...
    def generate_c_function_import_code_for_module(self, module, env, code) -> None: ...
    def generate_type_init_code(self, env, code) -> None: ...
    def generate_base_type_import_code(self, env, entry, code, import_generator) -> None: ...
    def generate_type_import_code(self, env, type, pos, code, import_generator) -> None: ...
    def generate_type_import_call(self, type, code, import_generator, error_code: Incomplete | None = None, error_pos: Incomplete | None = None) -> None: ...
    def generate_type_ready_code(self, entry, code) -> None: ...
    def is_main_module_flag_cname(self): ...
    def generate_exttype_vtable_init_code(self, entry, code) -> None: ...

class ModuleImportGenerator:
    """
    Helper to generate module import while importing external types.
    This is used to avoid excessive re-imports of external modules when multiple types are looked up.
    """
    code: Incomplete
    imported: Incomplete
    temps: Incomplete
    def __init__(self, code, imported_modules: Incomplete | None = None) -> None: ...
    def imported_module(self, module_name_string, error_code): ...
    def __enter__(self): ...
    def __exit__(self, *exc) -> None: ...

def generate_cfunction_declaration(entry, env, code, definition) -> None: ...

refnanny_utility_code: Incomplete
packed_struct_utility_code: Incomplete
