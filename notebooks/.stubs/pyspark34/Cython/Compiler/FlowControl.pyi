from . import Builtin as Builtin, ExprNodes as ExprNodes, Nodes as Nodes, Options as Options, PyrexTypes as PyrexTypes
from .Errors import InternalError as InternalError, error as error, warning as warning
from .Visitor import CythonTransform as CythonTransform, TreeVisitor as TreeVisitor
from _typeshed import Incomplete

class TypedExprNode(ExprNodes.ExprNode):
    type: Incomplete
    def __init__(self, type, may_be_none: Incomplete | None = None, pos: Incomplete | None = None) -> None: ...
    def may_be_none(self): ...

fake_rhs_expr: Incomplete

class ControlBlock:
    """Control flow graph node. Sequence of assignments and name references.

       children  set of children nodes
       parents   set of parent nodes
       positions set of position markers

       stats     list of block statements
       gen       dict of assignments generated by this block
       bounded   set  of entries that are definitely bounded in this block

       Example:

        a = 1
        b = a + c # 'c' is already bounded or exception here

        stats = [Assignment(a), NameReference(a), NameReference(c),
                     Assignment(b)]
        gen = {Entry(a): Assignment(a), Entry(b): Assignment(b)}
        bounded = {Entry(a), Entry(c)}

    """
    children: Incomplete
    parents: Incomplete
    positions: Incomplete
    stats: Incomplete
    gen: Incomplete
    bounded: Incomplete
    i_input: int
    i_output: int
    i_gen: int
    i_kill: int
    i_state: int
    def __init__(self) -> None: ...
    def empty(self): ...
    def detach(self) -> None:
        """Detach block from parents and children."""
    def add_child(self, block) -> None: ...

class ExitBlock(ControlBlock):
    """Non-empty exit point block."""
    def empty(self): ...

class AssignmentList:
    stats: Incomplete
    def __init__(self) -> None: ...

class ControlFlow:
    """Control-flow graph.

       entry_point ControlBlock entry point for this graph
       exit_point  ControlBlock normal exit point
       block       ControlBlock current block
       blocks      set    children nodes
       entries     set    tracked entries
       loops       list   stack for loop descriptors
       exceptions  list   stack for exception descriptors
       in_try_block  int  track if we're in a try...except or try...finally block
    """
    blocks: Incomplete
    entries: Incomplete
    loops: Incomplete
    exceptions: Incomplete
    entry_point: Incomplete
    exit_point: Incomplete
    block: Incomplete
    in_try_block: int
    def __init__(self) -> None: ...
    def newblock(self, parent: Incomplete | None = None):
        """Create floating block linked to `parent` if given.

           NOTE: Block is NOT added to self.blocks
        """
    def nextblock(self, parent: Incomplete | None = None):
        """Create block children block linked to current or `parent` if given.

           NOTE: Block is added to self.blocks
        """
    def is_tracked(self, entry): ...
    def is_statically_assigned(self, entry): ...
    def mark_position(self, node) -> None:
        """Mark position, will be used to draw graph nodes."""
    def mark_assignment(self, lhs, rhs, entry, rhs_scope: Incomplete | None = None) -> None: ...
    def mark_argument(self, lhs, rhs, entry) -> None: ...
    def mark_deletion(self, node, entry) -> None: ...
    def mark_reference(self, node, entry) -> None: ...
    def normalize(self) -> None:
        """Delete unreachable and orphan blocks."""
    assmts: Incomplete
    def initialize(self) -> None:
        """Set initial state, map assignments to bits."""
    def map_one(self, istate, entry): ...
    def reaching_definitions(self) -> None:
        """Per-block reaching definitions analysis."""

class LoopDescr:
    next_block: Incomplete
    loop_block: Incomplete
    exceptions: Incomplete
    def __init__(self, next_block, loop_block) -> None: ...

class ExceptionDescr:
    """Exception handling helper.

    entry_point   ControlBlock Exception handling entry point
    finally_enter ControlBlock Normal finally clause entry point
    finally_exit  ControlBlock Normal finally clause exit point
    """
    entry_point: Incomplete
    finally_enter: Incomplete
    finally_exit: Incomplete
    def __init__(self, entry_point, finally_enter: Incomplete | None = None, finally_exit: Incomplete | None = None) -> None: ...

class NameAssignment:
    lhs: Incomplete
    rhs: Incomplete
    entry: Incomplete
    pos: Incomplete
    refs: Incomplete
    is_arg: bool
    is_deletion: bool
    inferred_type: Incomplete
    rhs_scope: Incomplete
    def __init__(self, lhs, rhs, entry, rhs_scope: Incomplete | None = None) -> None: ...
    def infer_type(self): ...
    def type_dependencies(self): ...
    @property
    def type(self): ...

class StaticAssignment(NameAssignment):
    """Initialised at declaration time, e.g. stack allocation."""
    def __init__(self, entry) -> None: ...
    def infer_type(self): ...
    def type_dependencies(self): ...

class Argument(NameAssignment):
    is_arg: bool
    def __init__(self, lhs, rhs, entry) -> None: ...

class NameDeletion(NameAssignment):
    is_deletion: bool
    def __init__(self, lhs, entry) -> None: ...
    inferred_type: Incomplete
    def infer_type(self): ...

class Uninitialized:
    """Definitely not initialised yet."""
class Unknown:
    """Coming from outer closure, might be initialised or not."""

class NameReference:
    node: Incomplete
    entry: Incomplete
    pos: Incomplete
    def __init__(self, node, entry) -> None: ...

class ControlFlowState(list):
    cf_maybe_null: bool
    cf_is_null: bool
    is_single: bool
    def __init__(self, state) -> None: ...
    def one(self): ...

class GVContext:
    """Graphviz subgraph object."""
    blockids: Incomplete
    nextid: int
    children: Incomplete
    sources: Incomplete
    def __init__(self) -> None: ...
    def add(self, child) -> None: ...
    def nodeid(self, block): ...
    def extract_sources(self, block): ...
    def render(self, fp, name, annotate_defs: bool = False) -> None:
        """Render graphviz dot graph"""
    def escape(self, text): ...

class GV:
    """Graphviz DOT renderer."""
    name: Incomplete
    flow: Incomplete
    def __init__(self, name, flow) -> None: ...
    def render(self, fp, ctx, annotate_defs: bool = False) -> None: ...

class MessageCollection:
    """Collect error/warnings messages first then sort"""
    messages: Incomplete
    def __init__(self) -> None: ...
    def error(self, pos, message) -> None: ...
    def warning(self, pos, message) -> None: ...
    def report(self) -> None: ...

def check_definitions(flow, compiler_directives) -> None: ...

class AssignmentCollector(TreeVisitor):
    assignments: Incomplete
    def __init__(self) -> None: ...
    def visit_Node(self) -> None: ...
    def visit_SingleAssignmentNode(self, node) -> None: ...
    def visit_CascadedAssignmentNode(self, node) -> None: ...

class ControlFlowAnalysis(CythonTransform):
    def find_in_stack(self, env): ...
    gv_ctx: Incomplete
    constant_folder: Incomplete
    reductions: Incomplete
    in_inplace_assignment: bool
    env: Incomplete
    flow: Incomplete
    stack: Incomplete
    object_expr: Incomplete
    def visit_ModuleNode(self, node): ...
    def visit_FuncDefNode(self, node): ...
    def visit_DefNode(self, node): ...
    def visit_GeneratorBodyDefNode(self, node): ...
    def visit_CTypeDefNode(self, node): ...
    def mark_assignment(self, lhs, rhs: Incomplete | None = None, rhs_scope: Incomplete | None = None) -> None: ...
    def mark_position(self, node) -> None:
        """Mark position if DOT output is enabled."""
    def visit_FromImportStatNode(self, node): ...
    def visit_AssignmentNode(self, node) -> None: ...
    def visit_SingleAssignmentNode(self, node): ...
    def visit_CascadedAssignmentNode(self, node): ...
    def visit_ParallelAssignmentNode(self, node): ...
    def visit_InPlaceAssignmentNode(self, node): ...
    def visit_DelStatNode(self, node): ...
    def visit_CArgDeclNode(self, node): ...
    def visit_NameNode(self, node): ...
    def visit_StatListNode(self, node): ...
    def visit_Node(self, node): ...
    def visit_SizeofVarNode(self, node): ...
    def visit_TypeidNode(self, node): ...
    def visit_IfStatNode(self, node): ...
    def visit_AssertStatNode(self, node):
        """Essentially an if-condition that wraps a RaiseStatNode.
        """
    def visit_WhileStatNode(self, node): ...
    def mark_forloop_target(self, node) -> None: ...
    def visit_AsyncForStatNode(self, node): ...
    def visit_ForInStatNode(self, node): ...
    def visit_ParallelRangeNode(self, node): ...
    def visit_ParallelWithBlockNode(self, node): ...
    def visit_ForFromStatNode(self, node): ...
    def visit_LoopNode(self, node) -> None: ...
    def visit_WithTargetAssignmentStatNode(self, node): ...
    def visit_WithStatNode(self, node): ...
    def visit_TryExceptStatNode(self, node): ...
    def visit_TryFinallyStatNode(self, node): ...
    def visit_RaiseStatNode(self, node): ...
    def visit_ReraiseStatNode(self, node): ...
    def visit_ReturnStatNode(self, node): ...
    def visit_BreakStatNode(self, node): ...
    def visit_ContinueStatNode(self, node): ...
    def visit_ComprehensionNode(self, node): ...
    def visit_ScopedExprNode(self, node): ...
    def visit_PyClassDefNode(self, node): ...
    def visit_CClassDefNode(self, node): ...
    def visit_AmpersandNode(self, node): ...
