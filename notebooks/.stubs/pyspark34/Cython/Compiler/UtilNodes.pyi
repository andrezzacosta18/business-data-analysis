from . import ExprNodes as ExprNodes, Nodes as Nodes
from .ExprNodes import AtomicExprNode as AtomicExprNode
from .Nodes import Node as Node
from .PyrexTypes import c_bint_type as c_bint_type, c_ptr_type as c_ptr_type
from _typeshed import Incomplete

class TempHandle:
    temp: Incomplete
    needs_xdecref: bool
    type: Incomplete
    needs_cleanup: Incomplete
    def __init__(self, type, needs_cleanup: Incomplete | None = None) -> None: ...
    def ref(self, pos): ...

class TempRefNode(AtomicExprNode):
    def analyse_types(self, env): ...
    def analyse_target_types(self, env): ...
    def analyse_target_declaration(self, env) -> None: ...
    def calculate_result_code(self): ...
    def generate_result_code(self, code) -> None: ...
    def generate_assignment_code(self, rhs, code, overloaded_assignment: bool = False) -> None: ...

class TempsBlockNode(Node):
    """
    Creates a block which allocates temporary variables.
    This is used by transforms to output constructs that need
    to make use of a temporary variable. Simply pass the types
    of the needed temporaries to the constructor.

    The variables can be referred to using a TempRefNode
    (which can be constructed by calling get_ref_node).
    """
    child_attrs: Incomplete
    def generate_execution_code(self, code) -> None: ...
    def analyse_declarations(self, env) -> None: ...
    body: Incomplete
    def analyse_expressions(self, env): ...
    def generate_function_definitions(self, env, code) -> None: ...
    def annotate(self, code) -> None: ...

class ResultRefNode(AtomicExprNode):
    subexprs: Incomplete
    lhs_of_first_assignment: bool
    expression: Incomplete
    pos: Incomplete
    may_hold_none: Incomplete
    type: Incomplete
    is_temp: bool
    def __init__(self, expression: Incomplete | None = None, pos: Incomplete | None = None, type: Incomplete | None = None, may_hold_none: bool = True, is_temp: bool = False) -> None: ...
    def clone_node(self): ...
    def type_dependencies(self, env): ...
    def update_expression(self, expression) -> None: ...
    def analyse_target_declaration(self, env) -> None: ...
    def analyse_types(self, env): ...
    def infer_type(self, env): ...
    def may_be_none(self): ...
    def is_simple(self): ...
    result_code: Incomplete
    def result(self): ...
    def generate_evaluation_code(self, code) -> None: ...
    def generate_result_code(self, code) -> None: ...
    def generate_disposal_code(self, code) -> None: ...
    def generate_assignment_code(self, rhs, code, overloaded_assignment: bool = False) -> None: ...
    def allocate_temps(self, env) -> None: ...
    def release_temp(self, env) -> None: ...
    def free_temps(self, code) -> None: ...

class LetNodeMixin:
    lazy_temp: Incomplete
    temp_expression: Incomplete
    def set_temp_expr(self, lazy_temp) -> None: ...
    temp_type: Incomplete
    temp: Incomplete
    def setup_temp_expr(self, code) -> None: ...
    def teardown_temp_expr(self, code) -> None: ...

class EvalWithTempExprNode(ExprNodes.ExprNode, LetNodeMixin):
    subexprs: Incomplete
    pos: Incomplete
    subexpression: Incomplete
    type: Incomplete
    def __init__(self, lazy_temp, subexpression) -> None: ...
    def infer_type(self, env): ...
    def may_be_none(self): ...
    def result(self): ...
    temp_expression: Incomplete
    def analyse_types(self, env): ...
    def free_subexpr_temps(self, code) -> None: ...
    def generate_subexpr_disposal_code(self, code) -> None: ...
    def generate_evaluation_code(self, code) -> None: ...
LetRefNode = ResultRefNode

class LetNode(Nodes.StatNode, LetNodeMixin):
    child_attrs: Incomplete
    pos: Incomplete
    body: Incomplete
    def __init__(self, lazy_temp, body) -> None: ...
    def analyse_declarations(self, env) -> None: ...
    temp_expression: Incomplete
    def analyse_expressions(self, env): ...
    def generate_execution_code(self, code) -> None: ...
    def generate_function_definitions(self, env, code) -> None: ...

class TempResultFromStatNode(ExprNodes.ExprNode):
    subexprs: Incomplete
    child_attrs: Incomplete
    result_ref: Incomplete
    pos: Incomplete
    body: Incomplete
    type: Incomplete
    is_temp: int
    def __init__(self, result_ref, body) -> None: ...
    def analyse_declarations(self, env) -> None: ...
    def analyse_types(self, env): ...
    def may_be_none(self): ...
    def generate_result_code(self, code) -> None: ...
    def generate_function_definitions(self, env, code) -> None: ...

class HasGilNode(AtomicExprNode):
    """
    Simple node that evaluates to 0 or 1 depending on whether we're
    in a nogil context
    """
    type = c_bint_type
    def analyse_types(self, env): ...
    has_gil: Incomplete
    def generate_result_code(self, code) -> None: ...
    def calculate_result_code(self): ...
