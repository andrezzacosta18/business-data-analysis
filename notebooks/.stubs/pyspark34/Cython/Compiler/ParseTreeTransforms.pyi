from . import Builtin as Builtin, Errors as Errors, ExprNodes as ExprNodes, Naming as Naming, Nodes as Nodes, Options as Options, PyrexTypes as PyrexTypes
from .Code import UtilityCode as UtilityCode
from .Errors import CompileError as CompileError, InternalError as InternalError, error as error, warning as warning
from .StringEncoding import EncodedString as EncodedString
from .TreeFragment import TreeFragment as TreeFragment
from .UtilNodes import LetNode as LetNode, LetRefNode as LetRefNode
from .Visitor import CythonTransform as CythonTransform, EnvTransform as EnvTransform, ScopeTrackingTransform as ScopeTrackingTransform, TreeVisitor as TreeVisitor, VisitorTransform as VisitorTransform
from _typeshed import Incomplete

class SkipDeclarations:
    """
    Variable and function declarations can often have a deep tree structure,
    and yet most transformations don't need to descend to this depth.

    Declaration nodes are removed after AnalyseDeclarationsTransform, so there
    is no need to use this for transformations after that point.
    """
    def visit_CTypeDefNode(self, node): ...
    def visit_CVarDefNode(self, node): ...
    def visit_CDeclaratorNode(self, node): ...
    def visit_CBaseTypeNode(self, node): ...
    def visit_CEnumDefNode(self, node): ...
    def visit_CStructOrUnionDefNode(self, node): ...
    def visit_CppClassNode(self, node): ...

class NormalizeTree(CythonTransform):
    '''
    This transform fixes up a few things after parsing
    in order to make the parse tree more suitable for
    transforms.

    a) After parsing, blocks with only one statement will
    be represented by that statement, not by a StatListNode.
    When doing transforms this is annoying and inconsistent,
    as one cannot in general remove a statement in a consistent
    way and so on. This transform wraps any single statements
    in a StatListNode containing a single statement.

    b) The PassStatNode is a noop and serves no purpose beyond
    plugging such one-statement blocks; i.e., once parsed a
`    "pass" can just as well be represented using an empty
    StatListNode. This means less special cases to worry about
    in subsequent transforms (one always checks to see if a
    StatListNode has no children to see if the block is empty).
    '''
    is_in_statlist: bool
    is_in_expr: bool
    def __init__(self, context) -> None: ...
    def visit_ModuleNode(self, node): ...
    def visit_ExprNode(self, node): ...
    def visit_StatNode(self, node, is_listcontainer: bool = False): ...
    def visit_StatListNode(self, node): ...
    def visit_ParallelAssignmentNode(self, node): ...
    def visit_CEnumDefNode(self, node): ...
    def visit_CStructOrUnionDefNode(self, node): ...
    def visit_PassStatNode(self, node):
        """Eliminate PassStatNode"""
    def visit_ExprStatNode(self, node):
        """Eliminate useless string literals"""
    def visit_CDeclaratorNode(self, node): ...

class PostParseError(CompileError): ...

ERR_CDEF_INCLASS: str
ERR_BUF_DEFAULTS: str
ERR_INVALID_SPECIALATTR_TYPE: str

class PostParse(ScopeTrackingTransform):
    '''
    Basic interpretation of the parse tree, as well as validity
    checking that can be done on a very basic level on the parse
    tree (while still not being a problem with the basic syntax,
    as such).

    Specifically:
    - Default values to cdef assignments are turned into single
    assignments following the declaration (everywhere but in class
    bodies, where they raise a compile error)

    - Interpret some node structures into Python runtime values.
    Some nodes take compile-time arguments (currently:
    TemplatedTypeNode[args] and __cythonbufferdefaults__ = {args}),
    which should be interpreted. This happens in a general way
    and other steps should be taken to ensure validity.

    Type arguments cannot be interpreted in this way.

    - For __cythonbufferdefaults__ the arguments are checked for
    validity.

    TemplatedTypeNode has its directives interpreted:
    Any first positional argument goes into the "dtype" attribute,
    any "ndim" keyword argument goes into the "ndim" attribute and
    so on. Also it is checked that the directive combination is valid.
    - __cythonbufferdefaults__ attributes are parsed and put into the
    type information.

    Note: Currently Parsing.py does a lot of interpretation and
    reorganization that can be refactored into this transform
    if a more pure Abstract Syntax Tree is wanted.

    - Some invalid uses of := assignment expressions are detected
    '''
    specialattribute_handlers: Incomplete
    def __init__(self, context) -> None: ...
    def visit_LambdaNode(self, node): ...
    def visit_GeneratorExpressionNode(self, node): ...
    def visit_ComprehensionNode(self, node): ...
    def handle_bufferdefaults(self, decl) -> None: ...
    def visit_CVarDefNode(self, node): ...
    def visit_SingleAssignmentNode(self, node): ...
    def visit_CascadedAssignmentNode(self, node): ...
    def visit_DelStatNode(self, node): ...
    def visit_ExceptClauseNode(self, node): ...
    def visit_AssertStatNode(self, node):
        """Extract the exception raising into a RaiseStatNode to simplify GIL handling.
        """

class _AssignmentExpressionTargetNameFinder(TreeVisitor):
    target_names: Incomplete
    def __init__(self) -> None: ...
    def find_target_names(self, target): ...
    def visit_ForInStatNode(self, node) -> None: ...
    def visit_ComprehensionNode(self, node) -> None: ...
    def visit_LambdaNode(self, node) -> None: ...
    def visit_Node(self, node) -> None: ...

class _AssignmentExpressionChecker(TreeVisitor):
    """
    Enforces rules on AssignmentExpressions within generator expressions and comprehensions
    """
    target_names_dict: Incomplete
    in_iterator: bool
    in_nested_generator: bool
    scope_is_class: Incomplete
    current_target_names: Incomplete
    all_target_names: Incomplete
    def __init__(self, loop_node, scope_is_class) -> None: ...
    @classmethod
    def do_checks(cls, loop_node, scope_is_class) -> None: ...
    def visit_ForInStatNode(self, node) -> None: ...
    def visit_AssignmentExpressionNode(self, node) -> None: ...
    def visit_LambdaNode(self, node) -> None: ...
    def visit_ComprehensionNode(self, node) -> None: ...
    def visit_GeneratorExpressionNode(self, node) -> None: ...
    def visit_Node(self, node) -> None: ...

def eliminate_rhs_duplicates(expr_list_list, ref_node_sequence):
    """Replace rhs items by LetRefNodes if they appear more than once.
    Creates a sequence of LetRefNodes that set up the required temps
    and appends them to ref_node_sequence.  The input list is modified
    in-place.
    """
def sort_common_subsequences(items):
    """Sort items/subsequences so that all items and subsequences that
    an item contains appear before the item itself.  This is needed
    because each rhs item must only be evaluated once, so its value
    must be evaluated first and then reused when packing sequences
    that contain it.

    This implies a partial order, and the sort must be stable to
    preserve the original order as much as possible, so we use a
    simple insertion sort (which is very fast for short sequences, the
    normal case in practice).
    """
def unpack_string_to_character_literals(literal): ...
def flatten_parallel_assignments(input, output) -> None: ...
def map_starred_assignment(lhs_targets, starred_assignments, lhs_args, rhs_args) -> None: ...

class PxdPostParse(CythonTransform, SkipDeclarations):
    '''
    Basic interpretation/validity checking that should only be
    done on pxd trees.

    A lot of this checking currently happens in the parser; but
    what is listed below happens here.

    - "def" functions are let through only if they fill the
    getbuffer/releasebuffer slots

    - cdef functions are let through only if they are on the
    top level and are declared "inline"
    '''
    ERR_INLINE_ONLY: str
    ERR_NOGO_WITH_INLINE: str
    scope_type: str
    def __call__(self, node): ...
    def visit_CClassDefNode(self, node): ...
    def visit_FuncDefNode(self, node): ...

class TrackNumpyAttributes(VisitorTransform, SkipDeclarations):
    numpy_module_names: Incomplete
    def __init__(self) -> None: ...
    def visit_CImportStatNode(self, node): ...
    def visit_AttributeNode(self, node): ...
    visit_Node: Incomplete

class InterpretCompilerDirectives(CythonTransform):
    '''
    After parsing, directives can be stored in a number of places:
    - #cython-comments at the top of the file (stored in ModuleNode)
    - Command-line arguments overriding these
    - @cython.directivename decorators
    - with cython.directivename: statements
    - replaces "cython.compiled" with BoolNode(value=True)
      allowing unreachable blocks to be removed at a fairly early stage
      before cython typing rules are forced on applied

    This transform is responsible for interpreting these various sources
    and store the directive in two ways:
    - Set the directives attribute of the ModuleNode for global directives.
    - Use a CompilerDirectivesNode to override directives for a subtree.

    (The first one is primarily to not have to modify with the tree
    structure, so that ModuleNode stay on top.)

    The directives are stored in dictionaries from name to value in effect.
    Each such dictionary is always filled in for all possible directives,
    using default values where no value is given by the user.

    The available directives are controlled in Options.py.

    Note that we have to run this prior to analysis, and so some minor
    duplication of functionality has to occur: We manually track cimports
    and which names the "cython" module may have been imported to.
    '''
    unop_method_nodes: Incomplete
    binop_method_nodes: Incomplete
    special_methods: Incomplete
    valid_cython_submodules: Incomplete
    valid_parallel_directives: Incomplete
    cython_module_names: Incomplete
    directive_names: Incomplete
    parallel_directives: Incomplete
    directives: Incomplete
    def __init__(self, context, compilation_directive_defaults) -> None: ...
    def check_directive_scope(self, pos, directive, scope): ...
    module_scope: Incomplete
    def visit_ModuleNode(self, node): ...
    def visit_CompilerDirectivesNode(self, node): ...
    def is_cython_directive(self, name): ...
    def is_parallel_directive(self, full_name, pos):
        """
        Checks to see if fullname (e.g. cython.parallel.prange) is a valid
        parallel directive. If it is a star import it also updates the
        parallel_directives.
        """
    def visit_CImportStatNode(self, node): ...
    def visit_FromCImportStatNode(self, node): ...
    def visit_FromImportStatNode(self, node): ...
    def visit_SingleAssignmentNode(self, node): ...
    def visit_NameNode(self, node): ...
    def visit_AttributeNode(self, node): ...
    def visit_AnnotationNode(self, node): ...
    def visit_NewExprNode(self, node): ...
    def try_to_parse_directives(self, node): ...
    def try_to_parse_directive(self, optname, args, kwds, pos): ...
    def visit_with_directives(self, node, directives, contents_directives): ...
    def visit_FuncDefNode(self, node): ...
    def visit_CVarDefNode(self, node): ...
    def visit_CClassDefNode(self, node): ...
    def visit_CppClassNode(self, node): ...
    def visit_PyClassDefNode(self, node): ...
    def visit_WithStatNode(self, node): ...

class ParallelRangeTransform(CythonTransform, SkipDeclarations):
    """
    Transform cython.parallel stuff. The parallel_directives come from the
    module node, set there by InterpretCompilerDirectives.

        x = cython.parallel.threadavailable()   -> ParallelThreadAvailableNode
        with nogil, cython.parallel.parallel(): -> ParallelWithBlockNode
            print cython.parallel.threadid()    -> ParallelThreadIdNode
            for i in cython.parallel.prange(...):  -> ParallelRangeNode
                ...
    """
    parallel_directive: Incomplete
    namenode_is_cython_module: bool
    in_context_manager_section: bool
    state: Incomplete
    directive_to_node: Incomplete
    def node_is_parallel_directive(self, node): ...
    def get_directive_class_node(self, node):
        """
        Figure out which parallel directive was used and return the associated
        Node class.

        E.g. for a cython.parallel.prange() call we return ParallelRangeNode
        """
    parallel_directives: Incomplete
    def visit_ModuleNode(self, node):
        """
        If any parallel directives were imported, copy them over and visit
        the AST
        """
    def visit_NameNode(self, node): ...
    def visit_AttributeNode(self, node): ...
    def visit_CallNode(self, node): ...
    def visit_WithStatNode(self, node):
        """Rewrite with cython.parallel.parallel() blocks"""
    def visit_ForInStatNode(self, node):
        """Rewrite 'for i in cython.parallel.prange(...):'"""
    def visit(self, node):
        """Visit a node that may be None"""

class WithTransform(VisitorTransform, SkipDeclarations):
    def visit_WithStatNode(self, node): ...
    def visit_ExprNode(self, node): ...
    visit_Node: Incomplete

class _GeneratorExpressionArgumentsMarker(TreeVisitor, SkipDeclarations):
    gen_expr: Incomplete
    def __init__(self, gen_expr) -> None: ...
    def visit_ExprNode(self, node) -> None: ...
    def visit_Node(self, node) -> None: ...
    def visit_GeneratorExpressionNode(self, node) -> None: ...

class _HandleGeneratorArguments(VisitorTransform, SkipDeclarations):
    gen_node: Incomplete
    args: Incomplete
    call_parameters: Incomplete
    tag_count: int
    substitutions: Incomplete
    def __call__(self, node): ...
    def visit_GeneratorExpressionNode(self, node): ...
    def visit_ExprNode(self, node): ...
    visit_Node: Incomplete

class DecoratorTransform(ScopeTrackingTransform, SkipDeclarations):
    """
    Transforms method decorators in cdef classes into nested calls or properties.

    Python-style decorator properties are transformed into a PropertyNode
    with up to the three getter, setter and deleter DefNodes.
    The functional style isn't supported yet.
    """
    def visit_CClassDefNode(self, node): ...
    def visit_PropertyNode(self, node): ...
    def visit_CFuncDefNode(self, node): ...
    def visit_DefNode(self, node): ...
    @staticmethod
    def chain_decorators(node, decorators, name):
        """
        Decorators are applied directly in DefNode and PyClassDefNode to avoid
        reassignments to the function/class name - except for cdef class methods.
        For those, the reassignment is required as methods are originally
        defined in the PyMethodDef struct.

        The IndirectionNode allows DefNode to override the decorator.
        """

class CnameDirectivesTransform(CythonTransform, SkipDeclarations):
    """
    Only part of the CythonUtilityCode pipeline. Must be run before
    DecoratorTransform in case this is a decorator for a cdef class.
    It filters out @cname('my_cname') decorators and rewrites them to
    CnameDecoratorNodes.
    """
    def handle_function(self, node): ...
    visit_FuncDefNode = handle_function
    visit_CClassDefNode = handle_function
    visit_CEnumDefNode = handle_function
    visit_CStructOrUnionDefNode = handle_function

class ForwardDeclareTypes(CythonTransform):
    """
    Declare all global cdef names that we allow referencing in other places,
    before declaring everything (else) in source code order.
    """
    def visit_CompilerDirectivesNode(self, node): ...
    module_scope: Incomplete
    def visit_ModuleNode(self, node): ...
    def visit_CDefExternNode(self, node): ...
    def visit_CEnumDefNode(self, node): ...
    def visit_CStructOrUnionDefNode(self, node): ...
    def visit_CClassDefNode(self, node): ...
    def visit_FuncDefNode(self, node): ...
    def visit_PyClassDefNode(self, node): ...

class AnalyseDeclarationsTransform(EnvTransform):
    basic_property: Incomplete
    basic_pyobject_property: Incomplete
    basic_property_ro: Incomplete
    struct_or_union_wrapper: Incomplete
    init_assignment: Incomplete
    fused_function: Incomplete
    in_lambda: int
    seen_vars_stack: Incomplete
    fused_error_funcs: Incomplete
    def __call__(self, root): ...
    def visit_NameNode(self, node): ...
    extra_module_declarations: Incomplete
    def visit_ModuleNode(self, node): ...
    def visit_LambdaNode(self, node): ...
    def visit_CClassDefNode(self, node): ...
    def visit_FuncDefNode(self, node):
        """
        Analyse a function and its body, as that hasn't happened yet.  Also
        analyse the directive_locals set by @cython.locals().

        Then, if we are a function with fused arguments, replace the function
        (after it has declared itself in the symbol table!) with a
        FusedCFuncDefNode, and analyse its children (which are in turn normal
        functions). If we're a normal function, just analyse the body of the
        function.
        """
    def visit_DefNode(self, node): ...
    def visit_GeneratorBodyDefNode(self, node): ...
    def visit_func_outer_attrs(self, node) -> None: ...
    def visit_ScopedExprNode(self, node): ...
    def visit_TempResultFromStatNode(self, node): ...
    def visit_CppClassNode(self, node): ...
    def visit_CStructOrUnionDefNode(self, node): ...
    def visit_CDeclaratorNode(self, node): ...
    def visit_CTypeDefNode(self, node): ...
    def visit_CBaseTypeNode(self, node) -> None: ...
    def visit_CEnumDefNode(self, node): ...
    def visit_CNameDeclaratorNode(self, node): ...
    def visit_CVarDefNode(self, node) -> None: ...
    def visit_CnameDecoratorNode(self, node): ...
    def create_Property(self, entry): ...
    def visit_AssignmentExpressionNode(self, node): ...

class CalculateQualifiedNamesTransform(EnvTransform):
    """
    Calculate and store the '__qualname__' and the global
    module name on some nodes.
    """
    needs_qualname_assignment: bool
    needs_module_assignment: bool
    module_name: Incomplete
    qualified_name: Incomplete
    def visit_ModuleNode(self, node): ...
    def visit_ClassNode(self, node): ...
    def visit_PyClassNamespaceNode(self, node): ...
    def visit_PyCFunctionNode(self, node): ...
    def visit_DefNode(self, node): ...
    def visit_FuncDefNode(self, node): ...
    def generate_assignment(self, node, name, value) -> None: ...
    def visit_ClassDefNode(self, node): ...
    def visit_NameNode(self, node): ...

class AnalyseExpressionsTransform(CythonTransform):
    def visit_ModuleNode(self, node): ...
    def visit_FuncDefNode(self, node): ...
    def visit_ScopedExprNode(self, node): ...
    def visit_IndexNode(self, node):
        """
        Replace index nodes used to specialize cdef functions with fused
        argument types with the Attribute- or NameNode referring to the
        function. We then need to copy over the specialization properties to
        the attribute or name node.

        Because the indexing might be a Python indexing operation on a fused
        function, or (usually) a Cython indexing operation, we need to
        re-analyse the types.
        """

class FindInvalidUseOfFusedTypes(CythonTransform):
    def visit_FuncDefNode(self, node): ...
    def visit_ExprNode(self, node): ...

class ExpandInplaceOperators(EnvTransform):
    def visit_InPlaceAssignmentNode(self, node): ...
    def visit_ExprNode(self, node): ...

class AdjustDefByDirectives(CythonTransform, SkipDeclarations):
    """
    Adjust function and class definitions by the decorator directives:

    @cython.cfunc
    @cython.cclass
    @cython.ccall
    @cython.inline
    @cython.nogil
    """
    converts_to_cclass: Incomplete
    directives: Incomplete
    in_py_class: bool
    def visit_ModuleNode(self, node): ...
    def visit_CompilerDirectivesNode(self, node): ...
    def visit_DefNode(self, node): ...
    def visit_LambdaNode(self, node): ...
    def visit_PyClassDefNode(self, node): ...
    def visit_CClassDefNode(self, node): ...

class AlignFunctionDefinitions(CythonTransform):
    """
    This class takes the signatures from a .pxd file and applies them to
    the def methods in a .py file.
    """
    scope: Incomplete
    def visit_ModuleNode(self, node): ...
    def visit_PyClassDefNode(self, node): ...
    def visit_CClassDefNode(self, node, pxd_def: Incomplete | None = None): ...
    def visit_DefNode(self, node): ...
    def visit_ExprNode(self, node): ...

class AutoCpdefFunctionDefinitions(CythonTransform):
    directives: Incomplete
    imported_names: Incomplete
    scope: Incomplete
    def visit_ModuleNode(self, node): ...
    def visit_DefNode(self, node): ...
    def visit_CClassDefNode(self, node, pxd_def: Incomplete | None = None): ...
    def visit_FromImportStatNode(self, node): ...
    def visit_ExprNode(self, node): ...

class RemoveUnreachableCode(CythonTransform):
    def visit_StatListNode(self, node): ...
    def visit_IfClauseNode(self, node): ...
    def visit_IfStatNode(self, node): ...
    def visit_TryExceptStatNode(self, node): ...
    def visit_TryFinallyStatNode(self, node): ...

class YieldNodeCollector(TreeVisitor):
    yields: Incomplete
    returns: Incomplete
    finallys: Incomplete
    excepts: Incomplete
    has_return_value: bool
    has_yield: bool
    has_await: bool
    def __init__(self) -> None: ...
    def visit_Node(self, node) -> None: ...
    def visit_YieldExprNode(self, node) -> None: ...
    def visit_AwaitExprNode(self, node) -> None: ...
    def visit_ReturnStatNode(self, node) -> None: ...
    def visit_TryFinallyStatNode(self, node) -> None: ...
    def visit_TryExceptStatNode(self, node) -> None: ...
    def visit_ClassDefNode(self, node) -> None: ...
    def visit_FuncDefNode(self, node) -> None: ...
    def visit_LambdaNode(self, node) -> None: ...
    def visit_GeneratorExpressionNode(self, node) -> None: ...
    def visit_CArgDeclNode(self, node) -> None: ...

class MarkClosureVisitor(CythonTransform):
    needs_closure: bool
    def visit_ModuleNode(self, node): ...
    def visit_FuncDefNode(self, node): ...
    def visit_CFuncDefNode(self, node): ...
    def visit_LambdaNode(self, node): ...
    def visit_ClassDefNode(self, node): ...
    def visit_GeneratorExpressionNode(self, node): ...

class CreateClosureClasses(CythonTransform):
    path: Incomplete
    in_lambda: bool
    def __init__(self, context) -> None: ...
    module_scope: Incomplete
    def visit_ModuleNode(self, node): ...
    def find_entries_used_in_closures(self, node): ...
    def create_class_from_scope(self, node, target_module_scope, inner_node: Incomplete | None = None) -> None: ...
    def visit_LambdaNode(self, node): ...
    def visit_FuncDefNode(self, node): ...
    def visit_GeneratorBodyDefNode(self, node): ...
    def visit_CFuncDefNode(self, node): ...
    def visit_GeneratorExpressionNode(self, node): ...

class InjectGilHandling(VisitorTransform, SkipDeclarations):
    """
    Allow certain Python operations inside of nogil blocks by implicitly acquiring the GIL.

    Must run before the AnalyseDeclarationsTransform to make sure the GILStatNodes get
    set up, parallel sections know that the GIL is acquired inside of them, etc.
    """
    nogil: bool
    visit_RaiseStatNode: Incomplete
    visit_PrintStatNode: Incomplete
    def visit_GILStatNode(self, node): ...
    def visit_CFuncDefNode(self, node): ...
    def visit_ParallelRangeNode(self, node): ...
    def visit_ExprNode(self, node): ...
    visit_Node: Incomplete

class GilCheck(VisitorTransform):
    """
    Call `node.gil_check(env)` on each node to make sure we hold the
    GIL when we need it.  Raise an error when on Python operations
    inside a `nogil` environment.

    Additionally, raise exceptions for closely nested with gil or with nogil
    statements. The latter would abort Python.
    """
    env_stack: Incomplete
    nogil: bool
    nogil_declarator_only: bool
    current_gilstat_node_knows_gil_state: bool
    def __call__(self, root): ...
    def visit_FuncDefNode(self, node): ...
    def visit_GILStatNode(self, node): ...
    def visit_ParallelRangeNode(self, node): ...
    def visit_ParallelWithBlockNode(self, node): ...
    def visit_TryFinallyStatNode(self, node):
        """
        Take care of try/finally statements in nogil code sections.
        """
    def visit_GILExitNode(self, node): ...
    def visit_Node(self, node): ...

class CoerceCppTemps(EnvTransform, SkipDeclarations):
    """
    For temporary expression that are implemented using std::optional it's necessary the temps are
    assigned using `__pyx_t_x = value;` but accessed using `something = (*__pyx_t_x)`. This transform
    inserts a coercion node to take care of this, and runs absolutely last (once nothing else can be
    inserted into the tree)

    TODO: a possible alternative would be to split ExprNode.result() into ExprNode.rhs_rhs() and ExprNode.lhs_rhs()???
    """
    def visit_ModuleNode(self, node): ...
    def visit_ExprNode(self, node): ...

class TransformBuiltinMethods(EnvTransform):
    """
    Replace Cython's own cython.* builtins by the corresponding tree nodes.
    """
    def visit_SingleAssignmentNode(self, node): ...
    def visit_AttributeNode(self, node): ...
    def visit_NameNode(self, node): ...
    def visit_cython_attribute(self, node): ...
    def visit_ExecStatNode(self, node): ...
    def visit_PrimaryCmpNode(self, node): ...
    def visit_CascadedCmpNode(self, node): ...
    def visit_SimpleCallNode(self, node): ...
    def visit_GeneralCallNode(self, node): ...

class ReplaceFusedTypeChecks(VisitorTransform):
    """
    This is not a transform in the pipeline. It is invoked on the specific
    versions of a cdef function with fused argument types. It filters out any
    type branches that don't match. e.g.

        if fused_t is mytype:
            ...
        elif fused_t in other_fused_type:
            ...
    """
    local_scope: Incomplete
    transform: Incomplete
    def __init__(self, local_scope) -> None: ...
    def visit_IfStatNode(self, node):
        """
        Filters out any if clauses with false compile time type check
        expression.
        """
    def visit_GILStatNode(self, node):
        """
        Fold constant condition of GILStatNode.
        """
    def visit_PrimaryCmpNode(self, node): ...
    def specialize_type(self, type, pos): ...
    def visit_Node(self, node): ...

class DebugTransform(CythonTransform):
    """
    Write debug information for this Cython module.
    """
    visited: Incomplete
    tb: Incomplete
    c_output_file: Incomplete
    nested_funcdefs: Incomplete
    register_stepinto: bool
    def __init__(self, context, options, result) -> None: ...
    def visit_ModuleNode(self, node): ...
    def visit_FuncDefNode(self, node): ...
    def visit_NameNode(self, node): ...
    def serialize_modulenode_as_function(self, node) -> None:
        '''
        Serialize the module-level code as a function so the debugger will know
        it\'s a "relevant frame" and it will know where to set the breakpoint
        for \'break modulename\'.
        '''
    def serialize_local_variables(self, entries) -> None: ...
