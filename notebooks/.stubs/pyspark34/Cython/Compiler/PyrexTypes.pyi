from . import Naming as Naming, StringEncoding as StringEncoding
from .Code import LazyUtilityCode as LazyUtilityCode, TempitaUtilityCode as TempitaUtilityCode, UtilityCode as UtilityCode
from .Errors import CannotSpecialize as CannotSpecialize, error as error, performance_hint as performance_hint
from Cython.Utils import cached_function as cached_function
from _typeshed import Incomplete

class BaseType:
    subtypes: Incomplete
    default_format_spec: Incomplete
    def can_coerce_to_pyobject(self, env): ...
    def can_coerce_from_pyobject(self, env): ...
    def can_coerce_to_pystring(self, env, format_spec: Incomplete | None = None): ...
    def convert_to_pystring(self, cvalue, code, format_spec: Incomplete | None = None) -> None: ...
    def cast_code(self, expr_code): ...
    def empty_declaration_code(self, pyrex: bool = False): ...
    def specialization_name(self): ...
    def base_declaration_code(self, base_code, entity_code): ...
    def __deepcopy__(self, memo):
        """
        Types never need to be copied, if we do copy, Unfortunate Things
        Will Happen!
        """
    def get_fused_types(self, result: Incomplete | None = None, seen: Incomplete | None = None, subtypes: Incomplete | None = None, include_function_return_type: bool = False): ...
    def specialize_fused(self, env): ...
    @property
    def is_fused(self):
        """
        Whether this type or any of its subtypes is a fused type
        """
    def deduce_template_params(self, actual):
        """
        Deduce any template params in this (argument) type given the actual
        argument type.

        https://en.cppreference.com/w/cpp/language/function_template#Template_argument_deduction
        """
    def __lt__(self, other):
        """
        For sorting. The sorting order should correspond to the preference of
        conversion from Python types.

        Override to provide something sensible. This is only implemented so that
        python 3 doesn't trip
        """
    def py_type_name(self) -> None:
        """
        Return the name of the Python type that can coerce to this type.
        """
    def typeof_name(self):
        """
        Return the string with which fused python functions can be indexed.
        """
    def check_for_null_code(self, cname) -> None:
        """
        Return the code for a NULL-check in case an UnboundLocalError should
        be raised if an entry of this type is referenced before assignment.
        Returns None if no check should be performed.
        """
    def invalid_value(self) -> None:
        """
        Returns the most invalid value an object of this type can assume as a
        C expression string. Returns None if no such value exists.
        """

class PyrexType(BaseType):
    is_pyobject: int
    is_unspecified: int
    is_extension_type: int
    is_final_type: int
    is_builtin_type: int
    is_cython_builtin_type: int
    is_numeric: int
    is_int: int
    is_float: int
    is_complex: int
    is_void: int
    is_array: int
    is_ptr: int
    is_null_ptr: int
    is_reference: int
    is_fake_reference: int
    is_rvalue_reference: int
    is_const: int
    is_volatile: int
    is_cv_qualified: int
    is_cfunction: int
    is_struct_or_union: int
    is_cpp_class: int
    is_optional_cpp_class: int
    python_type_constructor_name: Incomplete
    is_cpp_string: int
    is_struct: int
    is_enum: int
    is_cpp_enum: bool
    is_typedef: int
    is_string: int
    is_pyunicode_ptr: int
    is_unicode_char: int
    is_returncode: int
    is_error: int
    is_buffer: int
    is_ctuple: int
    is_memoryviewslice: int
    is_pythran_expr: int
    is_numpy_buffer: int
    has_attributes: int
    needs_cpp_construction: int
    needs_refcounting: int
    refcounting_needs_gil: bool
    equivalent_type: Incomplete
    default_value: str
    declaration_value: str
    def resolve(self): ...
    def specialize(self, values): ...
    def literal_code(self, value): ...
    def same_as(self, other_type, **kwds): ...
    def same_as_resolved_type(self, other_type): ...
    def subtype_of(self, other_type): ...
    def subtype_of_resolved_type(self, other_type): ...
    def assignable_from(self, src_type): ...
    def assignable_from_resolved_type(self, src_type): ...
    def assignment_failure_extra_info(self, src_type):
        """Override if you can useful provide extra
        information about why an assignment didn't work."""
    def as_argument_type(self): ...
    def is_complete(self): ...
    def is_simple_buffer_dtype(self): ...
    def can_be_optional(self):
        """Returns True if type can be used with typing.Optional[]."""
    def struct_nesting_depth(self): ...
    def global_init_code(self, entry, code) -> None: ...
    def needs_nonecheck(self): ...
    generate_incref: Incomplete
    generate_xincref: Incomplete
    generate_decref: Incomplete
    generate_xdecref: Incomplete
    generate_decref_clear: Incomplete
    generate_xdecref_clear: Incomplete
    generate_gotref: Incomplete
    generate_xgotref: Incomplete
    generate_giveref: Incomplete
    generate_xgiveref: Incomplete
    generate_decref_set: Incomplete
    generate_xdecref_set: Incomplete
    def nullcheck_string(self, code, cname) -> None: ...
    def cpp_optional_declaration_code(self, entity_code, dll_linkage: Incomplete | None = None) -> None: ...

def public_decl(base_code, dll_linkage): ...
def create_typedef_type(name, base_type, cname, is_external: int = 0, namespace: Incomplete | None = None): ...

class CTypedefType(BaseType):
    is_typedef: int
    typedef_is_external: int
    to_py_utility_code: Incomplete
    from_py_utility_code: Incomplete
    subtypes: Incomplete
    typedef_name: Incomplete
    typedef_cname: Incomplete
    typedef_base_type: Incomplete
    typedef_namespace: Incomplete
    def __init__(self, name, base_type, cname, is_external: int = 0, namespace: Incomplete | None = None) -> None: ...
    def invalid_value(self): ...
    def resolve(self): ...
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...
    def as_argument_type(self): ...
    def cast_code(self, expr_code): ...
    def specialize(self, values): ...
    to_py_function: Incomplete
    def create_to_py_utility_code(self, env): ...
    from_py_function: Incomplete
    def create_from_py_utility_code(self, env): ...
    def to_py_call_code(self, source_code, result_code, result_type, to_py_function: Incomplete | None = None): ...
    def from_py_call_code(self, source_code, result_code, error_pos, code, from_py_function: Incomplete | None = None, error_condition: Incomplete | None = None, special_none_cvalue: Incomplete | None = None): ...
    def overflow_check_binop(self, binop, env, const_rhs: bool = False): ...
    def error_condition(self, result_code): ...
    def __getattr__(self, name): ...
    def py_type_name(self): ...
    def can_coerce_to_pyobject(self, env): ...
    def can_coerce_from_pyobject(self, env): ...

class MemoryViewSliceType(PyrexType):
    is_memoryviewslice: int
    default_value: str
    has_attributes: int
    needs_refcounting: int
    refcounting_needs_gil: bool
    scope: Incomplete
    from_py_function: Incomplete
    to_py_function: Incomplete
    exception_value: Incomplete
    exception_check: bool
    subtypes: Incomplete
    dtype: Incomplete
    axes: Incomplete
    ndim: Incomplete
    flags: Incomplete
    mode: Incomplete
    writable_needed: bool
    dtype_name: Incomplete
    def __init__(self, base_dtype, axes) -> None:
        """
        MemoryViewSliceType(base, axes)

        Base is the C base type; axes is a list of (access, packing) strings,
        where access is one of 'full', 'direct' or 'ptr' and packing is one of
        'contig', 'strided' or 'follow'.  There is one (access, packing) tuple
        for each dimension.

        the access specifiers determine whether the array data contains
        pointers that need to be dereferenced along that axis when
        retrieving/setting:

        'direct' -- No pointers stored in this dimension.
        'ptr' -- Pointer stored in this dimension.
        'full' -- Check along this dimension, don't assume either.

        the packing specifiers specify how the array elements are laid-out
        in memory.

        'contig' -- The data is contiguous in memory along this dimension.
                At most one dimension may be specified as 'contig'.
        'strided' -- The data isn't contiguous along this dimension.
        'follow' -- Used for C/Fortran contiguous arrays, a 'follow' dimension
            has its stride automatically computed from extents of the other
            dimensions to ensure C or Fortran memory layout.

        C-contiguous memory has 'direct' as the access spec, 'contig' as the
        *last* axis' packing spec and 'follow' for all other packing specs.

        Fortran-contiguous memory has 'direct' as the access spec, 'contig' as
        the *first* axis' packing spec and 'follow' for all other packing
        specs.
        """
    def __hash__(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def same_as_resolved_type(self, other_type): ...
    def needs_nonecheck(self): ...
    def is_complete(self): ...
    def can_be_optional(self):
        """Returns True if type can be used with typing.Optional[]."""
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...
    def attributes_known(self): ...
    def declare_attribute(self, attribute, env, pos): ...
    def get_entry(self, node, cname: Incomplete | None = None, type: Incomplete | None = None): ...
    def conforms_to(self, dst, broadcast: bool = False, copying: bool = False):
        """
        Returns True if src conforms to dst, False otherwise.

        If conformable, the types are the same, the ndims are equal, and each axis spec is conformable.

        Any packing/access spec is conformable to itself.

        'direct' and 'ptr' are conformable to 'full'.
        'contig' and 'follow' are conformable to 'strided'.
        Any other combo is not conformable.
        """
    def valid_dtype(self, dtype, i: int = 0):
        """
        Return whether type dtype can be used as the base type of a
        memoryview slice.

        We support structs, numeric types and objects
        """
    def validate_memslice_dtype(self, pos) -> None: ...
    def assert_direct_dims(self, pos): ...
    def transpose(self, pos): ...
    def specialization_name(self): ...
    def specialization_suffix(self): ...
    def can_coerce_to_pyobject(self, env): ...
    def can_coerce_from_pyobject(self, env): ...
    def check_for_null_code(self, cname): ...
    def create_from_py_utility_code(self, env): ...
    def from_py_call_code(self, source_code, result_code, error_pos, code, from_py_function: Incomplete | None = None, error_condition: Incomplete | None = None, special_none_cvalue: Incomplete | None = None): ...
    def create_to_py_utility_code(self, env): ...
    def to_py_call_code(self, source_code, result_code, result_type, to_py_function: Incomplete | None = None): ...
    def dtype_object_conversion_funcs(self, env): ...
    def axes_to_code(self):
        """Return a list of code constants for each axis"""
    def axes_to_name(self):
        """Return an abbreviated name for our axes"""
    def error_condition(self, result_code): ...
    def specialize(self, values):
        """This does not validate the base type!!"""
    def cast_code(self, expr_code): ...
    def generate_incref(self, code, name, **kwds) -> None: ...
    def generate_incref_memoryviewslice(self, code, slice_cname, have_gil) -> None: ...
    def generate_xdecref(self, code, cname, nanny, have_gil) -> None: ...
    def generate_decref(self, code, cname, nanny, have_gil) -> None: ...
    def generate_xdecref_clear(self, code, cname, clear_before_decref, **kwds) -> None: ...
    def generate_decref_clear(self, code, cname, **kwds) -> None: ...
    generate_gotref: Incomplete
    generate_xgotref: Incomplete
    generate_xgiveref: Incomplete
    generate_giveref: Incomplete

class BufferType(BaseType):
    is_buffer: int
    writable: bool
    subtypes: Incomplete
    base: Incomplete
    dtype: Incomplete
    ndim: Incomplete
    buffer_ptr_type: Incomplete
    mode: Incomplete
    negative_indices: Incomplete
    cast: Incomplete
    is_numpy_buffer: Incomplete
    def __init__(self, base, dtype, ndim, mode, negative_indices, cast) -> None: ...
    def can_coerce_to_pyobject(self, env): ...
    def can_coerce_from_pyobject(self, env): ...
    def as_argument_type(self): ...
    def specialize(self, values): ...
    def get_entry(self, node): ...
    def __getattr__(self, name): ...
    def assignable_from(self, other_type): ...
    def same_as(self, other_type, compare_base: bool = True): ...

class PyObjectType(PyrexType):
    name: str
    is_pyobject: int
    default_value: str
    declaration_value: str
    buffer_defaults: Incomplete
    is_extern: bool
    is_subclassed: bool
    is_gc_simple: bool
    builtin_trashcan: bool
    needs_refcounting: bool
    def can_coerce_to_pyobject(self, env): ...
    def can_coerce_from_pyobject(self, env): ...
    def can_be_optional(self):
        """Returns True if type can be used with typing.Optional[]."""
    def default_coerced_ctype(self) -> None:
        """The default C type that this Python type coerces to, or None."""
    def assignable_from(self, src_type): ...
    def is_simple_buffer_dtype(self): ...
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...
    def as_pyobject(self, cname): ...
    def py_type_name(self): ...
    def __lt__(self, other):
        """
        Make sure we sort highest, as instance checking on py_type_name
        ('object') is always true
        """
    def global_init_code(self, entry, code) -> None: ...
    def check_for_null_code(self, cname): ...
    def generate_incref(self, code, cname, nanny) -> None: ...
    def generate_xincref(self, code, cname, nanny) -> None: ...
    def generate_decref(self, code, cname, nanny, have_gil) -> None: ...
    def generate_xdecref(self, code, cname, nanny, have_gil) -> None: ...
    def generate_decref_clear(self, code, cname, clear_before_decref, nanny, have_gil) -> None: ...
    def generate_xdecref_clear(self, code, cname, clear_before_decref: bool = False, nanny: bool = True, have_gil: Incomplete | None = None) -> None: ...
    def generate_gotref(self, code, cname) -> None: ...
    def generate_xgotref(self, code, cname) -> None: ...
    def generate_giveref(self, code, cname) -> None: ...
    def generate_xgiveref(self, code, cname) -> None: ...
    def generate_decref_set(self, code, cname, rhs_cname) -> None: ...
    def generate_xdecref_set(self, code, cname, rhs_cname) -> None: ...
    def nullcheck_string(self, cname): ...

builtin_types_that_cannot_create_refcycles: Incomplete
builtin_types_with_trashcan: Incomplete

class BuiltinObjectType(PyObjectType):
    is_builtin_type: int
    has_attributes: int
    base_type: Incomplete
    module_name: str
    require_exact: int
    vtabslot_cname: Incomplete
    vtabstruct_cname: Incomplete
    vtabptr_cname: Incomplete
    typedef_flag: bool
    is_external: bool
    decl_type: str
    name: Incomplete
    cname: Incomplete
    typeptr_cname: Incomplete
    objstruct_cname: Incomplete
    is_gc_simple: Incomplete
    builtin_trashcan: Incomplete
    def __init__(self, name, cname, objstruct_cname: Incomplete | None = None) -> None: ...
    scope: Incomplete
    def set_scope(self, scope) -> None: ...
    def default_coerced_ctype(self): ...
    def assignable_from(self, src_type): ...
    def typeobj_is_available(self): ...
    def attributes_known(self): ...
    def subtype_of(self, type): ...
    def type_check_function(self, exact: bool = True): ...
    def isinstance_code(self, arg): ...
    def type_test_code(self, arg, notnone: bool = False, exact: bool = True): ...
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...
    def as_pyobject(self, cname): ...
    def cast_code(self, expr_code, to_object_struct: bool = False): ...
    def py_type_name(self): ...

class PyExtensionType(PyObjectType):
    is_extension_type: int
    has_attributes: int
    early_init: int
    objtypedef_cname: Incomplete
    dataclass_fields: Incomplete
    multiple_bases: bool
    has_sequence_flag: bool
    name: Incomplete
    scope: Incomplete
    typedef_flag: Incomplete
    base_type: Incomplete
    module_name: Incomplete
    objstruct_cname: Incomplete
    typeobj_cname: Incomplete
    typeptr_cname: Incomplete
    vtabslot_cname: Incomplete
    vtabstruct_cname: Incomplete
    vtabptr_cname: Incomplete
    vtable_cname: Incomplete
    is_external: Incomplete
    check_size: Incomplete
    defered_declarations: Incomplete
    def __init__(self, name, typedef_flag, base_type, is_external: int = 0, check_size: Incomplete | None = None) -> None: ...
    def set_scope(self, scope) -> None: ...
    def needs_nonecheck(self): ...
    def subtype_of_resolved_type(self, other_type): ...
    def typeobj_is_available(self): ...
    def typeobj_is_imported(self): ...
    def assignable_from(self, src_type): ...
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0, deref: int = 0): ...
    def type_test_code(self, py_arg, notnone: bool = False): ...
    def attributes_known(self): ...
    def py_type_name(self): ...

class CType(PyrexType):
    to_py_function: Incomplete
    from_py_function: Incomplete
    exception_value: Incomplete
    exception_check: int
    def create_to_py_utility_code(self, env): ...
    def create_from_py_utility_code(self, env): ...
    def can_coerce_to_pyobject(self, env): ...
    def can_coerce_from_pyobject(self, env): ...
    def error_condition(self, result_code): ...
    def to_py_call_code(self, source_code, result_code, result_type, to_py_function: Incomplete | None = None): ...
    def from_py_call_code(self, source_code, result_code, error_pos, code, from_py_function: Incomplete | None = None, error_condition: Incomplete | None = None, special_none_cvalue: Incomplete | None = None): ...

class PythranExpr(CType):
    to_py_function: str
    is_pythran_expr: bool
    writable: bool
    has_attributes: int
    org_buffer: Incomplete
    pythran_type: Incomplete
    name: Incomplete
    cname: Incomplete
    from_py_function: Incomplete
    scope: Incomplete
    def __init__(self, pythran_type, org_buffer: Incomplete | None = None) -> None: ...
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...
    def attributes_known(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __hash__(self): ...

class CConstOrVolatileType(BaseType):
    """A C const or volatile type"""
    subtypes: Incomplete
    is_cv_qualified: int
    cv_base_type: Incomplete
    is_const: Incomplete
    is_volatile: Incomplete
    scope: Incomplete
    def __init__(self, base_type, is_const: int = 0, is_volatile: int = 0) -> None: ...
    def cv_string(self): ...
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...
    def specialize(self, values): ...
    def deduce_template_params(self, actual): ...
    def can_coerce_to_pyobject(self, env): ...
    def can_coerce_from_pyobject(self, env): ...
    to_py_function: Incomplete
    def create_to_py_utility_code(self, env): ...
    def same_as_resolved_type(self, other_type): ...
    def __getattr__(self, name): ...

def CConstType(base_type): ...

class FusedType(CType):
    """
    Represents a Fused Type. All it needs to do is keep track of the types
    it aggregates, as it will be replaced with its specific version wherever
    needed.

    See http://wiki.cython.org/enhancements/fusedtypes

    types           [PyrexType]             is the list of types to be fused
    name            str                     the name of the ctypedef
    """
    is_fused: int
    exception_check: int
    types: Incomplete
    name: Incomplete
    def __init__(self, types, name: Incomplete | None = None) -> None: ...
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...
    def specialize(self, values): ...
    def get_fused_types(self, result: Incomplete | None = None, seen: Incomplete | None = None, include_function_return_type: bool = False): ...

class CVoidType(CType):
    is_void: int
    to_py_function: str
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...
    def is_complete(self): ...

class InvisibleVoidType(CVoidType):
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...

class CNumericType(CType):
    is_numeric: int
    default_value: str
    has_attributes: bool
    scope: Incomplete
    sign_words: Incomplete
    rank: Incomplete
    signed: Incomplete
    def __init__(self, rank, signed: int = 1) -> None: ...
    def sign_and_name(self): ...
    def is_simple_buffer_dtype(self): ...
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...
    def attributes_known(self): ...
    def __lt__(self, other):
        """Sort based on rank, preferring signed over unsigned"""
    def py_type_name(self): ...

class ForbidUseClass: ...

ForbidUse: Incomplete

class CIntLike:
    """Mixin for shared behaviour of C integers and enums.
    """
    to_py_function: Incomplete
    from_py_function: Incomplete
    to_pyunicode_utility: Incomplete
    default_format_spec: str
    def can_coerce_to_pyobject(self, env): ...
    def can_coerce_from_pyobject(self, env): ...
    def create_to_py_utility_code(self, env): ...
    def create_from_py_utility_code(self, env): ...
    def can_coerce_to_pystring(self, env, format_spec: Incomplete | None = None): ...
    def convert_to_pystring(self, cvalue, code, format_spec: Incomplete | None = None): ...

class CIntType(CIntLike, CNumericType):
    is_int: int
    typedef_flag: int
    exception_value: int
    def get_to_py_type_conversion(self): ...
    def assignable_from_resolved_type(self, src_type): ...
    def invalid_value(self): ...
    def overflow_check_binop(self, binop, env, const_rhs: bool = False): ...

class CAnonEnumType(CIntType):
    is_enum: int
    def sign_and_name(self): ...
    def specialization_name(self): ...

class CReturnCodeType(CIntType):
    to_py_function: str
    is_returncode: bool
    exception_check: bool
    default_format_spec: str
    def specialization_name(self): ...
    def can_coerce_to_pystring(self, env, format_spec: Incomplete | None = None): ...
    def convert_to_pystring(self, cvalue, code, format_spec: Incomplete | None = None): ...

class CBIntType(CIntType):
    to_py_function: str
    from_py_function: str
    exception_check: int
    default_format_spec: str
    def can_coerce_to_pystring(self, env, format_spec: Incomplete | None = None): ...
    def convert_to_pystring(self, cvalue, code, format_spec: Incomplete | None = None): ...
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...
    def specialization_name(self): ...
    def py_type_name(self): ...

class CPyUCS4IntType(CIntType):
    is_unicode_char: bool
    to_py_function: str
    from_py_function: str
    def can_coerce_to_pystring(self, env, format_spec: Incomplete | None = None): ...
    def create_from_py_utility_code(self, env): ...
    def sign_and_name(self): ...

class CPyUnicodeIntType(CIntType):
    is_unicode_char: bool
    to_py_function: str
    from_py_function: str
    def can_coerce_to_pystring(self, env, format_spec: Incomplete | None = None): ...
    def create_from_py_utility_code(self, env): ...
    def sign_and_name(self): ...

class CPyHashTType(CIntType):
    to_py_function: str
    from_py_function: str
    def sign_and_name(self): ...

class CPySSizeTType(CIntType):
    to_py_function: str
    from_py_function: str
    def sign_and_name(self): ...

class CSSizeTType(CIntType):
    to_py_function: str
    from_py_function: str
    def sign_and_name(self): ...

class CSizeTType(CIntType):
    to_py_function: str
    def sign_and_name(self): ...

class CPtrdiffTType(CIntType):
    def sign_and_name(self): ...

class CFloatType(CNumericType):
    is_float: int
    to_py_function: str
    from_py_function: str
    exception_value: int
    math_h_modifier: Incomplete
    def __init__(self, rank, math_h_modifier: str = '') -> None: ...
    def assignable_from_resolved_type(self, src_type): ...
    def invalid_value(self): ...

class CComplexType(CNumericType):
    is_complex: int
    has_attributes: int
    scope: Incomplete
    @property
    def to_py_function(self): ...
    funcsuffix: Incomplete
    implementation_suffix: str
    math_h_modifier: Incomplete
    real_type: Incomplete
    binops: Incomplete
    from_parts: Incomplete
    default_value: Incomplete
    def __init__(self, real_type) -> None: ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __lt__(self, other): ...
    def __hash__(self): ...
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...
    def sign_and_name(self): ...
    def assignable_from(self, src_type): ...
    def assignable_from_resolved_type(self, src_type): ...
    def attributes_known(self): ...
    def create_declaration_utility_code(self, env): ...
    def can_coerce_to_pyobject(self, env): ...
    def can_coerce_from_pyobject(self, env): ...
    def create_to_py_utility_code(self, env): ...
    from_py_function: Incomplete
    def create_from_py_utility_code(self, env): ...
    def lookup_op(self, nargs, op): ...
    def unary_op(self, op): ...
    def binary_op(self, op): ...
    def py_type_name(self): ...
    def cast_code(self, expr_code): ...
    def real_code(self, expr_code): ...
    def imag_code(self, expr_code): ...

complex_ops: Incomplete

class SoftCComplexType(CComplexType):
    '''
    a**b in Python can return either a complex or a float
    depending on the sign of a. This "soft complex" type is
    stored as a C complex (and so is a little slower than a
    direct C double) but it prints/coerces to a float if
    the imaginary part is 0. Therefore it provides a C
    representation of the Python behaviour.
    '''
    to_py_function: str
    def __init__(self) -> None: ...
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...
    def create_to_py_utility_code(self, env): ...

class CPyTSSTType(CType):
    declaration_value: str
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...

class CPointerBaseType(CType):
    subtypes: Incomplete
    base_type: Incomplete
    is_string: int
    is_pyunicode_ptr: int
    to_py_function: str
    from_py_function: str
    exception_value: str
    def __init__(self, base_type) -> None: ...
    def py_type_name(self): ...
    def literal_code(self, value): ...

class CArrayType(CPointerBaseType):
    is_array: int
    to_tuple_function: Incomplete
    size: Incomplete
    def __init__(self, base_type, size) -> None: ...
    def __eq__(self, other): ...
    def __hash__(self): ...
    def same_as_resolved_type(self, other_type): ...
    def assignable_from_resolved_type(self, src_type): ...
    def element_ptr_type(self): ...
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...
    def as_argument_type(self): ...
    def is_complete(self): ...
    def specialize(self, values): ...
    def deduce_template_params(self, actual): ...
    def can_coerce_to_pyobject(self, env): ...
    def can_coerce_from_pyobject(self, env): ...
    to_py_function: Incomplete
    def create_to_py_utility_code(self, env): ...
    def to_py_call_code(self, source_code, result_code, result_type, to_py_function: Incomplete | None = None): ...
    from_py_function: Incomplete
    def create_from_py_utility_code(self, env): ...
    def from_py_call_code(self, source_code, result_code, error_pos, code, from_py_function: Incomplete | None = None, error_condition: Incomplete | None = None, special_none_cvalue: Incomplete | None = None): ...
    def error_condition(self, result_code): ...

class CPtrType(CPointerBaseType):
    is_ptr: int
    default_value: str
    exception_value: str
    def __hash__(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def same_as_resolved_type(self, other_type): ...
    def is_simple_buffer_dtype(self): ...
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...
    def assignable_from_resolved_type(self, other_type): ...
    def assignment_failure_extra_info(self, src_type): ...
    def specialize(self, values): ...
    def deduce_template_params(self, actual): ...
    def invalid_value(self): ...
    def find_cpp_operation_type(self, operator, operand_type: Incomplete | None = None): ...
    def get_fused_types(self, result: Incomplete | None = None, seen: Incomplete | None = None, include_function_return_type: bool = False): ...

class CNullPtrType(CPtrType):
    is_null_ptr: int

class CReferenceBaseType(BaseType):
    is_fake_reference: int
    subtypes: Incomplete
    ref_base_type: Incomplete
    def __init__(self, base_type) -> None: ...
    def specialize(self, values): ...
    def deduce_template_params(self, actual): ...
    def __getattr__(self, name): ...

class CReferenceType(CReferenceBaseType):
    is_reference: int
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...

class CFakeReferenceType(CReferenceType):
    is_fake_reference: int
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...

class CppRvalueReferenceType(CReferenceBaseType):
    is_rvalue_reference: int
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...

class CFuncType(CType):
    is_cfunction: int
    original_sig: Incomplete
    cached_specialized_types: Incomplete
    from_fused: bool
    is_const_method: bool
    op_arg_struct: Incomplete
    subtypes: Incomplete
    return_type: Incomplete
    args: Incomplete
    has_varargs: Incomplete
    optional_arg_count: Incomplete
    exception_value: Incomplete
    exception_check: Incomplete
    calling_convention: Incomplete
    nogil: Incomplete
    with_gil: Incomplete
    is_overridable: Incomplete
    is_static_method: Incomplete
    templates: Incomplete
    is_strict_signature: Incomplete
    def __init__(self, return_type, args, has_varargs: int = 0, exception_value: Incomplete | None = None, exception_check: int = 0, calling_convention: str = '', nogil: int = 0, with_gil: int = 0, is_overridable: int = 0, optional_arg_count: int = 0, is_const_method: bool = False, is_static_method: bool = False, templates: Incomplete | None = None, is_strict_signature: bool = False) -> None: ...
    def with_with_gil(self, with_gil): ...
    def calling_convention_prefix(self): ...
    def as_argument_type(self): ...
    def same_c_signature_as(self, other_type, as_cmethod: int = 0): ...
    def same_c_signature_as_resolved_type(self, other_type, as_cmethod: bool = False, as_pxd_definition: bool = False, exact_semantics: bool = True): ...
    def compatible_signature_with(self, other_type, as_cmethod: int = 0): ...
    def compatible_signature_with_resolved_type(self, other_type, as_cmethod): ...
    def narrower_c_signature_than(self, other_type, as_cmethod: int = 0): ...
    def narrower_c_signature_than_resolved_type(self, other_type, as_cmethod): ...
    def same_calling_convention_as(self, other): ...
    def same_as_resolved_type(self, other_type, as_cmethod: bool = False): ...
    def pointer_assignable_from_resolved_type(self, rhs_type): ...
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0, with_calling_convention: int = 1): ...
    def function_header_code(self, func_name, arg_code): ...
    def signature_string(self): ...
    def signature_cast_string(self): ...
    def specialize(self, values): ...
    def opt_arg_cname(self, arg_name): ...
    def get_all_specialized_permutations(self, fused_types: Incomplete | None = None):
        """
        Permute all the types. For every specific instance of a fused type, we
        want all other specific instances of all other fused types.

        It returns an iterable of two-tuples of the cname that should prefix
        the cname of the function, and a dict mapping any fused types to their
        respective specific types.
        """
    def get_all_specialized_function_types(self):
        """
        Get all the specific function types of this one.
        """
    def get_fused_types(self, result: Incomplete | None = None, seen: Incomplete | None = None, subtypes: Incomplete | None = None, include_function_return_type: bool = False):
        """Return fused types in the order they appear as parameter types"""
    def specialize_entry(self, entry, cname) -> None: ...
    def can_coerce_to_pyobject(self, env): ...
    name: Incomplete
    type: Incomplete
    to_py_function: Incomplete
    def create_to_py_utility_code(self, env): ...

def specialize_entry(entry, cname) -> None:
    """
    Specialize an entry of a copied fused function or method
    """
def get_fused_cname(fused_cname, orig_cname):
    """
    Given the fused cname id and an original cname, return a specialized cname
    """
def unique(somelist): ...
def get_all_specialized_permutations(fused_types): ...
def specialization_signature_string(fused_compound_type, fused_to_specific):
    """
    Return the signature for a specialization of a fused type. e.g.

        floating[:] ->
            'float' or 'double'

        cdef fused ft:
            float[:]
            double[:]

        ft ->
            'float[:]' or 'double[:]'

        integral func(floating) ->
            'int (*func)(float)' or ...
    """
def get_specialized_types(type):
    """
    Return a list of specialized types in their declared order.
    """

class CFuncTypeArg(BaseType):
    not_none: bool
    or_none: bool
    accept_none: bool
    accept_builtin_subtypes: bool
    annotation: Incomplete
    subtypes: Incomplete
    name: Incomplete
    cname: Incomplete
    type: Incomplete
    pos: Incomplete
    needs_type_test: bool
    def __init__(self, name, type, pos, cname: Incomplete | None = None, annotation: Incomplete | None = None) -> None: ...
    def declaration_code(self, for_display: int = 0): ...
    def specialize(self, values): ...
    def is_forwarding_reference(self): ...

class ToPyStructUtilityCode:
    requires: Incomplete
    type: Incomplete
    header: Incomplete
    forward_decl: Incomplete
    env: Incomplete
    def __init__(self, type, forward_decl, env) -> None: ...
    def __eq__(self, other): ...
    def __hash__(self): ...
    def get_tree(self, **kwargs) -> None: ...
    def put_code(self, output) -> None: ...
    def inject_tree_and_scope_into(self, module_node) -> None: ...

class CStructOrUnionType(CType):
    is_struct_or_union: int
    has_attributes: int
    exception_check: bool
    name: Incomplete
    cname: Incomplete
    kind: Incomplete
    scope: Incomplete
    typedef_flag: Incomplete
    is_struct: Incomplete
    to_py_function: Incomplete
    from_py_function: Incomplete
    packed: Incomplete
    needs_cpp_construction: Incomplete
    def __init__(self, name, kind, scope, typedef_flag, cname, packed: bool = False, in_cpp: bool = False) -> None: ...
    def can_coerce_to_pyobject(self, env): ...
    def create_to_py_utility_code(self, env): ...
    def can_coerce_from_pyobject(self, env): ...
    def create_from_py_utility_code(self, env): ...
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...
    def __eq__(self, other): ...
    def __lt__(self, other): ...
    def __hash__(self): ...
    def is_complete(self): ...
    def attributes_known(self): ...
    def can_be_complex(self): ...
    def struct_nesting_depth(self): ...
    def cast_code(self, expr_code): ...

cpp_string_conversions: Incomplete
builtin_cpp_conversions: Incomplete

class CppClassType(CType):
    is_cpp_class: int
    has_attributes: int
    needs_cpp_construction: int
    exception_check: bool
    namespace: Incomplete
    kind: str
    packed: bool
    typedef_flag: bool
    subtypes: Incomplete
    name: Incomplete
    cname: Incomplete
    scope: Incomplete
    base_classes: Incomplete
    operators: Incomplete
    templates: Incomplete
    template_type: Incomplete
    num_optional_templates: Incomplete
    specializations: Incomplete
    is_cpp_string: Incomplete
    def __init__(self, name, scope, cname, base_classes, templates: Incomplete | None = None, template_type: Incomplete | None = None) -> None: ...
    def use_conversion_utility(self, from_or_to) -> None: ...
    def maybe_unordered(self): ...
    def can_coerce_from_pyobject(self, env): ...
    from_py_function: Incomplete
    def create_from_py_utility_code(self, env): ...
    def can_coerce_to_pyobject(self, env): ...
    to_py_function: Incomplete
    def create_to_py_utility_code(self, env): ...
    def is_template_type(self): ...
    def get_fused_types(self, result: Incomplete | None = None, seen: Incomplete | None = None, include_function_return_type: bool = False): ...
    def specialize_here(self, pos, env, template_values: Incomplete | None = None): ...
    def specialize(self, values): ...
    def deduce_template_params(self, actual): ...
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0, template_params: Incomplete | None = None): ...
    def cpp_optional_declaration_code(self, entity_code, dll_linkage: Incomplete | None = None, template_params: Incomplete | None = None): ...
    def is_subclass(self, other_type): ...
    def subclass_dist(self, super_type): ...
    def same_as_resolved_type(self, other_type): ...
    def assignable_from_resolved_type(self, other_type): ...
    def attributes_known(self): ...
    def find_cpp_operation_type(self, operator, operand_type: Incomplete | None = None): ...
    def get_constructor(self, pos): ...
    def check_nullary_constructor(self, pos, msg: str = 'stack allocated') -> None: ...
    def cpp_optional_check_for_null_code(self, cname): ...

class EnumMixin:
    """
    Common implementation details for C and C++ enums.
    """
    to_py_function: Incomplete
    def create_enum_to_py_utility_code(self, env) -> None: ...

class CppScopedEnumType(CType, EnumMixin):
    is_cpp_enum: bool
    name: Incomplete
    doc: Incomplete
    cname: Incomplete
    values: Incomplete
    underlying_type: Incomplete
    namespace: Incomplete
    def __init__(self, name, cname, underlying_type, namespace: Incomplete | None = None, doc: Incomplete | None = None) -> None: ...
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...
    from_py_function: Incomplete
    def create_from_py_utility_code(self, env): ...
    to_py_function: Incomplete
    def create_to_py_utility_code(self, env): ...
    def create_type_wrapper(self, env) -> None: ...

class TemplatePlaceholderType(CType):
    name: Incomplete
    optional: Incomplete
    def __init__(self, name, optional: bool = False) -> None: ...
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...
    def specialize(self, values): ...
    def deduce_template_params(self, actual): ...
    def same_as_resolved_type(self, other_type): ...
    def __hash__(self): ...
    def __cmp__(self, other): ...
    def __eq__(self, other): ...

def is_optional_template_param(type): ...

class CEnumType(CIntLike, CType, EnumMixin):
    is_enum: int
    signed: int
    rank: int
    name: Incomplete
    doc: Incomplete
    cname: Incomplete
    values: Incomplete
    typedef_flag: Incomplete
    namespace: Incomplete
    default_value: Incomplete
    def __init__(self, name, cname, typedef_flag, namespace: Incomplete | None = None, doc: Incomplete | None = None) -> None: ...
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...
    def specialize(self, values): ...
    to_py_function: Incomplete
    def create_type_wrapper(self, env) -> None: ...
    def create_to_py_utility_code(self, env): ...

class CTupleType(CType):
    is_ctuple: bool
    cname: Incomplete
    components: Incomplete
    size: Incomplete
    to_py_function: Incomplete
    from_py_function: Incomplete
    exception_check: bool
    equivalent_type: Incomplete
    def __init__(self, cname, components) -> None: ...
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...
    def can_coerce_to_pyobject(self, env): ...
    def can_coerce_from_pyobject(self, env): ...
    def create_to_py_utility_code(self, env): ...
    def create_from_py_utility_code(self, env): ...
    def cast_code(self, expr_code): ...

def c_tuple_type(components): ...

class UnspecifiedType(PyrexType):
    is_unspecified: int
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...
    def same_as_resolved_type(self, other_type): ...

class ErrorType(PyrexType):
    is_error: int
    exception_value: str
    exception_check: int
    to_py_function: str
    from_py_function: str
    def create_to_py_utility_code(self, env): ...
    def create_from_py_utility_code(self, env): ...
    def declaration_code(self, entity_code, for_display: int = 0, dll_linkage: Incomplete | None = None, pyrex: int = 0): ...
    def same_as_resolved_type(self, other_type): ...
    def error_condition(self, result_code): ...

class PythonTypeConstructorMixin:
    """Used to help Cython interpret indexed types from the typing module (or similar)
    """
    modifier_name: Incomplete
    python_type_constructor_name: Incomplete
    def set_python_type_constructor_name(self, name) -> None: ...
    def specialize_here(self, pos, env, template_values: Incomplete | None = None): ...
    def is_template_type(self): ...

class BuiltinTypeConstructorObjectType(BuiltinObjectType, PythonTypeConstructorMixin):
    """
    builtin types like list, dict etc which can be subscripted in annotations
    """
    def __init__(self, name, cname, objstruct_cname: Incomplete | None = None) -> None: ...

class PythonTupleTypeConstructor(BuiltinTypeConstructorObjectType):
    def specialize_here(self, pos, env, template_values: Incomplete | None = None): ...

class SpecialPythonTypeConstructor(PyObjectType, PythonTypeConstructorMixin):
    """
    For things like ClassVar, Optional, etc, which are not types and disappear during type analysis.
    """
    modifier_name: Incomplete
    def __init__(self, name) -> None: ...
    def resolve(self): ...
    def specialize_here(self, pos, env, template_values: Incomplete | None = None): ...

rank_to_type_name: Incomplete
RANK_INT: Incomplete
RANK_LONG: Incomplete
RANK_FLOAT: Incomplete
UNSIGNED: int
SIGNED: int
error_type: Incomplete
unspecified_type: Incomplete
py_object_type: Incomplete
c_void_type: Incomplete
c_uchar_type: Incomplete
c_ushort_type: Incomplete
c_uint_type: Incomplete
c_ulong_type: Incomplete
c_ulonglong_type: Incomplete
c_char_type: Incomplete
c_short_type: Incomplete
c_int_type: Incomplete
c_long_type: Incomplete
c_longlong_type: Incomplete
c_schar_type: Incomplete
c_sshort_type: Incomplete
c_sint_type: Incomplete
c_slong_type: Incomplete
c_slonglong_type: Incomplete
c_float_type: Incomplete
c_double_type: Incomplete
c_longdouble_type: Incomplete
c_float_complex_type: Incomplete
c_double_complex_type: Incomplete
c_longdouble_complex_type: Incomplete
soft_complex_type: Incomplete
c_anon_enum_type: Incomplete
c_returncode_type: Incomplete
c_bint_type: Incomplete
c_py_unicode_type: Incomplete
c_py_ucs4_type: Incomplete
c_py_hash_t_type: Incomplete
c_py_ssize_t_type: Incomplete
c_ssize_t_type: Incomplete
c_size_t_type: Incomplete
c_ptrdiff_t_type: Incomplete
c_null_ptr_type: Incomplete
c_void_ptr_type: Incomplete
c_void_ptr_ptr_type: Incomplete
c_char_ptr_type: Incomplete
c_const_char_ptr_type: Incomplete
c_uchar_ptr_type: Incomplete
c_const_uchar_ptr_type: Incomplete
c_char_ptr_ptr_type: Incomplete
c_int_ptr_type: Incomplete
c_py_unicode_ptr_type: Incomplete
c_const_py_unicode_ptr_type: Incomplete
c_py_ssize_t_ptr_type: Incomplete
c_ssize_t_ptr_type: Incomplete
c_size_t_ptr_type: Incomplete
c_gilstate_type: Incomplete
c_threadstate_type: Incomplete
c_threadstate_ptr_type: Incomplete
c_pytss_t_type: Incomplete
c_py_buffer_type: Incomplete
c_py_buffer_ptr_type: Incomplete
cy_integral_type: Incomplete
cy_floating_type: Incomplete
cy_numeric_type: Incomplete
c_buf_diminfo_type: Incomplete
c_pyx_buffer_type: Incomplete
c_pyx_buffer_ptr_type: Incomplete
c_pyx_buffer_nd_type: Incomplete
cython_memoryview_type: Incomplete
memoryviewslice_type: Incomplete
modifiers_and_name_to_type: Incomplete

def is_promotion(src_type, dst_type): ...
def best_match(arg_types, functions, pos: Incomplete | None = None, env: Incomplete | None = None, args: Incomplete | None = None):
    '''
    Given a list args of arguments and a list of functions, choose one
    to call which seems to be the "best" fit for this list of arguments.
    This function is used, e.g., when deciding which overloaded method
    to dispatch for C++ classes.

    We first eliminate functions based on arity, and if only one
    function has the correct arity, we return it. Otherwise, we weight
    functions based on how much work must be done to convert the
    arguments, with the following priorities:
      * identical types or pointers to identical types
      * promotions
      * non-Python types
    That is, we prefer functions where no arguments need converted,
    and failing that, functions where only promotions are required, and
    so on.

    If no function is deemed a good fit, or if two or more functions have
    the same weight, we return None (as there is no best match). If pos
    is not None, we also generate an error.
    '''
def merge_template_deductions(a, b): ...
def widest_numeric_type(type1, type2):
    """Given two numeric types, return the narrowest type encompassing both of them.
    """
def numeric_type_fits(small_type, large_type): ...
def independent_spanning_type(type1, type2): ...
def spanning_type(type1, type2): ...
def widest_extension_type(type1, type2): ...
def widest_cpp_type(type1, type2): ...
def simple_c_type(signed, longness, name): ...
def parse_basic_type(name): ...
def c_array_type(base_type, size): ...
def c_ptr_type(base_type): ...
def c_ref_type(base_type): ...
def cpp_rvalue_ref_type(base_type): ...
def c_const_type(base_type): ...
def c_const_or_volatile_type(base_type, is_const, is_volatile): ...
def same_type(type1, type2): ...
def assignable_from(type1, type2): ...
def typecast(to_type, from_type, expr_code): ...
def type_list_identifier(types): ...
def type_identifier(type, pyrex: bool = False): ...
def type_identifier_from_declaration(decl): ...
def cap_length(s, max_prefix: int = 63, max_len: int = 1024): ...
def write_noexcept_performance_hint(pos, env, function_name: Incomplete | None = None, void_return: bool = False) -> None: ...
def remove_cv_ref(tp, remove_fakeref: bool = False): ...
