from . import Naming as Naming, PyrexTypes as PyrexTypes
from .Errors import error as error
from _typeshed import Incomplete

invisible: Incomplete
richcmp_special_methods: Incomplete

class Signature:
    format_map: Incomplete
    type_to_format_map: Incomplete
    error_value_map: Incomplete
    use_fastcall: bool
    has_dummy_arg: bool
    has_generic_args: bool
    optional_object_arg_count: int
    fixed_arg_format: Incomplete
    ret_format: Incomplete
    error_value: Incomplete
    exception_check: Incomplete
    is_staticmethod: bool
    nogil: Incomplete
    def __init__(self, arg_format, ret_format, nogil: bool = False) -> None: ...
    def min_num_fixed_args(self): ...
    def max_num_fixed_args(self): ...
    def is_self_arg(self, i): ...
    def returns_self_type(self): ...
    def fixed_arg_type(self, i): ...
    def return_type(self): ...
    def format_from_type(self, arg_type): ...
    def exception_value(self): ...
    def function_type(self, self_arg_override: Incomplete | None = None): ...
    def method_flags(self): ...
    def method_function_type(self): ...
    def with_fastcall(self): ...
    @property
    def fastvar(self): ...

class SlotDescriptor:
    slot_name: Incomplete
    is_initialised_dynamically: Incomplete
    is_inherited: Incomplete
    ifdef: Incomplete
    used_ifdef: Incomplete
    py3: Incomplete
    py2: Incomplete
    is_binop: Incomplete
    def __init__(self, slot_name, dynamic: bool = False, inherited: bool = False, py3: bool = True, py2: bool = True, ifdef: Incomplete | None = None, is_binop: bool = False, used_ifdef: Incomplete | None = None) -> None: ...
    def slot_code(self, scope) -> None: ...
    def spec_value(self, scope): ...
    def preprocessor_guard_code(self): ...
    def generate_spec(self, scope, code) -> None: ...
    def generate(self, scope, code) -> None: ...
    def generate_dynamic_init_code(self, scope, code) -> None: ...
    def generate_set_slot_code(self, value, scope, code) -> None: ...

class FixedSlot(SlotDescriptor):
    value: Incomplete
    def __init__(self, slot_name, value, py3: bool = True, py2: bool = True, ifdef: Incomplete | None = None) -> None: ...
    def slot_code(self, scope): ...

class EmptySlot(FixedSlot):
    def __init__(self, slot_name, py3: bool = True, py2: bool = True, ifdef: Incomplete | None = None) -> None: ...

class MethodSlot(SlotDescriptor):
    signature: Incomplete
    slot_name: Incomplete
    method_name: Incomplete
    alternatives: Incomplete
    def __init__(self, signature, slot_name, method_name, method_name_to_slot, fallback: Incomplete | None = None, py3: bool = True, py2: bool = True, ifdef: Incomplete | None = None, inherited: bool = True) -> None: ...
    def slot_code(self, scope): ...

class InternalMethodSlot(SlotDescriptor):
    def __init__(self, slot_name, **kargs) -> None: ...
    def slot_code(self, scope): ...

class GCDependentSlot(InternalMethodSlot):
    def __init__(self, slot_name, **kargs) -> None: ...
    def slot_code(self, scope): ...

class GCClearReferencesSlot(GCDependentSlot):
    def slot_code(self, scope): ...

class ConstructorSlot(InternalMethodSlot):
    method: Incomplete
    def __init__(self, slot_name, method: Incomplete | None = None, **kargs) -> None: ...
    def slot_code(self, scope): ...
    def spec_value(self, scope): ...
    def generate_dynamic_init_code(self, scope, code) -> None: ...

class SyntheticSlot(InternalMethodSlot):
    user_methods: Incomplete
    default_value: Incomplete
    def __init__(self, slot_name, user_methods, default_value, **kargs) -> None: ...
    def slot_code(self, scope): ...
    def spec_value(self, scope): ...

class BinopSlot(SyntheticSlot):
    left_slot: Incomplete
    right_slot: Incomplete
    def __init__(self, signature, slot_name, left_method, method_name_to_slot, **kargs) -> None: ...

class RichcmpSlot(MethodSlot):
    def slot_code(self, scope): ...

class TypeFlagsSlot(SlotDescriptor):
    def slot_code(self, scope): ...
    def generate_spec(self, scope, code) -> None: ...

class DocStringSlot(SlotDescriptor):
    def slot_code(self, scope): ...

class SuiteSlot(SlotDescriptor):
    sub_slots: Incomplete
    slot_type: Incomplete
    def __init__(self, sub_slots, slot_type, slot_name, substructures, ifdef: Incomplete | None = None) -> None: ...
    def is_empty(self, scope): ...
    def substructure_cname(self, scope): ...
    def slot_code(self, scope): ...
    def generate_substructure(self, scope, code) -> None: ...
    def generate_spec(self, scope, code) -> None: ...

class MethodTableSlot(SlotDescriptor):
    def slot_code(self, scope): ...

class MemberTableSlot(SlotDescriptor):
    def slot_code(self, scope): ...
    def get_member_specs(self, scope): ...
    def is_empty(self, scope): ...
    def substructure_cname(self, scope): ...
    def generate_substructure_spec(self, scope, code) -> None: ...
    def spec_value(self, scope): ...

class GetSetSlot(SlotDescriptor):
    def slot_code(self, scope): ...

class BaseClassSlot(SlotDescriptor):
    def __init__(self, name) -> None: ...
    def generate_dynamic_init_code(self, scope, code) -> None: ...

class DictOffsetSlot(SlotDescriptor):
    def slot_code(self, scope): ...
    def members_slot_value(self, scope): ...

def get_property_accessor_signature(name): ...
def get_base_slot_function(scope, slot): ...
def get_slot_function(scope, slot): ...
def get_slot_by_name(slot_name, compiler_directives): ...
def get_slot_code_by_name(scope, slot_name): ...
def is_reverse_number_slot(name):
    """
    Tries to identify __radd__ and friends (so the METH_COEXIST flag can be applied).

    There's no great consequence if it inadvertently identifies a few other methods
    so just use a simple rule rather than an exact list.
    """

pyfunction_signature: Incomplete
pymethod_signature: Incomplete
pyfunction_noargs: Incomplete
pyfunction_onearg: Incomplete
unaryfunc: Incomplete
binaryfunc: Incomplete
ibinaryfunc: Incomplete
powternaryfunc: Incomplete
ipowternaryfunc: Incomplete
callfunc: Incomplete
inquiry: Incomplete
lenfunc: Incomplete
intargfunc: Incomplete
ssizeargfunc: Incomplete
intintargfunc: Incomplete
ssizessizeargfunc: Incomplete
intobjargproc: Incomplete
ssizeobjargproc: Incomplete
intintobjargproc: Incomplete
ssizessizeobjargproc: Incomplete
intintargproc: Incomplete
ssizessizeargproc: Incomplete
objargfunc: Incomplete
objobjargproc: Incomplete
readbufferproc: Incomplete
writebufferproc: Incomplete
segcountproc: Incomplete
charbufferproc: Incomplete
objargproc: Incomplete
destructor: Incomplete
getattrofunc: Incomplete
setattrofunc: Incomplete
delattrofunc: Incomplete
cmpfunc: Incomplete
reprfunc: Incomplete
hashfunc: Incomplete
richcmpfunc: Incomplete
getiterfunc: Incomplete
iternextfunc: Incomplete
descrgetfunc: Incomplete
descrsetfunc: Incomplete
descrdelfunc: Incomplete
initproc: Incomplete
getbufferproc: Incomplete
releasebufferproc: Incomplete
property_accessor_signatures: Incomplete
PyNumberMethods_Py2only_GUARD: str

class SlotTable:
    substructures: Incomplete
    PyNumberMethods: Incomplete
    PySequenceMethods: Incomplete
    PyMappingMethods: Incomplete
    PyBufferProcs: Incomplete
    PyAsyncMethods: Incomplete
    slot_table: Incomplete
    def __init__(self, old_binops) -> None: ...
    def get_special_method_signature(self, name): ...
    def get_slot_by_method_name(self, method_name): ...
    def __iter__(self): ...

def get_slot_table(compiler_directives): ...

special_method_names: Incomplete
method_noargs: str
method_onearg: str
method_varargs: str
method_fastcall: str
method_keywords: str
method_coexist: str
