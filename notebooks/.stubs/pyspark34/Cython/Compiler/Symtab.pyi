from . import Code as Code, Future as Future, Naming as Naming, Options as Options, PyrexTypes as PyrexTypes
from ..Utils import try_finally_contextmanager as try_finally_contextmanager
from .Errors import InternalError as InternalError, error as error, warning as warning
from .PyrexTypes import py_object_type as py_object_type, unspecified_type as unspecified_type
from .StringEncoding import EncodedString as EncodedString
from .TypeSlots import get_property_accessor_signature as get_property_accessor_signature, get_slot_table as get_slot_table, pyfunction_signature as pyfunction_signature, pymethod_signature as pymethod_signature, richcmp_special_methods as richcmp_special_methods
from _typeshed import Incomplete
from collections.abc import Generator

iso_c99_keywords: Incomplete

def c_safe_identifier(cname): ...
def punycodify_name(cname, mangle_with: Incomplete | None = None): ...

class BufferAux:
    writable_needed: bool
    buflocal_nd_var: Incomplete
    rcbuf_var: Incomplete
    def __init__(self, buflocal_nd_var, rcbuf_var) -> None: ...

class Entry:
    inline_func_in_pxd: bool
    borrowed: int
    init: str
    annotation: Incomplete
    pep563_annotation: Incomplete
    visibility: str
    is_builtin: int
    is_cglobal: int
    is_pyglobal: int
    is_member: int
    is_pyclass_attr: int
    is_variable: int
    is_cfunction: int
    is_cmethod: int
    is_builtin_cmethod: bool
    is_unbound_cmethod: int
    is_final_cmethod: int
    is_inline_cmethod: int
    is_anonymous: int
    is_type: int
    is_cclass: int
    is_cpp_class: int
    is_const: int
    is_property: int
    is_cproperty: int
    doc_cname: Incomplete
    getter_cname: Incomplete
    setter_cname: Incomplete
    is_self_arg: int
    is_arg: int
    is_local: int
    in_closure: int
    from_closure: int
    in_subscope: int
    is_declared_generic: int
    is_readonly: int
    pyfunc_cname: Incomplete
    func_cname: Incomplete
    func_modifiers: Incomplete
    final_func_cname: Incomplete
    doc: Incomplete
    as_variable: Incomplete
    xdecref_cleanup: int
    in_cinclude: int
    as_module: Incomplete
    is_inherited: int
    pystring_cname: Incomplete
    is_identifier: int
    is_interned: int
    used: int
    is_special: int
    defined_in_pxd: int
    is_implemented: int
    api: int
    utility_code: Incomplete
    is_overridable: int
    buffer_aux: Incomplete
    prev_entry: Incomplete
    might_overflow: int
    fused_cfunction: Incomplete
    is_fused_specialized: bool
    utility_code_definition: Incomplete
    needs_property: bool
    in_with_gil_block: int
    from_cython_utility_code: Incomplete
    error_on_uninitialized: bool
    cf_used: bool
    outer_entry: Incomplete
    is_cgetter: bool
    is_cpp_optional: bool
    known_standard_library_import: Incomplete
    pytyping_modifiers: Incomplete
    enum_int_value: Incomplete
    name: Incomplete
    cname: Incomplete
    type: Incomplete
    pos: Incomplete
    overloaded_alternatives: Incomplete
    cf_assignments: Incomplete
    cf_references: Incomplete
    inner_entries: Incomplete
    defining_entry: Incomplete
    def __init__(self, name, cname, type, pos: Incomplete | None = None, init: Incomplete | None = None) -> None: ...
    def already_declared_here(self) -> None: ...
    def redeclared(self, pos) -> None: ...
    def all_alternatives(self): ...
    def all_entries(self): ...
    def __lt__(left, right): ...
    @property
    def cf_is_reassigned(self): ...
    def make_cpp_optional(self) -> None: ...
    def declared_with_pytyping_modifier(self, modifier_name): ...

class InnerEntry(Entry):
    """
    An entry in a closure scope that represents the real outer Entry.
    """
    from_closure: bool
    outer_entry: Incomplete
    scope: Incomplete
    defining_entry: Incomplete
    inner_entries: Incomplete
    cf_assignments: Incomplete
    cf_references: Incomplete
    overloaded_alternatives: Incomplete
    is_cpp_optional: Incomplete
    def __init__(self, outer_entry, scope) -> None: ...
    def __getattr__(self, name): ...
    def all_entries(self): ...

class Scope:
    is_builtin_scope: int
    is_py_class_scope: int
    is_c_class_scope: int
    is_closure_scope: int
    is_local_scope: bool
    is_generator_expression_scope: int
    is_comprehension_scope: int
    is_passthrough: int
    is_cpp_class_scope: int
    is_property_scope: int
    is_module_scope: int
    is_c_dataclass_scope: bool
    is_internal: int
    scope_prefix: str
    in_cinclude: int
    nogil: int
    fused_to_specific: Incomplete
    return_type: Incomplete
    scope_predefined_names: Incomplete
    in_c_type_context: bool
    name: Incomplete
    outer_scope: Incomplete
    parent_scope: Incomplete
    qualified_name: Incomplete
    entries: Incomplete
    subscopes: Incomplete
    const_entries: Incomplete
    type_entries: Incomplete
    sue_entries: Incomplete
    arg_entries: Incomplete
    var_entries: Incomplete
    pyfunc_entries: Incomplete
    cfunc_entries: Incomplete
    c_class_entries: Incomplete
    defined_c_classes: Incomplete
    imported_c_classes: Incomplete
    cname_to_entry: Incomplete
    identifier_to_entry: Incomplete
    num_to_entry: Incomplete
    obj_to_entry: Incomplete
    buffer_entries: Incomplete
    lambda_defs: Incomplete
    id_counters: Incomplete
    def __init__(self, name, outer_scope, parent_scope) -> None: ...
    def __deepcopy__(self, memo): ...
    def merge_in(self, other, merge_unused: bool = True, allowlist: Incomplete | None = None) -> None: ...
    def qualifying_scope(self): ...
    def mangle(self, prefix, name: Incomplete | None = None): ...
    def mangle_internal(self, name): ...
    def mangle_class_private_name(self, name): ...
    def next_id(self, name: Incomplete | None = None): ...
    def global_scope(self):
        """ Return the module-level scope containing this scope. """
    def builtin_scope(self):
        """ Return the module-level scope containing this scope. """
    def iter_local_scopes(self) -> Generator[Incomplete, None, None]: ...
    def new_c_type_context(self, in_c_type_context: Incomplete | None = None) -> Generator[None, None, None]: ...
    def declare(self, name, cname, type, pos, visibility, shadow: int = 0, is_type: int = 0, create_wrapper: int = 0): ...
    def qualify_name(self, name): ...
    def declare_const(self, name, type, value, pos, cname: Incomplete | None = None, visibility: str = 'private', api: int = 0, create_wrapper: int = 0): ...
    def declare_type(self, name, type, pos, cname: Incomplete | None = None, visibility: str = 'private', api: int = 0, defining: int = 1, shadow: int = 0, template: int = 0): ...
    def declare_typedef(self, name, base_type, pos, cname: Incomplete | None = None, visibility: str = 'private', api: int = 0): ...
    def declare_struct_or_union(self, name, kind, scope, typedef_flag, pos, cname: Incomplete | None = None, visibility: str = 'private', api: int = 0, packed: bool = False): ...
    def declare_cpp_class(self, name, scope, pos, cname: Incomplete | None = None, base_classes=(), visibility: str = 'extern', templates: Incomplete | None = None): ...
    def check_previous_typedef_flag(self, entry, typedef_flag, pos) -> None: ...
    def check_previous_visibility(self, entry, visibility, pos) -> None: ...
    def declare_enum(self, name, pos, cname, scoped, typedef_flag, visibility: str = 'private', api: int = 0, create_wrapper: int = 0, doc: Incomplete | None = None): ...
    def declare_tuple_type(self, pos, components): ...
    def declare_var(self, name, type, pos, cname: Incomplete | None = None, visibility: str = 'private', api: bool = False, in_pxd: bool = False, is_cdef: bool = False, pytyping_modifiers: Incomplete | None = None): ...
    def declare_assignment_expression_target(self, name, type, pos): ...
    def declare_builtin(self, name, pos): ...
    def declare_pyfunction(self, name, pos, allow_redefine: bool = False, visibility: str = 'extern'): ...
    def declare_lambda_function(self, lambda_name, pos): ...
    def add_lambda_def(self, def_node) -> None: ...
    def register_pyfunction(self, entry) -> None: ...
    def declare_cfunction(self, name, type, pos, cname: Incomplete | None = None, visibility: str = 'private', api: int = 0, in_pxd: int = 0, defining: int = 0, modifiers=(), utility_code: Incomplete | None = None, overridable: bool = False): ...
    def declare_cgetter(self, name, return_type, pos: Incomplete | None = None, cname: Incomplete | None = None, visibility: str = 'private', modifiers=(), defining: bool = False, **cfunc_type_config): ...
    def add_cfunction(self, name, type, pos, cname, visibility, modifiers, inherited: bool = False): ...
    def find(self, name, pos): ...
    def find_imported_module(self, path, pos): ...
    def lookup(self, name): ...
    def lookup_here(self, name): ...
    def lookup_here_unmangled(self, name): ...
    def lookup_assignment_expression_target(self, name): ...
    def lookup_target(self, name): ...
    def lookup_type(self, name): ...
    def lookup_operator(self, operator, operands): ...
    def lookup_operator_for_types(self, pos, operator, types): ...
    def use_utility_code(self, new_code) -> None: ...
    def use_entry_utility_code(self, entry) -> None: ...
    def defines_any(self, names): ...
    def defines_any_special(self, names): ...
    def infer_types(self) -> None: ...
    def is_cpp(self): ...
    def add_include_file(self, filename, verbatim_include: Incomplete | None = None, late: bool = False) -> None: ...

class PreImportScope(Scope):
    namespace_cname: Incomplete
    def __init__(self) -> None: ...
    def declare_builtin(self, name, pos): ...

class BuiltinScope(Scope):
    is_builtin_scope: bool
    type_names: Incomplete
    def __init__(self) -> None: ...
    def lookup(self, name, language_level: Incomplete | None = None, str_is_str: Incomplete | None = None): ...
    def declare_builtin(self, name, pos): ...
    def declare_builtin_cfunction(self, name, type, cname, python_equiv: Incomplete | None = None, utility_code: Incomplete | None = None): ...
    def declare_builtin_type(self, name, cname, utility_code: Incomplete | None = None, objstruct_cname: Incomplete | None = None, type_class=...): ...
    def builtin_scope(self): ...

const_counter: int

class ModuleScope(Scope):
    is_module_scope: int
    has_import_star: int
    is_cython_builtin: int
    old_style_globals: int
    scope_predefined_names: Incomplete
    parent_module: Incomplete
    is_package: Incomplete
    module_name: Incomplete
    context: Incomplete
    module_cname: Incomplete
    module_dict_cname: Incomplete
    method_table_cname: Incomplete
    doc: str
    doc_cname: Incomplete
    utility_code_list: Incomplete
    module_entries: Incomplete
    c_includes: Incomplete
    type_names: Incomplete
    pxd_file_loaded: int
    cimported_modules: Incomplete
    types_imported: Incomplete
    included_files: Incomplete
    has_extern_class: int
    cached_builtins: Incomplete
    undeclared_cached_builtins: Incomplete
    namespace_cname: Incomplete
    def __init__(self, name, parent_module, context, is_package: bool = False) -> None: ...
    def qualifying_scope(self): ...
    def global_scope(self): ...
    def lookup(self, name, language_level: Incomplete | None = None, str_is_str: Incomplete | None = None): ...
    def declare_tuple_type(self, pos, components): ...
    def declare_builtin(self, name, pos): ...
    def find_module(self, module_name, pos, relative_level: int = -1): ...
    def find_submodule(self, name, as_package: bool = False): ...
    def lookup_submodule(self, name): ...
    def add_include_file(self, filename, verbatim_include: Incomplete | None = None, late: bool = False) -> None:
        """
        Add `filename` as include file. Add `verbatim_include` as
        verbatim text in the C file.
        Both `filename` and `verbatim_include` can be `None` or empty.
        """
    def process_include(self, inc) -> None:
        '''
        Add `inc`, which is an instance of `IncludeCode`, to this
        `ModuleScope`. This either adds a new element to the
        `c_includes` dict or it updates an existing entry.

        In detail: the values of the dict `self.c_includes` are
        instances of `IncludeCode` containing the code to be put in the
        generated C file. The keys of the dict are needed to ensure
        uniqueness in two ways: if an include file is specified in
        multiple "cdef extern" blocks, only one `#include` statement is
        generated. Second, the same include might occur multiple times
        if we find it through multiple "cimport" paths. So we use the
        generated code (of the form `#include "header.h"`) as dict key.

        If verbatim code does not belong to any include file (i.e. it
        was put in a `cdef extern from *` block), then we use a unique
        dict key: namely, the `sortkey()`.

        One `IncludeCode` object can contain multiple pieces of C code:
        one optional "main piece" for the include file and several other
        pieces for the verbatim code. The `IncludeCode.dict_update`
        method merges the pieces of two different `IncludeCode` objects
        if needed.
        '''
    def add_imported_module(self, scope) -> None: ...
    def add_imported_entry(self, name, entry, pos) -> None: ...
    def declare_module(self, name, scope, pos): ...
    def declare_var(self, name, type, pos, cname: Incomplete | None = None, visibility: str = 'private', api: bool = False, in_pxd: bool = False, is_cdef: bool = False, pytyping_modifiers: Incomplete | None = None): ...
    def declare_cfunction(self, name, type, pos, cname: Incomplete | None = None, visibility: str = 'private', api: int = 0, in_pxd: int = 0, defining: int = 0, modifiers=(), utility_code: Incomplete | None = None, overridable: bool = False): ...
    def declare_global(self, name, pos) -> None: ...
    def use_utility_code(self, new_code) -> None: ...
    def use_entry_utility_code(self, entry) -> None: ...
    def declare_c_class(self, name, pos, defining: int = 0, implementing: int = 0, module_name: Incomplete | None = None, base_type: Incomplete | None = None, objstruct_cname: Incomplete | None = None, typeobj_cname: Incomplete | None = None, typeptr_cname: Incomplete | None = None, visibility: str = 'private', typedef_flag: int = 0, api: int = 0, check_size: Incomplete | None = None, buffer_defaults: Incomplete | None = None, shadow: int = 0): ...
    def allocate_vtable_names(self, entry) -> None: ...
    def check_c_classes_pxd(self) -> None: ...
    def check_c_class(self, entry) -> None: ...
    def check_c_classes(self) -> None: ...
    def check_c_functions(self) -> None: ...
    def attach_var_entry_to_c_class(self, entry) -> None: ...
    def is_cpp(self): ...
    def infer_types(self) -> None: ...

class LocalScope(Scope):
    is_local_scope: bool
    has_with_gil_block: bool
    def __init__(self, name, outer_scope, parent_scope: Incomplete | None = None) -> None: ...
    def mangle(self, prefix, name): ...
    def declare_arg(self, name, type, pos): ...
    def declare_var(self, name, type, pos, cname: Incomplete | None = None, visibility: str = 'private', api: bool = False, in_pxd: bool = False, is_cdef: bool = False, pytyping_modifiers: Incomplete | None = None): ...
    def declare_global(self, name, pos) -> None: ...
    def declare_nonlocal(self, name, pos) -> None: ...
    def lookup(self, name): ...
    def mangle_closure_cnames(self, outer_scope_cname) -> None: ...

class ComprehensionScope(Scope):
    """Scope for comprehensions (but not generator expressions, which use ClosureScope).
    As opposed to generators, these can be easily inlined in some cases, so all
    we really need is a scope that holds the loop variable(s).
    """
    is_comprehension_scope: bool
    directives: Incomplete
    genexp_prefix: Incomplete
    var_entries: Incomplete
    def __init__(self, outer_scope) -> None: ...
    def mangle(self, prefix, name): ...
    def declare_var(self, name, type, pos, cname: Incomplete | None = None, visibility: str = 'private', api: bool = False, in_pxd: bool = False, is_cdef: bool = True, pytyping_modifiers: Incomplete | None = None): ...
    def declare_assignment_expression_target(self, name, type, pos): ...
    def declare_pyfunction(self, name, pos, allow_redefine: bool = False): ...
    def declare_lambda_function(self, func_cname, pos): ...
    def add_lambda_def(self, def_node): ...
    def lookup_assignment_expression_target(self, name): ...

class ClosureScope(LocalScope):
    is_closure_scope: bool
    closure_cname: Incomplete
    def __init__(self, name, scope_name, outer_scope, parent_scope: Incomplete | None = None) -> None: ...
    def declare_pyfunction(self, name, pos, allow_redefine: bool = False): ...
    def declare_assignment_expression_target(self, name, type, pos): ...

class GeneratorExpressionScope(ClosureScope):
    is_generator_expression_scope: bool
    def declare_assignment_expression_target(self, name, type, pos): ...
    def lookup_assignment_expression_target(self, name): ...

class StructOrUnionScope(Scope):
    def __init__(self, name: str = '?') -> None: ...
    def declare_var(self, name, type, pos, cname: Incomplete | None = None, visibility: str = 'private', api: bool = False, in_pxd: bool = False, is_cdef: bool = False, pytyping_modifiers: Incomplete | None = None, allow_pyobject: bool = False, allow_memoryview: bool = False, allow_refcounted: bool = False): ...
    def declare_cfunction(self, name, type, pos, cname: Incomplete | None = None, visibility: str = 'private', api: int = 0, in_pxd: int = 0, defining: int = 0, modifiers=(), overridable: bool = False): ...

class ClassScope(Scope):
    scope_predefined_names: Incomplete
    def mangle_class_private_name(self, name): ...
    class_name: Incomplete
    doc: Incomplete
    def __init__(self, name, outer_scope) -> None: ...
    def lookup(self, name): ...

class PyClassScope(ClassScope):
    is_py_class_scope: int
    def declare_var(self, name, type, pos, cname: Incomplete | None = None, visibility: str = 'private', api: bool = False, in_pxd: bool = False, is_cdef: bool = False, pytyping_modifiers: Incomplete | None = None): ...
    def declare_nonlocal(self, name, pos) -> None: ...
    def declare_global(self, name, pos) -> None: ...
    def add_default_value(self, type): ...

class CClassScope(ClassScope):
    is_c_class_scope: int
    is_closure_class_scope: bool
    has_pyobject_attrs: bool
    has_memoryview_attrs: bool
    has_cpp_constructable_attrs: bool
    has_cyclic_pyobject_attrs: bool
    defined: bool
    implemented: bool
    method_table_cname: Incomplete
    getset_table_cname: Incomplete
    property_entries: Incomplete
    inherited_var_entries: Incomplete
    parent_type: Incomplete
    namespace_cname: Incomplete
    def __init__(self, name, outer_scope, visibility, parent_type) -> None: ...
    def needs_gc(self): ...
    def needs_trashcan(self): ...
    def needs_tp_clear(self):
        """
        Do we need to generate an implementation for the tp_clear slot? Can
        be disabled to keep references for the __dealloc__ cleanup function.
        """
    def may_have_finalize(self):
        """
        This covers cases where we definitely have a __del__ function
        and also cases where one of the base classes could have a __del__
        function but we don't know.
        """
    def get_refcounted_entries(self, include_weakref: bool = False, include_gc_simple: bool = True): ...
    def declare_var(self, name, type, pos, cname: Incomplete | None = None, visibility: str = 'private', api: bool = False, in_pxd: bool = False, is_cdef: bool = False, pytyping_modifiers: Incomplete | None = None): ...
    def declare_pyfunction(self, name, pos, allow_redefine: bool = False): ...
    def lookup_here(self, name): ...
    def declare_cfunction(self, name, type, pos, cname: Incomplete | None = None, visibility: str = 'private', api: int = 0, in_pxd: int = 0, defining: int = 0, modifiers=(), utility_code: Incomplete | None = None, overridable: bool = False): ...
    def add_cfunction(self, name, type, pos, cname, visibility, modifiers, inherited: bool = False): ...
    def declare_builtin_cfunction(self, name, type, cname, utility_code: Incomplete | None = None): ...
    def declare_property(self, name, doc, pos, ctype: Incomplete | None = None, property_scope: Incomplete | None = None): ...
    def declare_cproperty(self, name, type, cfunc_name, doc: Incomplete | None = None, pos: Incomplete | None = None, visibility: str = 'extern', nogil: bool = False, with_gil: bool = False, exception_value: Incomplete | None = None, exception_check: bool = False, utility_code: Incomplete | None = None):
        """Internal convenience method to declare a C property function in one go.
        """
    def declare_inherited_c_attributes(self, base_scope): ...

class CppClassScope(Scope):
    is_cpp_class_scope: int
    default_constructor: Incomplete
    type: Incomplete
    directives: Incomplete
    inherited_var_entries: Incomplete
    def __init__(self, name, outer_scope, templates: Incomplete | None = None) -> None: ...
    def declare_var(self, name, type, pos, cname: Incomplete | None = None, visibility: str = 'extern', api: bool = False, in_pxd: bool = False, is_cdef: bool = False, defining: bool = False, pytyping_modifiers: Incomplete | None = None): ...
    def declare_cfunction(self, name, type, pos, cname: Incomplete | None = None, visibility: str = 'extern', api: int = 0, in_pxd: int = 0, defining: int = 0, modifiers=(), utility_code: Incomplete | None = None, overridable: bool = False): ...
    def declare_inherited_cpp_attributes(self, base_class) -> None: ...
    def specialize(self, values, type_entry): ...

class CppScopedEnumScope(Scope):
    def __init__(self, name, outer_scope) -> None: ...
    def declare_var(self, name, type, pos, cname: Incomplete | None = None, visibility: str = 'extern', pytyping_modifiers: Incomplete | None = None): ...

class PropertyScope(Scope):
    is_property_scope: int
    parent_type: Incomplete
    directives: Incomplete
    def __init__(self, name, class_scope) -> None: ...
    def declare_cfunction(self, name, type, pos, *args, **kwargs):
        """Declare a C property function.
        """
    def declare_pyfunction(self, name, pos, allow_redefine: bool = False): ...

class CConstOrVolatileScope(Scope):
    base_type_scope: Incomplete
    is_const: Incomplete
    is_volatile: Incomplete
    def __init__(self, base_type_scope, is_const: int = 0, is_volatile: int = 0) -> None: ...
    def lookup_here(self, name): ...

class TemplateScope(Scope):
    directives: Incomplete
    def __init__(self, name, outer_scope) -> None: ...
