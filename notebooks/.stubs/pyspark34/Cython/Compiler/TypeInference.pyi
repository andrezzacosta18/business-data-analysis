from . import Builtin as Builtin, ExprNodes as ExprNodes, Nodes as Nodes, PyrexTypes as PyrexTypes
from .. import Utils as Utils
from .Errors import error as error, message as message
from .PyrexTypes import py_object_type as py_object_type, unspecified_type as unspecified_type
from .Visitor import CythonTransform as CythonTransform, EnvTransform as EnvTransform
from _typeshed import Incomplete

class TypedExprNode(ExprNodes.ExprNode):
    subexprs: Incomplete
    def __init__(self, type, pos: Incomplete | None = None) -> None: ...

object_expr: Incomplete

class MarkParallelAssignments(EnvTransform):
    in_loop: bool
    parallel_errors: bool
    parallel_block_stack: Incomplete
    def __init__(self, context) -> None: ...
    def mark_assignment(self, lhs, rhs, inplace_op: Incomplete | None = None) -> None: ...
    def visit_WithTargetAssignmentStatNode(self, node): ...
    def visit_SingleAssignmentNode(self, node): ...
    def visit_CascadedAssignmentNode(self, node): ...
    def visit_InPlaceAssignmentNode(self, node): ...
    def visit_ForInStatNode(self, node): ...
    def visit_ForFromStatNode(self, node): ...
    def visit_WhileStatNode(self, node): ...
    def visit_ExceptClauseNode(self, node): ...
    def visit_FromCImportStatNode(self, node): ...
    def visit_FromImportStatNode(self, node): ...
    def visit_DefNode(self, node): ...
    def visit_DelStatNode(self, node): ...
    def visit_ParallelStatNode(self, node): ...
    def visit_YieldExprNode(self, node): ...
    def visit_ReturnStatNode(self, node): ...

class MarkOverflowingArithmetic(CythonTransform):
    might_overflow: bool
    env_stack: Incomplete
    env: Incomplete
    def __call__(self, root): ...
    def visit_safe_node(self, node): ...
    def visit_neutral_node(self, node): ...
    def visit_dangerous_node(self, node): ...
    def visit_FuncDefNode(self, node): ...
    def visit_NameNode(self, node): ...
    def visit_BinopNode(self, node): ...
    def visit_SimpleCallNode(self, node): ...
    visit_UnopNode = visit_neutral_node
    visit_UnaryMinusNode = visit_dangerous_node
    visit_InPlaceAssignmentNode = visit_dangerous_node
    visit_Node = visit_safe_node
    def visit_assignment(self, lhs, rhs) -> None: ...
    def visit_SingleAssignmentNode(self, node): ...
    def visit_CascadedAssignmentNode(self, node): ...

class PyObjectTypeInferer:
    """
    If it's not declared, it's a PyObject.
    """
    def infer_types(self, scope) -> None:
        """
        Given a dict of entries, map all unspecified types to a specified type.
        """

class SimpleAssignmentTypeInferer:
    """
    Very basic type inference.

    Note: in order to support cross-closure type inference, this must be
    applies to nested scopes in top-down order.
    """
    def set_entry_type(self, entry, entry_type, scope) -> None: ...
    def infer_types(self, scope): ...

def find_spanning_type(type1, type2): ...
def simply_type(result_type): ...
def aggressive_spanning_type(types, might_overflow, scope): ...
def safe_spanning_type(types, might_overflow, scope): ...
def get_type_inferer(): ...
