from . import Builtin as Builtin, ExprNodes as ExprNodes, Naming as Naming, Nodes as Nodes, PyrexTypes as PyrexTypes
from .Code import PyxCodeWriter as PyxCodeWriter, TempitaUtilityCode as TempitaUtilityCode, UtilityCode as UtilityCode
from .Errors import error as error, warning as warning
from .Options import copy_inherited_directives as copy_inherited_directives
from .ParseTreeTransforms import NormalizeTree as NormalizeTree, SkipDeclarations as SkipDeclarations
from .StringEncoding import EncodedString as EncodedString
from .TreeFragment import TreeFragment as TreeFragment
from .Visitor import VisitorTransform as VisitorTransform
from _typeshed import Incomplete
from collections.abc import Generator

def make_dataclasses_module_callnode(pos): ...
def make_dataclass_call_helper(pos, callable, kwds): ...

class RemoveAssignmentsToNames(VisitorTransform, SkipDeclarations):
    """
    Cython (and Python) normally treats

    class A:
         x = 1

    as generating a class attribute. However for dataclasses the `= 1` should be interpreted as
    a default value to initialize an instance attribute with.
    This transform therefore removes the `x=1` assignment so that the class attribute isn't
    generated, while recording what it has removed so that it can be used in the initialization.
    """
    names: Incomplete
    removed_assignments: Incomplete
    def __init__(self, names) -> None: ...
    def visit_CClassNode(self, node): ...
    def visit_PyClassNode(self, node): ...
    def visit_FuncDefNode(self, node): ...
    def visit_SingleAssignmentNode(self, node): ...
    def visit_Node(self, node): ...

class TemplateCode:
    """
    Adds the ability to keep track of placeholder argument names to PyxCodeWriter.

    Also adds extra_stats which are nodes bundled at the end when this
    is converted to a tree.
    """
    writer: Incomplete
    placeholders: Incomplete
    extra_stats: Incomplete
    def __init__(self, writer: Incomplete | None = None, placeholders: Incomplete | None = None, extra_stats: Incomplete | None = None) -> None: ...
    def add_code_line(self, code_line) -> None: ...
    def add_code_lines(self, code_lines) -> None: ...
    def reset(self) -> None: ...
    def empty(self): ...
    def indenter(self): ...
    def new_placeholder(self, field_names, value): ...
    def add_extra_statements(self, statements) -> None: ...
    def generate_tree(self, level: str = 'c_class'): ...
    def insertion_point(self): ...

class _MISSING_TYPE: ...

MISSING: Incomplete

class Field:
    """
    Field is based on the dataclasses.field class from the standard library module.
    It is used internally during the generation of Cython dataclasses to keep track
    of the settings for individual attributes.

    Attributes of this class are stored as nodes so they can be used in code construction
    more readily (i.e. we store BoolNode rather than bool)
    """
    default = MISSING
    default_factory = MISSING
    private: bool
    literal_keys: Incomplete
    repr: Incomplete
    hash: Incomplete
    init: Incomplete
    compare: Incomplete
    metadata: Incomplete
    is_initvar: Incomplete
    is_classvar: Incomplete
    def __init__(self, pos, default=..., default_factory=..., repr: Incomplete | None = None, hash: Incomplete | None = None, init: Incomplete | None = None, compare: Incomplete | None = None, metadata: Incomplete | None = None, is_initvar: bool = False, is_classvar: bool = False, **additional_kwds) -> None: ...
    def iterate_record_node_arguments(self) -> Generator[Incomplete, None, None]: ...

def process_class_get_fields(node): ...
def handle_cclass_dataclass(node, dataclass_args, analyse_decs_transform) -> None: ...
def generate_init_code(code, init, node, fields, kw_only) -> None:
    '''
    Notes on CPython generated "__init__":
    * Implemented in `_init_fn`.
    * The use of the `dataclasses._HAS_DEFAULT_FACTORY` sentinel value as
      the default argument for fields that need constructing with a factory
      function is copied from the CPython implementation. (`None` isn\'t
      suitable because it could also be a value for the user to pass.)
      There\'s no real reason why it needs importing from the dataclasses module
      though - it could equally be a value generated by Cython when the module loads.
    * seen_default and the associated error message are copied directly from Python
    * Call to user-defined __post_init__ function (if it exists) is copied from
      CPython.

    Cython behaviour deviates a little here (to be decided if this is right...)
    Because the class variable from the assignment does not exist Cython fields will
    return None (or whatever their type default is) if not initialized while Python
    dataclasses will fall back to looking up the class variable.
    '''
def generate_repr_code(code, repr, node, fields) -> None:
    '''
    The core of the CPython implementation is just:
    [\'return self.__class__.__qualname__ + f"(\' +
                     \', \'.join([f"{f.name}={{self.{f.name}!r}}"
                                for f in fields]) +
                     \')"\'],

    The only notable difference here is self.__class__.__qualname__ -> type(self).__name__
    which is because Cython currently supports Python 2.

    However, it also has some guards for recursive repr invocations. In the standard
    library implementation they\'re done with a wrapper decorator that captures a set
    (with the set keyed by id and thread). Here we create a set as a thread local
    variable and key only by id.
    '''
def generate_cmp_code(code, op, funcname, node, fields) -> None: ...
def generate_eq_code(code, eq, node, fields) -> None: ...
def generate_order_code(code, order, node, fields) -> None: ...
def generate_hash_code(code, unsafe_hash, eq, frozen, node, fields) -> None:
    """
    Copied from CPython implementation - the intention is to follow this as far as
    is possible:
    #    +------------------- unsafe_hash= parameter
    #    |       +----------- eq= parameter
    #    |       |       +--- frozen= parameter
    #    |       |       |
    #    v       v       v    |        |        |
    #                         |   no   |  yes   |  <--- class has explicitly defined __hash__
    # +=======+=======+=======+========+========+
    # | False | False | False |        |        | No __eq__, use the base class __hash__
    # +-------+-------+-------+--------+--------+
    # | False | False | True  |        |        | No __eq__, use the base class __hash__
    # +-------+-------+-------+--------+--------+
    # | False | True  | False | None   |        | <-- the default, not hashable
    # +-------+-------+-------+--------+--------+
    # | False | True  | True  | add    |        | Frozen, so hashable, allows override
    # +-------+-------+-------+--------+--------+
    # | True  | False | False | add    | raise  | Has no __eq__, but hashable
    # +-------+-------+-------+--------+--------+
    # | True  | False | True  | add    | raise  | Has no __eq__, but hashable
    # +-------+-------+-------+--------+--------+
    # | True  | True  | False | add    | raise  | Not frozen, but hashable
    # +-------+-------+-------+--------+--------+
    # | True  | True  | True  | add    | raise  | Frozen, so hashable
    # +=======+=======+=======+========+========+
    # For boxes that are blank, __hash__ is untouched and therefore
    # inherited from the base class.  If the base is object, then
    # id-based hashing is used.

    The Python implementation creates a tuple of all the fields, then hashes them.
    This implementation creates a tuple of all the hashes of all the fields and hashes that.
    The reason for this slight difference is to avoid to-Python conversions for anything
    that Cython knows how to hash directly (It doesn't look like this currently applies to
    anything though...).
    """
def get_field_type(pos, entry):
    """
    sets the .type attribute for a field

    Returns the annotation if possible (since this is what the dataclasses
    module does). If not (for example, attributes defined with cdef) then
    it creates a string fallback.
    """

class FieldRecordNode(ExprNodes.ExprNode):
    '''
    __dataclass_fields__ contains a bunch of field objects recording how each field
    of the dataclass was initialized (mainly corresponding to the arguments passed to
    the "field" function). This node is used for the attributes of these field objects.

    If possible, coerces `arg` to a Python object.
    Otherwise, generates a sensible backup string.
    '''
    subexprs: Incomplete
    def __init__(self, pos, arg) -> None: ...
    type: Incomplete
    def analyse_types(self, env): ...
    def coerce_to_pyobject(self, env): ...
    def generate_evaluation_code(self, code): ...
