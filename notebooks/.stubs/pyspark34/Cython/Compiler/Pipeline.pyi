from . import DebugFlags as DebugFlags, Errors as Errors, Naming as Naming, Options as Options
from .Errors import AbortError as AbortError, CompileError as CompileError, InternalError as InternalError
from _typeshed import Incomplete

def dumptree(t): ...
def abort_on_errors(node): ...
def parse_stage_factory(context): ...
def parse_pxd_stage_factory(context, scope, module_name): ...
def generate_pyx_code_stage_factory(options, result): ...
def inject_pxd_code_stage_factory(context): ...
def use_utility_code_definitions(scope, target, seen: Incomplete | None = None) -> None: ...
def sorted_utility_codes_and_deps(utilcodes): ...
def normalize_deps(utilcodes) -> None: ...
def inject_utility_code_stage_factory(context): ...
def create_pipeline(context, mode, exclude_classes=()): ...
def create_pyx_pipeline(context, options, result, py: bool = False, exclude_classes=()): ...
def create_pxd_pipeline(context, scope, module_name): ...
def create_py_pipeline(context, options, result): ...
def create_pyx_as_pxd_pipeline(context, result): ...
def insert_into_pipeline(pipeline, transform, before: Incomplete | None = None, after: Incomplete | None = None):
    """
    Insert a new transform into the pipeline after or before an instance of
    the given class. e.g.

        pipeline = insert_into_pipeline(pipeline, transform,
                                        after=AnalyseDeclarationsTransform)
    """

class _threadlocal: ...

threadlocal: Incomplete

def get_timings(): ...
def run_pipeline(pipeline, source, printtree: bool = True): ...
