from . import Builtin as Builtin, Future as Future, Naming as Naming, Nodes as Nodes, PyrexTypes as PyrexTypes, StringEncoding as StringEncoding, Symtab as Symtab, TypeSlots as TypeSlots
from .. import Utils as Utils
from ..Debugging import print_call_chain as print_call_chain
from .Annotate import AnnotationItem as AnnotationItem
from .Builtin import basestring_type as basestring_type, bytearray_type as bytearray_type, bytes_type as bytes_type, dict_type as dict_type, list_type as list_type, long_type as long_type, memoryview_type as memoryview_type, set_type as set_type, slice_type as slice_type, str_type as str_type, tuple_type as tuple_type, type_type as type_type, unicode_type as unicode_type
from .Code import TempitaUtilityCode as TempitaUtilityCode, UtilityCode as UtilityCode
from .DebugFlags import debug_coercion as debug_coercion, debug_disposal_code as debug_disposal_code
from .Errors import CannotSpecialize as CannotSpecialize, CompileError as CompileError, InternalError as InternalError, error as error, local_errors as local_errors, performance_hint as performance_hint, report_error as report_error, warning as warning
from .Nodes import Node as Node, SingleAssignmentNode as SingleAssignmentNode, utility_code_for_imports as utility_code_for_imports
from .PyrexTypes import PythranExpr as PythranExpr, error_type as error_type, py_object_type as py_object_type, typecast as typecast, unspecified_type as unspecified_type
from .Pythran import has_np_pythran as has_np_pythran, is_pythran_expr as is_pythran_expr, is_pythran_supported_node_or_none as is_pythran_supported_node_or_none, is_pythran_supported_operation_type as is_pythran_supported_operation_type, is_pythran_supported_type as is_pythran_supported_type, pythran_binop_type as pythran_binop_type, pythran_func_type as pythran_func_type, pythran_functor as pythran_functor, pythran_get_func_include_file as pythran_get_func_include_file, pythran_indexing_code as pythran_indexing_code, pythran_indexing_type as pythran_indexing_type, pythran_is_numpy_func_supported as pythran_is_numpy_func_supported, pythran_type as pythran_type, pythran_unaryop_type as pythran_unaryop_type, to_pythran as to_pythran
from _typeshed import Incomplete

basestring = str
any_string_type: Incomplete
IS_PYTHON3: bool

class NotConstant:
    def __new__(cls): ...

not_a_constant: Incomplete
constant_value_not_set: Incomplete
coercion_error_dict: Incomplete

def find_coercion_error(type_tuple, default, env): ...
def default_str_type(env): ...
def check_negative_indices(*nodes) -> None:
    '''
    Raise a warning on nodes that are known to have negative numeric values.
    Used to find (potential) bugs inside of "wraparound=False" sections.
    '''
def infer_sequence_item_type(env, seq_node, index_node: Incomplete | None = None, seq_type: Incomplete | None = None): ...
def make_dedup_key(outer_type, item_nodes):
    """
    Recursively generate a deduplication key from a sequence of values.
    Includes Cython node types to work around the fact that (1, 2.0) == (1.0, 2), for example.

    @param outer_type: The type of the outer container.
    @param item_nodes: A sequence of constant nodes that will be traversed recursively.
    @return: A tuple that can be used as a dict key for deduplication.
    """
def get_exception_handler(exception_value): ...
def maybe_check_py_error(code, check_py_exception, pos, nogil) -> None: ...
def translate_cpp_exception(code, pos, inside, py_result, exception_value, nogil) -> None: ...
def needs_cpp_exception_conversion(node): ...
def translate_double_cpp_exception(code, pos, lhs_type, lhs_code, rhs_code, lhs_exc_val, assign_exc_val, nogil) -> None: ...

class ExprNode(Node):
    result_ctype: Incomplete
    type: Incomplete
    annotation: Incomplete
    temp_code: Incomplete
    old_temp: Incomplete
    use_managed_ref: bool
    result_is_used: bool
    is_numpy_attribute: bool
    generator_arg_tag: Incomplete
    is_sequence_constructor: bool
    is_dict_literal: bool
    is_set_literal: bool
    is_string_literal: bool
    is_attribute: bool
    is_subscript: bool
    is_slice: bool
    is_buffer_access: bool
    is_memview_index: bool
    is_memview_slice: bool
    is_memview_broadcast: bool
    is_memview_copy_assignment: bool
    is_temp: bool
    has_temp_moved: bool
    is_target: bool
    is_starred: bool
    constant_result = constant_value_not_set
    child_attrs: Incomplete
    def analyse_annotations(self, env) -> None: ...
    def not_implemented(self, method_name) -> None: ...
    def is_lvalue(self): ...
    def is_addressable(self): ...
    def is_ephemeral(self): ...
    def subexpr_nodes(self): ...
    def result(self): ...
    def move_result_rhs(self): ...
    def move_result_rhs_as(self, type): ...
    def pythran_result(self, type_: Incomplete | None = None): ...
    def is_c_result_required(self):
        """
        Subtypes may return False here if result temp allocation can be skipped.
        """
    def result_as(self, type: Incomplete | None = None): ...
    def py_result(self): ...
    def ctype(self): ...
    def get_constant_c_result_code(self) -> None: ...
    def calculate_constant_result(self) -> None: ...
    def has_constant_result(self): ...
    def compile_time_value(self, denv) -> None: ...
    def compile_time_value_error(self, e) -> None: ...
    def analyse_target_declaration(self, env) -> None: ...
    def analyse_assignment_expression_target_declaration(self, env) -> None: ...
    def analyse_const_expression(self, env): ...
    def analyse_expressions(self, env): ...
    def analyse_target_expression(self, env, rhs): ...
    def analyse_boolean_expression(self, env): ...
    def analyse_temp_boolean_expression(self, env): ...
    def type_dependencies(self, env): ...
    def infer_type(self, env): ...
    def nonlocally_immutable(self): ...
    def inferable_item_node(self, index: int = 0):
        """
        Return a node that represents the (type) result of an indexing operation,
        e.g. for tuple unpacking or iteration.
        """
    def analyse_as_module(self, env) -> None: ...
    def analyse_as_type(self, env) -> None: ...
    def analyse_as_specialized_type(self, env): ...
    def analyse_as_extension_type(self, env) -> None: ...
    def analyse_types(self, env) -> None: ...
    def analyse_target_types(self, env): ...
    def nogil_check(self, env) -> None: ...
    def gil_assignment_check(self, env) -> None: ...
    def check_const(self): ...
    def not_const(self) -> None: ...
    def check_const_addr(self): ...
    def addr_not_const(self) -> None: ...
    def result_in_temp(self): ...
    def target_code(self): ...
    def calculate_result_code(self) -> None: ...
    def allocate_temp_result(self, code) -> None: ...
    def release_temp_result(self, code) -> None: ...
    def make_owned_reference(self, code) -> None:
        """
        Make sure we own a reference to result.
        If the result is in a temp, it is already a new reference.
        """
    def make_owned_memoryviewslice(self, code) -> None:
        """
        Make sure we own the reference to this memoryview slice.
        """
    def generate_evaluation_code(self, code) -> None: ...
    def generate_subexpr_evaluation_code(self, code) -> None: ...
    def generate_result_code(self, code) -> None: ...
    def generate_disposal_code(self, code) -> None: ...
    def generate_subexpr_disposal_code(self, code) -> None: ...
    def generate_post_assignment_code(self, code) -> None: ...
    def generate_assignment_code(self, rhs, code, overloaded_assignment: bool = False, exception_check: Incomplete | None = None, exception_value: Incomplete | None = None) -> None: ...
    def generate_deletion_code(self, code, ignore_nonexisting: bool = False) -> None: ...
    def free_temps(self, code) -> None: ...
    def free_subexpr_temps(self, code) -> None: ...
    def generate_function_definitions(self, env, code) -> None: ...
    def generate_decref_set(self, code, rhs) -> None: ...
    def generate_xdecref_set(self, code, rhs) -> None: ...
    def generate_gotref(self, code, handle_null: bool = False, maybe_null_extra_check: bool = True) -> None: ...
    def generate_xgotref(self, code) -> None: ...
    def generate_giveref(self, code) -> None: ...
    def generate_xgiveref(self, code) -> None: ...
    def annotate(self, code) -> None: ...
    def coerce_to(self, dst_type, env): ...
    def fail_assignment(self, dst_type) -> None: ...
    def check_for_coercion_error(self, dst_type, env, fail: bool = False, default: Incomplete | None = None): ...
    def coerce_to_pyobject(self, env): ...
    def coerce_to_boolean(self, env): ...
    def coerce_to_integer(self, env): ...
    def coerce_to_temp(self, env): ...
    def coerce_to_simple(self, env): ...
    def is_simple(self): ...
    def may_be_none(self): ...
    def as_cython_attribute(self) -> None: ...
    def as_none_safe_node(self, message, error: str = 'PyExc_TypeError', format_args=()): ...
    @classmethod
    def from_node(cls, node, **kwargs):
        """Instantiate this node class from another node, properly
        copying over all attributes that one would forget otherwise.
        """
    def get_known_standard_library_import(self) -> None:
        """
        Gets the module.path that this node was imported from.

        Many nodes do not have one, or it is ambiguous, in which case
        this function returns a false value.
        """

class AtomicExprNode(ExprNode):
    subexprs: Incomplete
    def generate_subexpr_evaluation_code(self, code) -> None: ...
    def generate_subexpr_disposal_code(self, code) -> None: ...

class PyConstNode(AtomicExprNode):
    is_literal: int
    type = py_object_type
    nogil_check: Incomplete
    def is_simple(self): ...
    def may_be_none(self): ...
    def analyse_types(self, env): ...
    def calculate_result_code(self): ...
    def generate_result_code(self, code) -> None: ...

class NoneNode(PyConstNode):
    is_none: int
    value: str
    constant_result: Incomplete
    def compile_time_value(self, denv) -> None: ...
    def may_be_none(self): ...
    def coerce_to(self, dst_type, env): ...

class EllipsisNode(PyConstNode):
    value: str
    constant_result = Ellipsis
    def compile_time_value(self, denv): ...

class ConstNode(AtomicExprNode):
    is_literal: int
    nogil_check: Incomplete
    def is_simple(self): ...
    def nonlocally_immutable(self): ...
    def may_be_none(self): ...
    def analyse_types(self, env): ...
    def check_const(self): ...
    def get_constant_c_result_code(self): ...
    def calculate_result_code(self): ...
    def generate_result_code(self, code) -> None: ...

class BoolNode(ConstNode):
    type: Incomplete
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def compile_time_value(self, denv): ...
    def calculate_result_code(self): ...
    def coerce_to(self, dst_type, env): ...

class NullNode(ConstNode):
    type: Incomplete
    value: str
    constant_result: int
    def get_constant_c_result_code(self): ...

class CharNode(ConstNode):
    type: Incomplete
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def compile_time_value(self, denv): ...
    def calculate_result_code(self): ...

class IntNode(ConstNode):
    unsigned: str
    longness: str
    is_c_literal: Incomplete
    @property
    def hex_value(self): ...
    @property
    def base_10_value(self): ...
    type: Incomplete
    def __init__(self, pos, **kwds) -> None: ...
    def find_suitable_type_for_value(self): ...
    def coerce_to(self, dst_type, env): ...
    def coerce_to_boolean(self, env): ...
    result_code: Incomplete
    def generate_evaluation_code(self, code) -> None: ...
    def get_constant_c_result_code(self): ...
    def value_as_c_integer_string(self): ...
    def calculate_result_code(self): ...
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def compile_time_value(self, denv): ...

class FloatNode(ConstNode):
    type: Incomplete
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def compile_time_value(self, denv): ...
    def coerce_to(self, dst_type, env): ...
    def calculate_result_code(self): ...
    def get_constant_c_result_code(self): ...
    result_code: Incomplete
    def generate_evaluation_code(self, code) -> None: ...

class BytesNode(ConstNode):
    is_string_literal: bool
    type = bytes_type
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def as_sliced_node(self, start, stop, step: Incomplete | None = None): ...
    def compile_time_value(self, denv): ...
    def analyse_as_type(self, env): ...
    def can_coerce_to_char_literal(self): ...
    def coerce_to_boolean(self, env): ...
    def coerce_to(self, dst_type, env): ...
    result_code: Incomplete
    def generate_evaluation_code(self, code) -> None: ...
    def get_constant_c_result_code(self) -> None: ...
    def calculate_result_code(self): ...

class UnicodeNode(ConstNode):
    is_string_literal: bool
    bytes_value: Incomplete
    type = unicode_type
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def analyse_as_type(self, env): ...
    def as_sliced_node(self, start, stop, step: Incomplete | None = None): ...
    def coerce_to(self, dst_type, env): ...
    def can_coerce_to_char_literal(self): ...
    def coerce_to_boolean(self, env): ...
    def contains_surrogates(self): ...
    result_code: Incomplete
    def generate_evaluation_code(self, code) -> None: ...
    def calculate_result_code(self): ...
    def compile_time_value(self, env): ...

class StringNode(PyConstNode):
    type = str_type
    is_string_literal: bool
    is_identifier: Incomplete
    unicode_value: Incomplete
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def analyse_as_type(self, env): ...
    def as_sliced_node(self, start, stop, step: Incomplete | None = None): ...
    def coerce_to(self, dst_type, env): ...
    def can_coerce_to_char_literal(self): ...
    result_code: Incomplete
    def generate_evaluation_code(self, code) -> None: ...
    def get_constant_c_result_code(self) -> None: ...
    def calculate_result_code(self): ...
    def compile_time_value(self, env): ...

class IdentifierStringNode(StringNode):
    is_identifier: bool

class ImagNode(AtomicExprNode):
    type: Incomplete
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def compile_time_value(self, denv): ...
    def analyse_types(self, env): ...
    def may_be_none(self): ...
    def coerce_to(self, dst_type, env): ...
    gil_message: str
    def calculate_result_code(self): ...
    def generate_result_code(self, code) -> None: ...

class NewExprNode(AtomicExprNode):
    type: Incomplete
    class_type: Incomplete
    entry: Incomplete
    def infer_type(self, env): ...
    def analyse_types(self, env): ...
    def may_be_none(self): ...
    def generate_result_code(self, code) -> None: ...
    def calculate_result_code(self): ...

class NameNode(AtomicExprNode):
    is_name: bool
    is_cython_module: bool
    cython_attribute: Incomplete
    lhs_of_first_assignment: bool
    is_used_as_rvalue: int
    entry: Incomplete
    type_entry: Incomplete
    cf_maybe_null: bool
    cf_is_null: bool
    allow_null: bool
    nogil: bool
    inferred_type: Incomplete
    def as_cython_attribute(self): ...
    def type_dependencies(self, env): ...
    def infer_type(self, env): ...
    def compile_time_value(self, denv): ...
    def get_constant_c_result_code(self): ...
    def coerce_to(self, dst_type, env): ...
    def declare_from_annotation(self, env, as_target: bool = False) -> None:
        """Implements PEP 526 annotation typing in a fairly relaxed way.

        Annotations are ignored for global variables.
        All other annotations are stored on the entry in the symbol table.
        String literals are allowed and not evaluated.
        The ambiguous Python types 'int' and 'long' are not evaluated - the 'cython.int' form must be used instead.
        """
    def analyse_as_module(self, env): ...
    def analyse_as_type(self, env): ...
    def analyse_as_extension_type(self, env): ...
    def analyse_target_declaration(self, env): ...
    def analyse_assignment_expression_target_declaration(self, env): ...
    initialized_check: Incomplete
    is_literal: bool
    type: Incomplete
    def analyse_types(self, env): ...
    def analyse_target_types(self, env): ...
    result_ctype: Incomplete
    is_temp: int
    use_managed_ref: bool
    def analyse_rvalue_entry(self, env): ...
    def nogil_check(self, env) -> None: ...
    gil_message: str
    def analyse_entry(self, env, is_target: bool = False) -> None: ...
    def check_identifier_kind(self) -> None: ...
    def is_cimported_module_without_shadow(self, env): ...
    def is_simple(self): ...
    def may_be_none(self): ...
    def nonlocally_immutable(self): ...
    def calculate_target_results(self, env) -> None: ...
    def check_const(self): ...
    def check_const_addr(self): ...
    def is_lvalue(self): ...
    def is_addressable(self): ...
    def is_ephemeral(self): ...
    def calculate_result_code(self): ...
    def generate_result_code(self, code) -> None: ...
    def generate_assignment_code(self, rhs, code, overloaded_assignment: bool = False, exception_check: Incomplete | None = None, exception_value: Incomplete | None = None) -> None: ...
    def generate_acquire_memoryviewslice(self, rhs, code) -> None:
        """
        Slices, coercions from objects, return values etc are new references.
        We have a borrowed reference in case of dst = src
        """
    def generate_acquire_buffer(self, rhs, code) -> None: ...
    def generate_deletion_code(self, code, ignore_nonexisting: bool = False) -> None: ...
    def annotate(self, code) -> None: ...
    def get_known_standard_library_import(self): ...

class BackquoteNode(ExprNode):
    type = py_object_type
    subexprs: Incomplete
    arg: Incomplete
    is_temp: int
    def analyse_types(self, env): ...
    gil_message: str
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def generate_result_code(self, code) -> None: ...

class ImportNode(ExprNode):
    type = py_object_type
    module_names: Incomplete
    get_top_level_module: bool
    is_temp: bool
    subexprs: Incomplete
    level: int
    module_name: Incomplete
    name_list: Incomplete
    def analyse_types(self, env): ...
    gil_message: str
    def generate_result_code(self, code) -> None: ...
    def get_known_standard_library_import(self): ...

class ScopedExprNode(ExprNode):
    subexprs: Incomplete
    expr_scope: Incomplete
    has_local_scope: bool
    def init_scope(self, outer_scope, expr_scope: Incomplete | None = None) -> None: ...
    def analyse_declarations(self, env) -> None: ...
    def analyse_scoped_declarations(self, env) -> None: ...
    def analyse_types(self, env): ...
    def analyse_scoped_expressions(self, env): ...
    def generate_evaluation_code(self, code) -> None: ...

class IteratorNode(ScopedExprNode):
    type = py_object_type
    iter_func_ptr: Incomplete
    counter_cname: Incomplete
    reversed: bool
    is_async: bool
    has_local_scope: bool
    subexprs: Incomplete
    sequence: Incomplete
    is_temp: int
    def analyse_types(self, env): ...
    gil_message: str
    def is_reversed_cpp_iteration(self):
        """
        Returns True if the 'reversed' function is applied to a C++ iterable.

        This supports C++ classes with reverse_iterator implemented.
        """
    def type_dependencies(self, env): ...
    def infer_type(self, env): ...
    may_be_a_sequence: Incomplete
    def generate_result_code(self, code) -> None: ...
    def generate_next_sequence_item(self, test_name, result_name, code) -> None: ...
    def generate_iter_next_result_code(self, result_name, code) -> None: ...
    def free_temps(self, code) -> None: ...

class CppIteratorNode(ExprNode):
    cpp_sequence_cname: Incomplete
    cpp_attribute_op: str
    extra_dereference: str
    is_temp: bool
    reversed: bool
    subexprs: Incomplete
    def get_iterator_func_names(self): ...
    type: Incomplete
    def analyse_types(self, env): ...
    def generate_result_code(self, code) -> None: ...
    def generate_iter_next_result_code(self, result_name, code) -> None: ...
    def generate_subexpr_disposal_code(self, code) -> None: ...
    def free_subexpr_temps(self, code) -> None: ...
    def generate_disposal_code(self, code) -> None: ...
    def free_temps(self, code) -> None: ...

class NextNode(AtomicExprNode):
    iterator: Incomplete
    def __init__(self, iterator) -> None: ...
    def nogil_check(self, env) -> None: ...
    def type_dependencies(self, env): ...
    def infer_type(self, env, iterator_type: Incomplete | None = None): ...
    type: Incomplete
    is_temp: int
    def analyse_types(self, env): ...
    def generate_result_code(self, code) -> None: ...

class AsyncIteratorNode(ScopedExprNode):
    subexprs: Incomplete
    is_async: bool
    type = py_object_type
    is_temp: int
    has_local_scope: bool
    def infer_type(self, env): ...
    sequence: Incomplete
    def analyse_types(self, env): ...
    def generate_result_code(self, code) -> None: ...

class AsyncNextNode(AtomicExprNode):
    type = py_object_type
    is_temp: int
    iterator: Incomplete
    def __init__(self, iterator) -> None: ...
    def infer_type(self, env): ...
    def analyse_types(self, env): ...
    def generate_result_code(self, code) -> None: ...

class WithExitCallNode(ExprNode):
    subexprs: Incomplete
    test_if_run: bool
    await_expr: Incomplete
    args: Incomplete
    type: Incomplete
    is_temp: bool
    def analyse_types(self, env): ...
    def generate_evaluation_code(self, code) -> None: ...

class ExcValueNode(AtomicExprNode):
    type = py_object_type
    def __init__(self, pos) -> None: ...
    var: Incomplete
    def set_var(self, var) -> None: ...
    def calculate_result_code(self): ...
    def generate_result_code(self, code) -> None: ...
    def analyse_types(self, env): ...

class TempNode(ExprNode):
    subexprs: Incomplete
    type: Incomplete
    result_ctype: Incomplete
    is_temp: int
    def __init__(self, pos, type, env: Incomplete | None = None) -> None: ...
    def analyse_types(self, env): ...
    is_target: bool
    def analyse_target_declaration(self, env) -> None: ...
    def generate_result_code(self, code) -> None: ...
    temp_cname: Incomplete
    def allocate(self, code) -> None: ...
    def release(self, code) -> None: ...
    def result(self): ...
    def allocate_temp_result(self, code) -> None: ...
    def release_temp_result(self, code) -> None: ...

class PyTempNode(TempNode):
    def __init__(self, pos, env) -> None: ...

class RawCNameExprNode(ExprNode):
    subexprs: Incomplete
    cname: Incomplete
    def __init__(self, pos, type: Incomplete | None = None, cname: Incomplete | None = None) -> None: ...
    def analyse_types(self, env): ...
    def set_cname(self, cname) -> None: ...
    def result(self): ...
    def generate_result_code(self, code) -> None: ...

class JoinedStrNode(ExprNode):
    type = unicode_type
    is_temp: bool
    gil_message: str
    subexprs: Incomplete
    values: Incomplete
    def analyse_types(self, env): ...
    def may_be_none(self): ...
    def generate_evaluation_code(self, code) -> None: ...

class FormattedValueNode(ExprNode):
    subexprs: Incomplete
    type = unicode_type
    is_temp: bool
    c_format_spec: Incomplete
    gil_message: str
    find_conversion_func: Incomplete
    def may_be_none(self): ...
    value: Incomplete
    format_spec: Incomplete
    def analyse_types(self, env): ...
    def generate_result_code(self, code) -> None: ...

class ParallelThreadsAvailableNode(AtomicExprNode):
    """
    Note: this is disabled and not a valid directive at this moment

    Implements cython.parallel.threadsavailable(). If we are called from the
    sequential part of the application, we need to call omp_get_max_threads(),
    and in the parallel part we can just call omp_get_num_threads()
    """
    type: Incomplete
    is_temp: bool
    def analyse_types(self, env): ...
    def generate_result_code(self, code) -> None: ...
    def result(self): ...

class ParallelThreadIdNode(AtomicExprNode):
    """
    Implements cython.parallel.threadid()
    """
    type: Incomplete
    is_temp: bool
    def analyse_types(self, env): ...
    def generate_result_code(self, code) -> None: ...
    def result(self): ...

class _IndexingBaseNode(ExprNode):
    def is_ephemeral(self): ...
    def check_const_addr(self): ...
    def is_lvalue(self): ...

class IndexNode(_IndexingBaseNode):
    subexprs: Incomplete
    type_indices: Incomplete
    is_subscript: bool
    is_fused_index: bool
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def compile_time_value(self, denv): ...
    def is_simple(self): ...
    def may_be_none(self): ...
    def analyse_target_declaration(self, env) -> None: ...
    def analyse_as_type(self, env): ...
    def analyse_pytyping_modifiers(self, env): ...
    def type_dependencies(self, env): ...
    def infer_type(self, env): ...
    def analyse_types(self, env): ...
    def analyse_target_types(self, env): ...
    base: Incomplete
    type: Incomplete
    index: Incomplete
    nogil: Incomplete
    original_index_type: Incomplete
    def analyse_base_and_index_types(self, env, getting: bool = False, setting: bool = False, analyse_base: bool = True): ...
    is_temp: int
    def analyse_as_pyobject(self, env, is_slice, getting, setting): ...
    def analyse_as_c_array(self, env, is_slice): ...
    result_code: str
    exception_check: Incomplete
    exception_value: Incomplete
    def analyse_as_cpp(self, env, setting): ...
    def analyse_as_c_function(self, env): ...
    def analyse_as_c_tuple(self, env, getting, setting): ...
    def analyse_as_buffer_operation(self, env, getting):
        """
        Analyse buffer indexing and memoryview indexing/slicing
        """
    def wrap_in_nonecheck_node(self, env, getting) -> None: ...
    def parse_index_as_types(self, env, required: bool = True): ...
    entry: Incomplete
    is_attribute: bool
    obj: Incomplete
    def parse_indexed_fused_cdef(self, env):
        """
        Interpret fused_cdef_func[specific_type1, ...]

        Note that if this method is called, we are an indexed cdef function
        with fused argument types, and this IndexNode will be replaced by the
        NameNode with specific entry just after analysis of expressions by
        AnalyseExpressionsTransform.
        """
    gil_message: str
    def calculate_result_code(self): ...
    def extra_index_params(self, code): ...
    def generate_result_code(self, code) -> None: ...
    def generate_setitem_code(self, value_code, code) -> None: ...
    def generate_assignment_code(self, rhs, code, overloaded_assignment: bool = False, exception_check: Incomplete | None = None, exception_value: Incomplete | None = None) -> None: ...
    def generate_deletion_code(self, code, ignore_nonexisting: bool = False) -> None: ...

class BufferIndexNode(_IndexingBaseNode):
    """
    Indexing of buffers and memoryviews. This node is created during type
    analysis from IndexNode and replaces it.

    Attributes:
        base - base node being indexed
        indices - list of indexing expressions
    """
    subexprs: Incomplete
    is_buffer_access: bool
    writable_needed: bool
    index_temps: Incomplete
    def analyse_target_types(self, env) -> None: ...
    type: Incomplete
    none_error_message: str
    def analyse_types(self, env, getting: bool = True):
        """
        Analyse types for buffer indexing only. Overridden by memoryview
        indexing and slicing subclasses
        """
    base: Incomplete
    buffer_type: Incomplete
    is_temp: bool
    def analyse_buffer_index(self, env, getting) -> None: ...
    def analyse_assignment(self, rhs) -> None:
        """
        Called by IndexNode when this node is assigned to,
        with the rhs of the assignment
        """
    def wrap_in_nonecheck_node(self, env) -> None: ...
    def nogil_check(self, env) -> None: ...
    def calculate_result_code(self): ...
    def buffer_entry(self): ...
    def get_index_in_temp(self, code, ivar): ...
    def buffer_lookup_code(self, code):
        """
        ndarray[1, 2, 3] and memslice[1, 2, 3]
        """
    def generate_assignment_code(self, rhs, code, overloaded_assignment: bool = False) -> None: ...
    def generate_buffer_setitem_code(self, rhs, code, op: str = '') -> None: ...
    def generate_result_code(self, code) -> None: ...
    def free_subexpr_temps(self, code) -> None: ...

class MemoryViewIndexNode(BufferIndexNode):
    is_memview_index: bool
    is_buffer_access: bool
    warned_untyped_idx: bool
    is_pythran_mode: Incomplete
    writable_needed: bool
    memslice_index: Incomplete
    type: Incomplete
    is_memview_slice: bool
    indices: Incomplete
    original_indices: Incomplete
    nogil: Incomplete
    def analyse_types(self, env, getting: bool = True): ...
    none_error_message: str
    def analyse_operation(self, env, getting, axes) -> None: ...
    def analyse_broadcast_operation(self, rhs) -> None:
        """
        Support broadcasting for slice assignment.
        E.g.
            m_2d[...] = m_1d  # or,
            m_1d[...] = m_2d  # if the leading dimension has extent 1
        """
    def analyse_as_memview_scalar_assignment(self, rhs): ...

class MemoryViewSliceNode(MemoryViewIndexNode):
    is_memview_slice: bool
    is_ellipsis_noop: bool
    is_memview_scalar_assignment: bool
    is_memview_index: bool
    is_memview_broadcast: bool
    type: Incomplete
    def analyse_ellipsis_noop(self, env, getting) -> None:
        """Slicing operations needing no evaluation, i.e. m[...] or m[:, :]"""
    none_error_message: str
    index: Incomplete
    is_temp: bool
    use_managed_ref: bool
    base: Incomplete
    def analyse_operation(self, env, getting, axes) -> None: ...
    def analyse_assignment(self, rhs): ...
    def merged_indices(self, indices):
        '''Return a new list of indices/slices with \'indices\' merged into the current ones
        according to slicing rules.
        Is used to implement "view[i][j]" => "view[i, j]".
        Return None if the indices cannot (easily) be merged at compile time.
        '''
    def is_simple(self): ...
    def calculate_result_code(self):
        """This is called in case this is a no-op slicing node"""
    def generate_result_code(self, code) -> None: ...
    def generate_assignment_code(self, rhs, code, overloaded_assignment: bool = False) -> None: ...

class MemoryCopyNode(ExprNode):
    """
    Wraps a memoryview slice for slice assignment.

        dst: destination mememoryview slice
    """
    subexprs: Incomplete
    dst: Incomplete
    type: Incomplete
    def __init__(self, pos, dst) -> None: ...
    def generate_assignment_code(self, rhs, code, overloaded_assignment: bool = False) -> None: ...

class MemoryCopySlice(MemoryCopyNode):
    """
    Copy the contents of slice src to slice dst. Does not support indirect
    slices.

        memslice1[...] = memslice2
        memslice1[:] = memslice2
    """
    is_memview_copy_assignment: bool
    copy_slice_cname: str

class MemoryCopyScalar(MemoryCopyNode):
    """
    Assign a scalar to a slice. dst must be simple, scalar will be assigned
    to a correct type and not just something assignable.

        memslice1[...] = 0.0
        memslice1[:] = 0.0
    """
    type: Incomplete
    def __init__(self, pos, dst) -> None: ...

class SliceIndexNode(ExprNode):
    subexprs: Incomplete
    nogil: bool
    slice: Incomplete
    def infer_type(self, env): ...
    def inferable_item_node(self, index: int = 0): ...
    def may_be_none(self): ...
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def compile_time_value(self, denv): ...
    def analyse_target_declaration(self, env) -> None: ...
    def analyse_target_types(self, env): ...
    base: Incomplete
    start: Incomplete
    stop: Incomplete
    type: Incomplete
    is_temp: int
    def analyse_types(self, env, getting: bool = True): ...
    def analyse_as_type(self, env): ...
    def nogil_check(self, env): ...
    gil_message: str
    get_slice_utility_code: Incomplete
    set_slice_utility_code: Incomplete
    def coerce_to(self, dst_type, env): ...
    def generate_result_code(self, code) -> None: ...
    def generate_assignment_code(self, rhs, code, overloaded_assignment: bool = False, exception_check: Incomplete | None = None, exception_value: Incomplete | None = None) -> None: ...
    def generate_deletion_code(self, code, ignore_nonexisting: bool = False) -> None: ...
    def get_slice_config(self): ...
    def generate_slice_guard_code(self, code, target_size) -> None: ...
    def start_code(self): ...
    def stop_code(self): ...
    def calculate_result_code(self): ...

class SliceNode(ExprNode):
    subexprs: Incomplete
    is_slice: bool
    type = slice_type
    is_temp: int
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def compile_time_value(self, denv): ...
    def may_be_none(self): ...
    start: Incomplete
    stop: Incomplete
    step: Incomplete
    is_literal: bool
    def analyse_types(self, env): ...
    gil_message: str
    def calculate_result_code(self): ...
    result_code: Incomplete
    def generate_result_code(self, code) -> None: ...

class SliceIntNode(SliceNode):
    is_temp: int
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def compile_time_value(self, denv): ...
    def may_be_none(self): ...
    start: Incomplete
    stop: Incomplete
    step: Incomplete
    is_literal: bool
    def analyse_types(self, env): ...
    def calculate_result_code(self) -> None: ...
    def generate_result_code(self, code) -> None: ...

class CallNode(ExprNode):
    may_return_none: Incomplete
    def infer_type(self, env): ...
    def type_dependencies(self, env): ...
    def is_simple(self): ...
    def may_be_none(self): ...
    type: Incomplete
    result_ctype: Incomplete
    def set_py_result_type(self, function, func_type: Incomplete | None = None) -> None: ...
    key_value_pairs: Incomplete
    __class__: Incomplete
    args: Incomplete
    function: Incomplete
    def analyse_as_type_constructor(self, env): ...
    def is_lvalue(self): ...
    def nogil_check(self, env) -> None: ...
    gil_message: str

class SimpleCallNode(CallNode):
    subexprs: Incomplete
    self: Incomplete
    coerced_self: Incomplete
    arg_tuple: Incomplete
    wrapper_call: bool
    has_optional_args: bool
    nogil: bool
    analysed: bool
    overflowcheck: bool
    def compile_time_value(self, denv): ...
    @classmethod
    def for_cproperty(cls, pos, obj, entry): ...
    def analyse_as_type(self, env): ...
    def explicit_args_kwds(self): ...
    function: Incomplete
    is_numpy_call_with_exprs: bool
    args: Incomplete
    is_temp: int
    def analyse_types(self, env): ...
    def function_type(self): ...
    type: Incomplete
    result_code: str
    result_ctype: Incomplete
    def analyse_c_function_call(self, env) -> None: ...
    def calculate_result_code(self): ...
    def c_call_code(self): ...
    def is_c_result_required(self): ...
    def generate_evaluation_code(self, code) -> None: ...
    opt_arg_struct: Incomplete
    def generate_result_code(self, code) -> None: ...

class NumPyMethodCallNode(ExprNode):
    subexprs: Incomplete
    is_temp: bool
    may_return_none: bool
    def generate_evaluation_code(self, code) -> None: ...

class PyMethodCallNode(SimpleCallNode):
    subexprs: Incomplete
    is_temp: bool
    def generate_evaluation_code(self, code): ...

class InlinedDefNodeCallNode(CallNode):
    subexprs: Incomplete
    is_temp: int
    type = py_object_type
    function: Incomplete
    function_name: Incomplete
    def can_be_inlined(self): ...
    args: Incomplete
    def analyse_types(self, env): ...
    def generate_result_code(self, code) -> None: ...

class PythonCapiFunctionNode(ExprNode):
    subexprs: Incomplete
    def __init__(self, pos, py_name, cname, func_type, utility_code: Incomplete | None = None) -> None: ...
    def analyse_types(self, env): ...
    def generate_result_code(self, code) -> None: ...
    def calculate_result_code(self): ...

class PythonCapiCallNode(SimpleCallNode):
    may_return_none: bool
    type: Incomplete
    result_ctype: Incomplete
    function: Incomplete
    def __init__(self, pos, function_name, func_type, utility_code: Incomplete | None = None, py_name: Incomplete | None = None, **kwargs) -> None: ...

class CachedBuiltinMethodCallNode(CallNode):
    subexprs: Incomplete
    is_temp: bool
    def __init__(self, call_node, obj, method_name, args) -> None: ...
    def may_be_none(self): ...
    def generate_result_code(self, code) -> None: ...

class GeneralCallNode(CallNode):
    type = py_object_type
    subexprs: Incomplete
    nogil_check: Incomplete
    def compile_time_value(self, denv): ...
    def explicit_args_kwds(self): ...
    function: Incomplete
    keyword_args: Incomplete
    positional_args: Incomplete
    is_temp: int
    def analyse_types(self, env): ...
    def map_to_simple_call_node(self):
        """
        Tries to map keyword arguments to declared positional arguments.
        Returns self to try a Python call, None to report an error
        or a SimpleCallNode if the mapping succeeds.
        """
    def generate_result_code(self, code) -> None: ...

class AsTupleNode(ExprNode):
    subexprs: Incomplete
    is_temp: int
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def compile_time_value(self, denv): ...
    arg: Incomplete
    type: Incomplete
    def analyse_types(self, env): ...
    def may_be_none(self): ...
    nogil_check: Incomplete
    gil_message: str
    def generate_result_code(self, code) -> None: ...

class MergedDictNode(ExprNode):
    subexprs: Incomplete
    is_temp: int
    type = dict_type
    reject_duplicates: bool
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def compile_time_value(self, denv): ...
    def type_dependencies(self, env): ...
    def infer_type(self, env): ...
    keyword_args: Incomplete
    def analyse_types(self, env): ...
    def may_be_none(self): ...
    gil_message: str
    def generate_evaluation_code(self, code) -> None: ...
    def annotate(self, code) -> None: ...

class AttributeNode(ExprNode):
    is_attribute: int
    subexprs: Incomplete
    entry: Incomplete
    is_called: int
    needs_none_check: bool
    is_memslice_transpose: bool
    is_special_lookup: bool
    is_py_attr: int
    def as_cython_attribute(self): ...
    is_temp: int
    obj: Incomplete
    def coerce_to(self, dst_type, env): ...
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def compile_time_value(self, denv): ...
    def type_dependencies(self, env): ...
    def infer_type(self, env): ...
    is_target: bool
    def analyse_target_declaration(self, env) -> None: ...
    def analyse_target_types(self, env): ...
    type: Incomplete
    initialized_check: Incomplete
    def analyse_types(self, env, target: int = 0): ...
    def analyse_as_cimported_attribute_node(self, env, target): ...
    def analyse_as_type_attribute(self, env): ...
    def analyse_as_type(self, env): ...
    def analyse_as_extension_type(self, env): ...
    def analyse_as_module(self, env): ...
    def as_name_node(self, env, entry, target): ...
    result_ctype: Incomplete
    def analyse_as_ordinary_attribute_node(self, env, target): ...
    member: Incomplete
    op: str
    use_managed_ref: bool
    def analyse_attribute(self, env, obj_type: Incomplete | None = None) -> None: ...
    attribute: Incomplete
    def analyse_as_python_attribute(self, env, obj_type: Incomplete | None = None, immutable_obj: bool = False) -> None: ...
    def wrap_obj_in_nonecheck(self, env) -> None: ...
    def nogil_check(self, env) -> None: ...
    gil_message: str
    def is_cimported_module_without_shadow(self, env): ...
    def is_simple(self): ...
    def is_lvalue(self): ...
    def is_ephemeral(self): ...
    def calculate_result_code(self): ...
    def calculate_access_code(self): ...
    def generate_result_code(self, code) -> None: ...
    def generate_disposal_code(self, code) -> None: ...
    def generate_assignment_code(self, rhs, code, overloaded_assignment: bool = False, exception_check: Incomplete | None = None, exception_value: Incomplete | None = None) -> None: ...
    def generate_deletion_code(self, code, ignore_nonexisting: bool = False) -> None: ...
    def annotate(self, code) -> None: ...
    def get_known_standard_library_import(self): ...

class StarredUnpackingNode(ExprNode):
    subexprs: Incomplete
    is_starred: int
    type = py_object_type
    is_temp: int
    starred_expr_allowed_here: bool
    def __init__(self, pos, target) -> None: ...
    def analyse_declarations(self, env) -> None: ...
    def infer_type(self, env): ...
    target: Incomplete
    def analyse_types(self, env): ...
    def analyse_target_declaration(self, env) -> None: ...
    def analyse_target_types(self, env): ...
    def calculate_result_code(self): ...
    def generate_result_code(self, code) -> None: ...

class SequenceNode(ExprNode):
    subexprs: Incomplete
    is_sequence_constructor: int
    unpacked_items: Incomplete
    mult_factor: Incomplete
    slow: bool
    def compile_time_value_list(self, denv): ...
    starred_assignment: bool
    args: Incomplete
    def replace_starred_target_node(self) -> None: ...
    def analyse_target_declaration(self, env) -> None: ...
    is_temp: int
    def analyse_types(self, env, skip_children: bool = False): ...
    def coerce_to_ctuple(self, dst_type, env): ...
    def may_be_none(self): ...
    coerced_unpacked_items: Incomplete
    any_coerced_items: bool
    type: Incomplete
    def analyse_target_types(self, env): ...
    def generate_result_code(self, code) -> None: ...
    def generate_sequence_packing_code(self, code, target: Incomplete | None = None, plain: bool = False) -> None: ...
    def generate_subexpr_disposal_code(self, code) -> None: ...
    def generate_assignment_code(self, rhs, code, overloaded_assignment: bool = False, exception_check: Incomplete | None = None, exception_value: Incomplete | None = None) -> None: ...
    def generate_parallel_assignment_code(self, rhs, code) -> None: ...
    def generate_special_parallel_unpacking_code(self, code, rhs, use_loop) -> None: ...
    def generate_generic_parallel_unpacking_code(self, code, rhs, unpacked_items, use_loop, terminate: bool = True): ...
    def generate_starred_assignment_code(self, rhs, code) -> None: ...
    def annotate(self, code) -> None: ...

class TupleNode(SequenceNode):
    type = tuple_type
    is_partly_literal: bool
    gil_message: str
    def infer_type(self, env): ...
    is_literal: bool
    is_temp: bool
    def analyse_types(self, env, skip_children: bool = False): ...
    def analyse_as_type(self, env): ...
    def coerce_to(self, dst_type, env): ...
    def as_list(self): ...
    def is_simple(self): ...
    def nonlocally_immutable(self): ...
    def calculate_result_code(self): ...
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def compile_time_value(self, denv): ...
    result_code: Incomplete
    def generate_operation_code(self, code) -> None: ...

class ListNode(SequenceNode):
    obj_conversion_errors: Incomplete
    type = list_type
    in_module_scope: bool
    gil_message: str
    def type_dependencies(self, env): ...
    def infer_type(self, env): ...
    def analyse_expressions(self, env): ...
    original_args: Incomplete
    def analyse_types(self, env): ...
    def coerce_to(self, dst_type, env): ...
    def as_list(self): ...
    def as_tuple(self): ...
    temp_code: Incomplete
    def allocate_temp_result(self, code) -> None: ...
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def compile_time_value(self, denv): ...
    def generate_operation_code(self, code) -> None: ...

class ComprehensionNode(ScopedExprNode):
    child_attrs: Incomplete
    is_temp: bool
    constant_result = not_a_constant
    def infer_type(self, env): ...
    def analyse_declarations(self, env) -> None: ...
    def analyse_scoped_declarations(self, env) -> None: ...
    loop: Incomplete
    def analyse_types(self, env): ...
    def analyse_scoped_expressions(self, env): ...
    def may_be_none(self): ...
    def generate_result_code(self, code) -> None: ...
    def generate_operation_code(self, code) -> None: ...
    def annotate(self, code) -> None: ...

class ComprehensionAppendNode(Node):
    child_attrs: Incomplete
    target: Incomplete
    type: Incomplete
    expr: Incomplete
    def analyse_expressions(self, env): ...
    def generate_execution_code(self, code) -> None: ...
    def generate_function_definitions(self, env, code) -> None: ...
    def annotate(self, code) -> None: ...

class DictComprehensionAppendNode(ComprehensionAppendNode):
    child_attrs: Incomplete
    key_expr: Incomplete
    value_expr: Incomplete
    def analyse_expressions(self, env): ...
    def generate_execution_code(self, code) -> None: ...
    def generate_function_definitions(self, env, code) -> None: ...
    def annotate(self, code) -> None: ...

class InlinedGeneratorExpressionNode(ExprNode):
    subexprs: Incomplete
    orig_func: Incomplete
    target: Incomplete
    is_temp: bool
    type = py_object_type
    def __init__(self, pos, gen, comprehension_type: Incomplete | None = None, **kwargs) -> None: ...
    def may_be_none(self): ...
    def infer_type(self, env): ...
    gen: Incomplete
    def analyse_types(self, env): ...
    def generate_result_code(self, code) -> None: ...

class MergedSequenceNode(ExprNode):
    """
    Merge a sequence of iterables into a set/list/tuple.

    The target collection is determined by self.type, which must be set externally.

    args    [ExprNode]
    """
    subexprs: Incomplete
    is_temp: bool
    gil_message: str
    def __init__(self, pos, args, type) -> None: ...
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def compile_time_value(self, denv): ...
    def type_dependencies(self, env): ...
    def infer_type(self, env): ...
    args: Incomplete
    def analyse_types(self, env): ...
    def may_be_none(self): ...
    def generate_evaluation_code(self, code) -> None: ...
    def annotate(self, code) -> None: ...

class SetNode(ExprNode):
    """
    Set constructor.
    """
    subexprs: Incomplete
    type = set_type
    is_set_literal: bool
    gil_message: str
    is_temp: int
    def analyse_types(self, env): ...
    def may_be_none(self): ...
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def compile_time_value(self, denv): ...
    def generate_evaluation_code(self, code) -> None: ...

class DictNode(ExprNode):
    subexprs: Incomplete
    is_temp: int
    exclude_null_values: bool
    type = dict_type
    is_dict_literal: bool
    reject_duplicates: bool
    obj_conversion_errors: Incomplete
    @classmethod
    def from_pairs(cls, pos, pairs): ...
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def compile_time_value(self, denv): ...
    def type_dependencies(self, env): ...
    def infer_type(self, env): ...
    key_value_pairs: Incomplete
    def analyse_types(self, env): ...
    def may_be_none(self): ...
    def coerce_to(self, dst_type, env): ...
    def release_errors(self) -> None: ...
    gil_message: str
    def generate_evaluation_code(self, code) -> None: ...
    def annotate(self, code) -> None: ...
    def as_python_dict(self): ...

class DictItemNode(ExprNode):
    subexprs: Incomplete
    nogil_check: Incomplete
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    key: Incomplete
    value: Incomplete
    def analyse_types(self, env): ...
    def generate_evaluation_code(self, code) -> None: ...
    def generate_disposal_code(self, code) -> None: ...
    def free_temps(self, code) -> None: ...
    def __iter__(self): ...

class SortedDictKeysNode(ExprNode):
    subexprs: Incomplete
    is_temp: bool
    type: Incomplete
    def __init__(self, arg) -> None: ...
    arg: Incomplete
    def analyse_types(self, env): ...
    def may_be_none(self): ...
    def generate_result_code(self, code) -> None: ...

class ModuleNameMixin:
    def get_py_mod_name(self, code): ...
    def get_py_qualified_name(self, code): ...

class ClassNode(ExprNode, ModuleNameMixin):
    subexprs: Incomplete
    type = py_object_type
    is_temp: bool
    def analyse_annotations(self, env) -> None: ...
    def infer_type(self, env): ...
    doc: Incomplete
    def analyse_types(self, env): ...
    def may_be_none(self): ...
    gil_message: str
    def generate_result_code(self, code) -> None: ...

class Py3ClassNode(ExprNode):
    subexprs: Incomplete
    type = py_object_type
    force_type: bool
    is_temp: bool
    def infer_type(self, env): ...
    def analyse_types(self, env): ...
    def may_be_none(self): ...
    gil_message: str
    def analyse_annotations(self, env) -> None: ...
    def generate_result_code(self, code) -> None: ...

class PyClassMetaclassNode(ExprNode):
    subexprs: Incomplete
    type: Incomplete
    is_temp: bool
    def analyse_types(self, env): ...
    def may_be_none(self): ...
    def generate_result_code(self, code) -> None: ...

class PyClassNamespaceNode(ExprNode, ModuleNameMixin):
    subexprs: Incomplete
    doc: Incomplete
    type: Incomplete
    is_temp: int
    def analyse_types(self, env): ...
    def may_be_none(self): ...
    def generate_result_code(self, code) -> None: ...

class ClassCellInjectorNode(ExprNode):
    is_temp: bool
    type = py_object_type
    subexprs: Incomplete
    is_active: bool
    def analyse_expressions(self, env): ...
    def generate_result_code(self, code) -> None: ...
    def generate_injection_code(self, code, classobj_cname) -> None: ...

class ClassCellNode(ExprNode):
    subexprs: Incomplete
    is_temp: bool
    is_generator: bool
    type = py_object_type
    def analyse_types(self, env): ...
    def generate_result_code(self, code) -> None: ...

class PyCFunctionNode(ExprNode, ModuleNameMixin):
    subexprs: Incomplete
    code_object: Incomplete
    binding: bool
    def_node: Incomplete
    defaults: Incomplete
    defaults_struct: Incomplete
    defaults_pyobjects: int
    defaults_tuple: Incomplete
    defaults_kwdict: Incomplete
    annotations_dict: Incomplete
    type = py_object_type
    is_temp: int
    specialized_cpdefs: Incomplete
    is_specialization: bool
    @classmethod
    def from_defnode(cls, node, binding): ...
    def analyse_types(self, env): ...
    def analyse_default_args(self, env) -> None:
        """
        Handle non-literal function's default arguments.
        """
    def may_be_none(self): ...
    gil_message: str
    def closure_result_code(self): ...
    def generate_result_code(self, code) -> None: ...
    def generate_pycfunction_code(self, code) -> None: ...
    def generate_cyfunction_code(self, code) -> None: ...

class InnerFunctionNode(PyCFunctionNode):
    binding: bool
    needs_closure_code: bool
    def closure_result_code(self): ...

class CodeObjectNode(ExprNode):
    subexprs: Incomplete
    is_temp: bool
    result_code: Incomplete
    varnames: Incomplete
    def __init__(self, def_node) -> None: ...
    def may_be_none(self): ...
    def calculate_result_code(self, code: Incomplete | None = None): ...
    def generate_result_code(self, code) -> None: ...

class DefaultLiteralArgNode(ExprNode):
    subexprs: Incomplete
    is_literal: bool
    is_temp: bool
    arg: Incomplete
    constant_result: Incomplete
    type: Incomplete
    evaluated: bool
    def __init__(self, pos, arg) -> None: ...
    def analyse_types(self, env): ...
    def generate_result_code(self, code) -> None: ...
    def generate_evaluation_code(self, code) -> None: ...
    def result(self): ...

class DefaultNonLiteralArgNode(ExprNode):
    subexprs: Incomplete
    arg: Incomplete
    defaults_struct: Incomplete
    def __init__(self, pos, arg, defaults_struct) -> None: ...
    type: Incomplete
    is_temp: bool
    def analyse_types(self, env): ...
    def generate_result_code(self, code) -> None: ...
    def result(self): ...

class DefaultsTupleNode(TupleNode):
    def __init__(self, pos, defaults, defaults_struct) -> None: ...
    def analyse_types(self, env, skip_children: bool = False): ...

class DefaultsKwDictNode(DictNode):
    def __init__(self, pos, defaults, defaults_struct) -> None: ...

class LambdaNode(InnerFunctionNode):
    child_attrs: Incomplete
    name: Incomplete
    lambda_name: Incomplete
    pymethdef_cname: Incomplete
    def analyse_declarations(self, env) -> None: ...
    def_node: Incomplete
    def analyse_types(self, env): ...
    def generate_result_code(self, code) -> None: ...

class GeneratorExpressionNode(LambdaNode):
    name: Incomplete
    binding: bool
    child_attrs: Incomplete
    subexprs: Incomplete
    call_parameters: Incomplete
    def __init__(self, pos, *args, **kwds) -> None: ...
    genexpr_name: Incomplete
    def analyse_declarations(self, env) -> None: ...
    def generate_result_code(self, code) -> None: ...

class YieldExprNode(ExprNode):
    subexprs: Incomplete
    type = py_object_type
    label_num: int
    is_yield_from: bool
    is_await: bool
    in_async_gen: bool
    expr_keyword: str
    is_temp: int
    arg: Incomplete
    def analyse_types(self, env): ...
    def coerce_yield_argument(self, env) -> None: ...
    def generate_evaluation_code(self, code) -> None: ...
    def generate_yield_code(self, code) -> None:
        """
        Generate the code to return the argument in 'Naming.retval_cname'
        and to continue at the yield label.
        """
    def generate_sent_value_handling_code(self, code, value_cname) -> None: ...

class _YieldDelegationExprNode(YieldExprNode):
    def yield_from_func(self, code) -> None: ...
    def generate_evaluation_code(self, code, source_cname: Incomplete | None = None, decref_source: bool = False) -> None: ...
    def fetch_iteration_result(self, code) -> None: ...
    def handle_iteration_exception(self, code) -> None: ...

class YieldFromExprNode(_YieldDelegationExprNode):
    is_yield_from: bool
    expr_keyword: str
    arg: Incomplete
    def coerce_yield_argument(self, env) -> None: ...
    def yield_from_func(self, code): ...

class AwaitExprNode(_YieldDelegationExprNode):
    is_await: bool
    expr_keyword: str
    arg: Incomplete
    def coerce_yield_argument(self, env) -> None: ...
    def yield_from_func(self, code): ...

class AwaitIterNextExprNode(AwaitExprNode):
    def fetch_iteration_result(self, code) -> None: ...
    def generate_sent_value_handling_code(self, code, value_cname) -> None: ...

class GlobalsExprNode(AtomicExprNode):
    type = dict_type
    is_temp: int
    def analyse_types(self, env): ...
    gil_message: str
    def may_be_none(self): ...
    def generate_result_code(self, code) -> None: ...

class LocalsDictItemNode(DictItemNode):
    key: Incomplete
    value: Incomplete
    def analyse_types(self, env): ...

class FuncLocalsExprNode(DictNode):
    def __init__(self, pos, env) -> None: ...
    def analyse_types(self, env): ...

class PyClassLocalsExprNode(AtomicExprNode):
    pyclass_dict: Incomplete
    def __init__(self, pos, pyclass_dict) -> None: ...
    type: Incomplete
    is_temp: bool
    def analyse_types(self, env): ...
    def may_be_none(self): ...
    def result(self): ...
    def generate_result_code(self, code) -> None: ...

def LocalsExprNode(pos, scope_node, env): ...

compile_time_unary_operators: Incomplete

class UnopNode(ExprNode):
    subexprs: Incomplete
    infix: bool
    is_inc_dec_op: bool
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def compile_time_value(self, denv): ...
    def infer_type(self, env): ...
    def infer_unop_type(self, env, operand_type): ...
    def may_be_none(self): ...
    operand: Incomplete
    type: Incomplete
    is_temp: int
    def analyse_types(self, env): ...
    def check_const(self): ...
    def is_py_operation(self): ...
    def is_pythran_operation(self, env): ...
    def nogil_check(self, env) -> None: ...
    def is_cpp_operation(self): ...
    def coerce_operand_to_pyobject(self, env) -> None: ...
    def generate_result_code(self, code) -> None: ...
    def generate_py_operation_code(self, code) -> None: ...
    def type_error(self) -> None: ...
    exception_check: Incomplete
    exception_value: Incomplete
    def analyse_cpp_operation(self, env, overload_check: bool = True) -> None: ...

class NotNode(UnopNode):
    operator: str
    type: Incomplete
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def compile_time_value(self, denv): ...
    def infer_unop_type(self, env, operand_type): ...
    operand: Incomplete
    def analyse_types(self, env): ...
    def calculate_result_code(self): ...

class UnaryPlusNode(UnopNode):
    operator: str
    type: Incomplete
    def analyse_c_operation(self, env) -> None: ...
    def py_operation_function(self, code): ...
    def calculate_result_code(self): ...

class UnaryMinusNode(UnopNode):
    operator: str
    type: Incomplete
    infix: bool
    def analyse_c_operation(self, env) -> None: ...
    def py_operation_function(self, code): ...
    def calculate_result_code(self): ...
    def get_constant_c_result_code(self): ...

class TildeNode(UnopNode):
    type: Incomplete
    def analyse_c_operation(self, env) -> None: ...
    def py_operation_function(self, code): ...
    def calculate_result_code(self): ...

class CUnopNode(UnopNode):
    def is_py_operation(self): ...

class DereferenceNode(CUnopNode):
    operator: str
    def infer_unop_type(self, env, operand_type): ...
    type: Incomplete
    def analyse_c_operation(self, env) -> None: ...
    def calculate_result_code(self): ...

class DecrementIncrementNode(CUnopNode):
    is_inc_dec_op: bool
    type: Incomplete
    def type_error(self) -> None: ...
    def analyse_c_operation(self, env) -> None: ...
    def calculate_result_code(self): ...

def inc_dec_constructor(is_prefix, operator): ...

class AmpersandNode(CUnopNode):
    operator: str
    def infer_unop_type(self, env, operand_type): ...
    operand: Incomplete
    type: Incomplete
    def analyse_types(self, env): ...
    def check_const(self): ...
    result_code: str
    def error(self, mess) -> None: ...
    def calculate_result_code(self): ...
    def generate_result_code(self, code) -> None: ...

unop_node_classes: Incomplete

def unop_node(pos, operator, operand): ...

class TypecastNode(ExprNode):
    subexprs: Incomplete
    base_type: Incomplete
    declarator: Incomplete
    type: Incomplete
    def type_dependencies(self, env): ...
    def infer_type(self, env): ...
    operand: Incomplete
    result_ctype: Incomplete
    def analyse_types(self, env): ...
    def is_simple(self): ...
    def is_ephemeral(self): ...
    def nonlocally_immutable(self): ...
    def nogil_check(self, env) -> None: ...
    def check_const(self): ...
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def calculate_result_code(self, operand_result: Incomplete | None = None): ...
    def get_constant_c_result_code(self): ...
    def result_as(self, type): ...
    def generate_result_code(self, code) -> None: ...

ERR_START: str
ERR_NOT_STOP: str
ERR_STEPS: str
ERR_NOT_POINTER: str
ERR_BASE_TYPE: str

class CythonArrayNode(ExprNode):
    """
    Used when a pointer of base_type is cast to a memoryviewslice with that
    base type. i.e.

        <int[:M:1, :N]> p

    creates a fortran-contiguous cython.array.

    We leave the type set to object so coercions to object are more efficient
    and less work. Acquiring a memoryviewslice from this will be just as
    efficient. ExprNode.coerce_to() will do the additional typecheck on
    self.compile_time_type

    This also handles <int[:, :]> my_c_array


    operand             ExprNode                 the thing we're casting
    base_type_node      MemoryViewSliceTypeNode  the cast expression node
    """
    subexprs: Incomplete
    shapes: Incomplete
    is_temp: bool
    mode: str
    array_dtype: Incomplete
    shape_type: Incomplete
    operand: Incomplete
    type: Incomplete
    coercion_type: Incomplete
    def analyse_types(self, env): ...
    temp_code: Incomplete
    def allocate_temp_result(self, code) -> None: ...
    def infer_type(self, env): ...
    def get_cython_array_type(self, env): ...
    def generate_result_code(self, code) -> None: ...
    @classmethod
    def from_carray(cls, src_node, env):
        """
        Given a C array type, return a CythonArrayNode
        """

class SizeofNode(ExprNode):
    type: Incomplete
    def check_const(self): ...
    def generate_result_code(self, code) -> None: ...

class SizeofTypeNode(SizeofNode):
    subexprs: Incomplete
    arg_type: Incomplete
    def analyse_types(self, env): ...
    def check_type(self) -> None: ...
    def calculate_result_code(self): ...

class SizeofVarNode(SizeofNode):
    subexprs: Incomplete
    arg_type: Incomplete
    __class__: Incomplete
    operand: Incomplete
    def analyse_types(self, env): ...
    def calculate_result_code(self): ...
    def generate_result_code(self, code) -> None: ...

class TypeidNode(ExprNode):
    subexprs: Incomplete
    arg_type: Incomplete
    is_variable: Incomplete
    is_temp: int
    def get_type_info_type(self, env): ...
    cpp_message: str
    type: Incomplete
    is_type: bool
    operand: Incomplete
    def analyse_types(self, env): ...
    result_code: str
    def error(self, mess) -> None: ...
    def check_const(self): ...
    def calculate_result_code(self): ...
    def generate_result_code(self, code) -> None: ...

class TypeofNode(ExprNode):
    literal: Incomplete
    type = py_object_type
    subexprs: Incomplete
    operand: Incomplete
    def analyse_types(self, env): ...
    def analyse_as_type(self, env): ...
    def may_be_none(self): ...
    def generate_evaluation_code(self, code) -> None: ...
    def calculate_result_code(self): ...

matmul_operator: Incomplete
compile_time_binary_operators: Incomplete

def get_compile_time_binop(node): ...

class BinopNode(ExprNode):
    subexprs: Incomplete
    inplace: bool
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def compile_time_value(self, denv): ...
    def infer_type(self, env): ...
    operand1: Incomplete
    operand2: Incomplete
    def analyse_types(self, env): ...
    type: Incomplete
    is_temp: int
    def analyse_operation(self, env) -> None: ...
    def is_py_operation(self): ...
    def is_py_operation_types(self, type1, type2): ...
    def is_pythran_operation(self, env): ...
    def is_pythran_operation_types(self, type1, type2, env): ...
    def is_cpp_operation(self): ...
    exception_check: Incomplete
    exception_value: Incomplete
    def analyse_cpp_operation(self, env) -> None: ...
    def result_type(self, type1, type2, env): ...
    def infer_builtin_types_operation(self, type1, type2) -> None: ...
    def nogil_check(self, env) -> None: ...
    def coerce_operands_to_pyobjects(self, env) -> None: ...
    def check_const(self): ...
    def is_ephemeral(self): ...
    def generate_result_code(self, code) -> None: ...
    def type_error(self) -> None: ...

class CBinopNode(BinopNode):
    def analyse_types(self, env): ...
    def py_operation_function(self, code): ...
    def calculate_result_code(self): ...
    def compute_c_result_type(self, type1, type2): ...

def c_binop_constructor(operator): ...

class NumBinopNode(BinopNode):
    infix: bool
    overflow_check: bool
    overflow_bit_node: Incomplete
    type: Incomplete
    overflow_fold: Incomplete
    func: Incomplete
    is_temp: bool
    operand1: Incomplete
    operand2: Incomplete
    def analyse_c_operation(self, env) -> None: ...
    def compute_c_result_type(self, type1, type2): ...
    def may_be_none(self): ...
    def get_constant_c_result_code(self): ...
    def c_types_okay(self, type1, type2): ...
    overflow_bit: Incomplete
    def generate_evaluation_code(self, code) -> None: ...
    def calculate_result_code(self): ...
    def is_py_operation_types(self, type1, type2): ...
    def py_operation_function(self, code): ...
    py_functions: Incomplete
    overflow_op_names: Incomplete

class IntBinopNode(NumBinopNode):
    def c_types_okay(self, type1, type2): ...

class AddNode(NumBinopNode):
    def is_py_operation_types(self, type1, type2): ...
    def infer_builtin_types_operation(self, type1, type2): ...
    def compute_c_result_type(self, type1, type2): ...
    def py_operation_function(self, code): ...

class SubNode(NumBinopNode):
    def compute_c_result_type(self, type1, type2): ...

class MulNode(NumBinopNode):
    is_sequence_mul: bool
    operand1: Incomplete
    operand2: Incomplete
    def analyse_types(self, env): ...
    @staticmethod
    def is_builtin_seqmul_type(type): ...
    def calculate_is_sequence_mul(self): ...
    def analyse_sequence_mul(self, env, seq, mult): ...
    def coerce_operands_to_pyobjects(self, env) -> None: ...
    def is_py_operation_types(self, type1, type2): ...
    def py_operation_function(self, code): ...
    def infer_builtin_types_operation(self, type1, type2): ...

class MatMultNode(NumBinopNode):
    def is_py_operation_types(self, type1, type2): ...
    def generate_evaluation_code(self, code) -> None: ...

class DivNode(NumBinopNode):
    cdivision: Incomplete
    truedivision: Incomplete
    ctruedivision: bool
    cdivision_warnings: bool
    zerodivision_check: Incomplete
    def find_compile_time_binary_operator(self, op1, op2): ...
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def compile_time_value(self, denv): ...
    def infer_type(self, env): ...
    operand1: Incomplete
    operand2: Incomplete
    def analyse_operation(self, env) -> None: ...
    def compute_c_result_type(self, type1, type2): ...
    def zero_division_message(self): ...
    def generate_evaluation_code(self, code) -> None: ...
    def generate_div_warning_code(self, code) -> None: ...
    def calculate_result_code(self): ...

class ModNode(DivNode):
    def is_py_operation_types(self, type1, type2): ...
    def infer_builtin_types_operation(self, type1, type2): ...
    def zero_division_message(self): ...
    cdivision: Incomplete
    def analyse_operation(self, env) -> None: ...
    def generate_evaluation_code(self, code) -> None: ...
    def calculate_result_code(self): ...
    def py_operation_function(self, code): ...

class PowNode(NumBinopNode):
    is_cpow: Incomplete
    type_was_inferred: bool
    def infer_type(self, env): ...
    def analyse_types(self, env): ...
    operand1: Incomplete
    operand2: Incomplete
    pow_func: Incomplete
    def analyse_c_operation(self, env) -> None: ...
    def compute_c_result_type(self, type1, type2): ...
    def calculate_result_code(self): ...
    def py_operation_function(self, code): ...
    def coerce_to(self, dst_type, env): ...

class BoolBinopNode(ExprNode):
    '''
    Short-circuiting boolean operation.

    Note that this node provides the same code generation method as
    BoolBinopResultNode to simplify expression nesting.

    operator  string                              "and"/"or"
    operand1  BoolBinopNode/BoolBinopResultNode   left operand
    operand2  BoolBinopNode/BoolBinopResultNode   right operand
    '''
    subexprs: Incomplete
    is_temp: bool
    operator: Incomplete
    operand1: Incomplete
    operand2: Incomplete
    def infer_type(self, env): ...
    def may_be_none(self): ...
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def compile_time_value(self, denv): ...
    def is_ephemeral(self): ...
    type: Incomplete
    def analyse_types(self, env): ...
    def wrap_operands(self, env) -> None:
        """
        Must get called by transforms that want to create a correct BoolBinopNode
        after the type analysis phase.
        """
    def coerce_to_boolean(self, env): ...
    def coerce_to(self, dst_type, env): ...
    def generate_bool_evaluation_code(self, code, final_result_temp, final_result_type, and_label, or_label, end_label, fall_through) -> None: ...
    def generate_evaluation_code(self, code) -> None: ...
    gil_message: str
    def check_const(self): ...
    def generate_subexpr_disposal_code(self, code) -> None: ...
    def free_subexpr_temps(self, code) -> None: ...
    def generate_operand1_test(self, code): ...

class BoolBinopResultNode(ExprNode):
    """
    Intermediate result of a short-circuiting and/or expression.
    Tests the result for 'truthiness' and takes care of coercing the final result
    of the overall expression to the target type.

    Note that this node provides the same code generation method as
    BoolBinopNode to simplify expression nesting.

    arg     ExprNode    the argument to test
    value   ExprNode    the coerced result value node
    """
    subexprs: Incomplete
    is_temp: bool
    arg: Incomplete
    value: Incomplete
    def __init__(self, arg, result_type, env) -> None: ...
    def coerce_to_boolean(self, env): ...
    def coerce_to(self, dst_type, env): ...
    def nogil_check(self, env) -> None: ...
    def generate_operand_test(self, code): ...
    def generate_bool_evaluation_code(self, code, final_result_temp, final_result_type, and_label, or_label, end_label, fall_through) -> None: ...
    def analyse_types(self, env): ...

class CondExprNode(ExprNode):
    true_val: Incomplete
    false_val: Incomplete
    is_temp: bool
    subexprs: Incomplete
    def type_dependencies(self, env): ...
    def infer_type(self, env): ...
    constant_result: Incomplete
    def calculate_constant_result(self) -> None: ...
    def is_ephemeral(self): ...
    test: Incomplete
    def analyse_types(self, env): ...
    type: Incomplete
    result_ctype: Incomplete
    def analyse_result_type(self, env): ...
    def coerce_to_integer(self, env): ...
    def coerce_to(self, dst_type, env): ...
    def type_error(self) -> None: ...
    def check_const(self): ...
    def generate_evaluation_code(self, code) -> None: ...
    def eval_and_get(self, code, expr) -> None: ...
    def generate_subexpr_disposal_code(self, code) -> None: ...
    def free_subexpr_temps(self, code) -> None: ...

richcmp_constants: Incomplete

class CmpNode:
    special_bool_cmp_function: Incomplete
    special_bool_cmp_utility_code: Incomplete
    special_bool_extra_args: Incomplete
    def infer_type(self, env): ...
    constant_result: Incomplete
    operand2: Incomplete
    def calculate_cascaded_constant_result(self, operand1_result) -> None: ...
    def cascaded_compile_time_value(self, operand1, denv): ...
    def is_cpp_comparison(self): ...
    def find_common_int_type(self, env, op, operand1, operand2): ...
    def find_common_type(self, env, op, operand1, common_type: Incomplete | None = None): ...
    def invalid_types_error(self, operand1, op, operand2) -> None: ...
    def is_python_comparison(self): ...
    def coerce_operands_to(self, dst_type, env) -> None: ...
    def is_python_result(self): ...
    def is_c_string_contains(self): ...
    def is_ptr_contains(self): ...
    def find_special_bool_compare_function(self, env, operand1, result_is_bool: bool = False): ...
    def generate_operation_code(self, code, result_code, operand1, op, operand2) -> None: ...
    def c_operator(self, op): ...

class PrimaryCmpNode(ExprNode, CmpNode):
    child_attrs: Incomplete
    cascade: Incomplete
    coerced_operand2: Incomplete
    is_memslice_nonecheck: bool
    def infer_type(self, env): ...
    def type_dependencies(self, env): ...
    def calculate_constant_result(self) -> None: ...
    def compile_time_value(self, denv): ...
    def unify_cascade_type(self) -> None: ...
    operand1: Incomplete
    operand2: Incomplete
    type: Incomplete
    is_pycmp: bool
    is_temp: int
    def analyse_types(self, env): ...
    result_code: str
    exception_check: Incomplete
    exception_value: Incomplete
    def analyse_cpp_comparison(self, env) -> None: ...
    def analyse_memoryviewslice_comparison(self, env): ...
    def coerce_to_boolean(self, env): ...
    def has_python_operands(self): ...
    def check_const(self): ...
    def calculate_result_code(self): ...
    def generate_evaluation_code(self, code) -> None: ...
    def generate_subexpr_disposal_code(self, code) -> None: ...
    def free_subexpr_temps(self, code) -> None: ...
    def annotate(self, code) -> None: ...

class CascadedCmpNode(Node, CmpNode):
    child_attrs: Incomplete
    cascade: Incomplete
    coerced_operand2: Incomplete
    constant_result = constant_value_not_set
    def infer_type(self, env): ...
    def type_dependencies(self, env): ...
    def has_constant_result(self): ...
    operand2: Incomplete
    def analyse_types(self, env): ...
    def has_python_operands(self): ...
    def is_cpp_comparison(self): ...
    is_pycmp: bool
    type: Incomplete
    def optimise_comparison(self, operand1, env, result_is_bool: bool = False): ...
    def coerce_operands_to_pyobjects(self, env) -> None: ...
    def coerce_cascaded_operands_to_temp(self, env) -> None: ...
    def generate_evaluation_code(self, code, result, operand1, needs_evaluation: bool = False) -> None: ...
    def annotate(self, code) -> None: ...

binop_node_classes: Incomplete

def binop_node(pos, operator, operand1, operand2, inplace: bool = False, **kwargs): ...

class CoercionNode(ExprNode):
    subexprs: Incomplete
    constant_result = not_a_constant
    arg: Incomplete
    def __init__(self, arg) -> None: ...
    def calculate_constant_result(self) -> None: ...
    def annotate(self, code) -> None: ...
    def analyse_types(self, env): ...

class CoerceToMemViewSliceNode(CoercionNode):
    """
    Coerce an object to a memoryview slice. This holds a new reference in
    a managed temp.
    """
    type: Incomplete
    is_temp: int
    use_managed_ref: bool
    arg: Incomplete
    def __init__(self, arg, dst_type, env) -> None: ...
    def generate_result_code(self, code) -> None: ...

class CastNode(CoercionNode):
    type: Incomplete
    def __init__(self, arg, new_type) -> None: ...
    def may_be_none(self): ...
    def calculate_result_code(self): ...
    def generate_result_code(self, code) -> None: ...

class PyTypeTestNode(CoercionNode):
    exact_builtin_type: bool
    type: Incomplete
    result_ctype: Incomplete
    notnone: Incomplete
    def __init__(self, arg, dst_type, env, notnone: bool = False) -> None: ...
    nogil_check: Incomplete
    gil_message: str
    def analyse_types(self, env): ...
    def may_be_none(self): ...
    def is_simple(self): ...
    def result_in_temp(self): ...
    def is_ephemeral(self): ...
    def nonlocally_immutable(self): ...
    def reanalyse(self): ...
    def calculate_constant_result(self) -> None: ...
    def calculate_result_code(self): ...
    def generate_result_code(self, code) -> None: ...
    def generate_post_assignment_code(self, code) -> None: ...
    def allocate_temp_result(self, code) -> None: ...
    def release_temp_result(self, code) -> None: ...
    def free_temps(self, code) -> None: ...
    def free_subexpr_temps(self, code) -> None: ...

class NoneCheckNode(CoercionNode):
    is_nonecheck: bool
    type: Incomplete
    result_ctype: Incomplete
    exception_type_cname: Incomplete
    exception_message: Incomplete
    exception_format_args: Incomplete
    def __init__(self, arg, exception_type_cname, exception_message, exception_format_args=()) -> None: ...
    nogil_check: Incomplete
    def analyse_types(self, env): ...
    def may_be_none(self): ...
    def is_simple(self): ...
    def result_in_temp(self): ...
    def nonlocally_immutable(self): ...
    def calculate_result_code(self): ...
    def condition(self): ...
    @classmethod
    def generate(cls, arg, code, exception_message, exception_type_cname: str = 'PyExc_TypeError', exception_format_args=(), in_nogil_context: bool = False) -> None: ...
    @classmethod
    def generate_if_needed(cls, arg, code, exception_message, exception_type_cname: str = 'PyExc_TypeError', exception_format_args=(), in_nogil_context: bool = False) -> None: ...
    def put_nonecheck(self, code) -> None: ...
    def generate_result_code(self, code) -> None: ...
    def generate_post_assignment_code(self, code) -> None: ...
    def free_temps(self, code) -> None: ...

class CoerceToPyTypeNode(CoercionNode):
    type = py_object_type
    target_type = py_object_type
    is_temp: int
    def __init__(self, arg, env, type=...) -> None: ...
    gil_message: str
    def may_be_none(self): ...
    def coerce_to_boolean(self, env): ...
    def coerce_to_integer(self, env): ...
    def analyse_types(self, env): ...
    def generate_result_code(self, code) -> None: ...

class CoerceIntToBytesNode(CoerceToPyTypeNode):
    is_temp: int
    type: Incomplete
    def __init__(self, arg, env) -> None: ...
    def generate_result_code(self, code) -> None: ...

class CoerceFromPyTypeNode(CoercionNode):
    special_none_cvalue: Incomplete
    type: Incomplete
    is_temp: int
    def __init__(self, result_type, arg, env) -> None: ...
    def analyse_types(self, env): ...
    def is_ephemeral(self): ...
    def generate_result_code(self, code) -> None: ...
    def nogil_check(self, env) -> None: ...

class CoerceToBooleanNode(CoercionNode):
    type: Incomplete
    is_temp: int
    def __init__(self, arg, env) -> None: ...
    def nogil_check(self, env) -> None: ...
    gil_message: str
    def check_const(self): ...
    def calculate_result_code(self): ...
    def generate_result_code(self, code) -> None: ...
    def analyse_types(self, env): ...

class CoerceToComplexNode(CoercionNode):
    type: Incomplete
    def __init__(self, arg, dst_type, env) -> None: ...
    def calculate_result_code(self): ...
    def generate_result_code(self, code) -> None: ...
    def analyse_types(self, env): ...

def coerce_from_soft_complex(arg, dst_type, env): ...

class CoerceToTempNode(CoercionNode):
    type: Incomplete
    constant_result: Incomplete
    is_temp: int
    result_ctype: Incomplete
    def __init__(self, arg, env) -> None: ...
    gil_message: str
    def analyse_types(self, env): ...
    def may_be_none(self): ...
    arg: Incomplete
    def coerce_to_boolean(self, env): ...
    def generate_result_code(self, code) -> None: ...

class ProxyNode(CoercionNode):
    """
    A node that should not be replaced by transforms or other means,
    and hence can be useful to wrap the argument to a clone node

    MyNode    -> ProxyNode -> ArgNode
    CloneNode -^
    """
    nogil_check: Incomplete
    constant_result: Incomplete
    def __init__(self, arg) -> None: ...
    arg: Incomplete
    def analyse_types(self, env): ...
    def infer_type(self, env): ...
    type: Incomplete
    result_ctype: Incomplete
    entry: Incomplete
    def update_type_and_entry(self) -> None: ...
    def generate_result_code(self, code) -> None: ...
    def result(self): ...
    def is_simple(self): ...
    def may_be_none(self): ...
    def generate_evaluation_code(self, code) -> None: ...
    def generate_disposal_code(self, code) -> None: ...
    def free_temps(self, code) -> None: ...

class CloneNode(CoercionNode):
    subexprs: Incomplete
    nogil_check: Incomplete
    constant_result: Incomplete
    type: Incomplete
    result_ctype: Incomplete
    entry: Incomplete
    def __init__(self, arg) -> None: ...
    def result(self): ...
    def may_be_none(self): ...
    def type_dependencies(self, env): ...
    def infer_type(self, env): ...
    is_temp: int
    def analyse_types(self, env): ...
    def coerce_to(self, dest_type, env): ...
    def is_simple(self): ...
    def generate_evaluation_code(self, code) -> None: ...
    def generate_result_code(self, code) -> None: ...
    def generate_disposal_code(self, code) -> None: ...
    def generate_post_assignment_code(self, code) -> None: ...
    def free_temps(self, code) -> None: ...

class CppOptionalTempCoercion(CoercionNode):
    """
    Used only in CoerceCppTemps - handles cases the temp is actually a OptionalCppClassType (and thus needs dereferencing when on the rhs)
    """
    is_temp: bool
    @property
    def type(self): ...
    def calculate_result_code(self): ...
    def generate_result_code(self, code) -> None: ...

class CMethodSelfCloneNode(CloneNode):
    def coerce_to(self, dst_type, env): ...

class ModuleRefNode(ExprNode):
    type = py_object_type
    is_temp: bool
    subexprs: Incomplete
    def analyse_types(self, env): ...
    def may_be_none(self): ...
    def calculate_result_code(self): ...
    def generate_result_code(self, code) -> None: ...

class DocstringRefNode(ExprNode):
    subexprs: Incomplete
    type = py_object_type
    is_temp: bool
    body: Incomplete
    def __init__(self, pos, body) -> None: ...
    def analyse_types(self, env): ...
    def generate_result_code(self, code) -> None: ...

class AnnotationNode(ExprNode):
    subexprs: Incomplete
    untyped: bool
    string: Incomplete
    expr: Incomplete
    def __init__(self, pos, expr, string: Incomplete | None = None) -> None:
        """string is expected to already be a StringNode or None"""
    def analyse_types(self, env): ...
    def analyse_as_type(self, env): ...
    def analyse_type_annotation(self, env, assigned_value: Incomplete | None = None): ...

class AssignmentExpressionNode(ExprNode):
    """
    Also known as a named expression or the walrus operator

    Arguments
    lhs - NameNode - not stored directly as an attribute of the node
    rhs - ExprNode

    Attributes
    rhs        - ExprNode
    assignment - SingleAssignmentNode
    """
    subexprs: Incomplete
    child_attrs: Incomplete
    is_temp: bool
    assignment: Incomplete
    clone_node: Incomplete
    rhs: Incomplete
    def __init__(self, pos, lhs, rhs, **kwds) -> None: ...
    @property
    def type(self): ...
    @property
    def target_name(self): ...
    def infer_type(self, env): ...
    def analyse_declarations(self, env) -> None: ...
    def analyse_types(self, env): ...
    def coerce_to(self, dst_type, env): ...
    def calculate_result_code(self): ...
    def generate_result_code(self, code) -> None: ...
