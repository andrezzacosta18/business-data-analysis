from . import DebugFlags as DebugFlags, Naming as Naming, Options as Options, StringEncoding as StringEncoding
from .. import Utils as Utils
from ..StringIOTree import StringIOTree as StringIOTree
from .Scanning import SourceDescriptor as SourceDescriptor
from _typeshed import Incomplete
from collections.abc import Generator

non_portable_builtins_map: Incomplete
ctypedef_builtins_map: Incomplete
basicsize_builtins_map: Incomplete
uncachable_builtins: Incomplete
special_py_methods: Incomplete
modifier_output_mapper: Incomplete

class IncludeCode:
    """
    An include file and/or verbatim C code to be included in the
    generated sources.
    """
    INITIAL: int
    EARLY: int
    LATE: int
    counter: int
    order: Incomplete
    pieces: Incomplete
    location: Incomplete
    def __init__(self, include: Incomplete | None = None, verbatim: Incomplete | None = None, late: bool = True, initial: bool = False) -> None: ...
    def dict_update(self, d, key) -> None:
        """
        Insert `self` in dict `d` with key `key`. If that key already
        exists, update the attributes of the existing value with `self`.
        """
    def sortkey(self): ...
    def mainpiece(self):
        """
        Return the main piece of C code, corresponding to the include
        file. If there was no include file, return None.
        """
    def write(self, code) -> None: ...

def get_utility_dir(): ...

read_utilities_hook: Incomplete

def read_utilities_from_utility_dir(path):
    """
    Read all lines of the file at the provided path from a path relative
    to get_utility_dir().
    """
read_utilities_hook = read_utilities_from_utility_dir

class UtilityCodeBase:
    """
    Support for loading utility code from a file.

    Code sections in the file can be specified as follows:

        ##### MyUtility.proto #####

        [proto declarations]

        ##### MyUtility.init #####

        [code run at module initialization]

        ##### MyUtility #####
        #@requires: MyOtherUtility
        #@substitute: naming

        [definitions]

        ##### MyUtility #####
        #@substitute: tempita

        [requires tempita substitution
         - context can't be specified here though so only
           tempita utility that requires no external context
           will benefit from this tag
         - only necessary when @required from non-tempita code]

    for prototypes and implementation respectively.  For non-python or
    -cython files backslashes should be used instead.  5 to 30 comment
    characters may be used on either side.

    If the @cname decorator is not used and this is a CythonUtilityCode,
    one should pass in the 'name' keyword argument to be used for name
    mangling of such entries.
    """
    is_cython_utility: bool
    @classmethod
    def load_utilities_from_file(cls, path): ...
    @classmethod
    def load(cls, util_code_name, from_file, **kwargs):
        """
        Load utility code from a file specified by from_file (relative to
        Cython/Utility) and name util_code_name.
        """
    @classmethod
    def load_cached(cls, utility_code_name, from_file, __cache={}):
        """
        Calls .load(), but using a per-type cache based on utility name and file name.
        """
    @classmethod
    def load_as_string(cls, util_code_name, from_file, **kwargs):
        """
        Load a utility code as a string. Returns (proto, implementation)
        """
    def format_code(self, code_string, replace_empty_lines=...):
        """
        Format a code section for output.
        """
    def get_tree(self, **kwargs) -> None: ...
    def __deepcopy__(self, memodict: Incomplete | None = None): ...

class UtilityCode(UtilityCodeBase):
    """
    Stores utility code to add during code generation.

    See GlobalState.put_utility_code.

    hashes/equals by instance

    proto           C prototypes
    impl            implementation code
    init            code to call on module initialization
    requires        utility code dependencies
    proto_block     the place in the resulting file where the prototype should
                    end up
    name            name of the utility code (or None)
    file            filename of the utility code file this utility was loaded
                    from (or None)
    """
    proto: Incomplete
    impl: Incomplete
    init: Incomplete
    cleanup: Incomplete
    requires: Incomplete
    specialize_list: Incomplete
    proto_block: Incomplete
    name: Incomplete
    file: Incomplete
    def __init__(self, proto: Incomplete | None = None, impl: Incomplete | None = None, init: Incomplete | None = None, cleanup: Incomplete | None = None, requires: Incomplete | None = None, proto_block: str = 'utility_code_proto', name: Incomplete | None = None, file: Incomplete | None = None) -> None: ...
    def __hash__(self): ...
    def __eq__(self, other): ...
    def none_or_sub(self, s, context):
        """
        Format a string in this utility code with context. If None, do nothing.
        """
    def specialize(self, pyrex_type: Incomplete | None = None, **data): ...
    def inject_string_constants(self, impl, output):
        '''Replace \'PYIDENT("xyz")\' by a constant Python identifier cname.
        '''
    def inject_unbound_methods(self, impl, output):
        '''Replace \'UNBOUND_METHOD(type, "name")\' by a constant Python identifier cname.
        '''
    def wrap_c_strings(self, impl):
        """Replace CSTRING('''xyz''') by a C compatible string
        """
    def put_code(self, output) -> None: ...

def sub_tempita(s, context, file: Incomplete | None = None, name: Incomplete | None = None):
    """Run tempita on string s with given context."""

class TempitaUtilityCode(UtilityCode):
    def __init__(self, name: Incomplete | None = None, proto: Incomplete | None = None, impl: Incomplete | None = None, init: Incomplete | None = None, file: Incomplete | None = None, context: Incomplete | None = None, **kwargs) -> None: ...
    @classmethod
    def load_cached(cls, utility_code_name, from_file: Incomplete | None = None, context: Incomplete | None = None, __cache={}): ...
    def none_or_sub(self, s, context):
        """
        Format a string in this utility code with context. If None, do nothing.
        """

class LazyUtilityCode(UtilityCodeBase):
    """
    Utility code that calls a callback with the root code writer when
    available. Useful when you only have 'env' but not 'code'.
    """
    requires: Incomplete
    callback: Incomplete
    def __init__(self, callback) -> None: ...
    def put_code(self, globalstate) -> None: ...

class FunctionState:
    names_taken: Incomplete
    owner: Incomplete
    scope: Incomplete
    error_label: Incomplete
    label_counter: int
    labels_used: Incomplete
    return_label: Incomplete
    continue_label: Incomplete
    break_label: Incomplete
    yield_labels: Incomplete
    in_try_finally: int
    exc_vars: Incomplete
    current_except: Incomplete
    can_trace: bool
    gil_owned: bool
    temps_allocated: Incomplete
    temps_free: Incomplete
    temps_used_type: Incomplete
    zombie_temps: Incomplete
    temp_counter: int
    closure_temps: Incomplete
    collect_temps_stack: Incomplete
    should_declare_error_indicator: bool
    uses_error_indicator: bool
    error_without_exception: bool
    needs_refnanny: bool
    def __init__(self, owner, names_taken=..., scope: Incomplete | None = None) -> None: ...
    def validate_exit(self) -> None: ...
    def new_label(self, name: Incomplete | None = None): ...
    def new_yield_label(self, expr_type: str = 'yield'): ...
    def new_error_label(self, prefix: str = ''): ...
    def get_loop_labels(self): ...
    def set_loop_labels(self, labels) -> None: ...
    def new_loop_labels(self, prefix: str = ''): ...
    def get_all_labels(self): ...
    def set_all_labels(self, labels) -> None: ...
    def all_new_labels(self): ...
    def use_label(self, lbl) -> None: ...
    def label_used(self, lbl): ...
    def allocate_temp(self, type, manage_ref, static: bool = False, reusable: bool = True):
        '''
        Allocates a temporary (which may create a new one or get a previously
        allocated and released one of the same type). Type is simply registered
        and handed back, but will usually be a PyrexType.

        If type.needs_refcounting, manage_ref comes into play. If manage_ref is set to
        True, the temp will be decref-ed on return statements and in exception
        handling clauses. Otherwise the caller has to deal with any reference
        counting of the variable.

        If not type.needs_refcounting, then manage_ref will be ignored, but it
        still has to be passed. It is recommended to pass False by convention
        if it is known that type will never be a reference counted type.

        static=True marks the temporary declaration with "static".
        This is only used when allocating backing store for a module-level
        C array literals.

        if reusable=False, the temp will not be reused after release.

        A C string referring to the variable is returned.
        '''
    def release_temp(self, name) -> None:
        """
        Releases a temporary so that it can be reused by other code needing
        a temp of the same type.
        """
    def temps_in_use(self):
        """Return a list of (cname,type,manage_ref) tuples of temp names and their type
        that are currently in use.
        """
    def temps_holding_reference(self):
        """Return a list of (cname,type) tuples of temp names and their type
        that are currently in use. This includes only temps
        with a reference counted type which owns its reference.
        """
    def all_managed_temps(self):
        """Return a list of (cname, type) tuples of refcount-managed Python objects.
        """
    def all_free_managed_temps(self):
        """Return a list of (cname, type) tuples of refcount-managed Python
        objects that are not currently in use.  This is used by
        try-except and try-finally blocks to clean up temps in the
        error case.
        """
    def start_collecting_temps(self) -> None:
        """
        Useful to find out which temps were used in a code block
        """
    def stop_collecting_temps(self): ...
    def init_closure_temps(self, scope) -> None: ...

class NumConst:
    """Global info about a Python number constant held by GlobalState.

    cname       string
    value       string
    py_type     string     int, long, float
    value_code  string     evaluation code if different from value
    """
    cname: Incomplete
    value: Incomplete
    py_type: Incomplete
    value_code: Incomplete
    def __init__(self, cname, value, py_type, value_code: Incomplete | None = None) -> None: ...

class PyObjectConst:
    """Global info about a generic constant held by GlobalState.
    """
    cname: Incomplete
    type: Incomplete
    def __init__(self, cname, type) -> None: ...

possible_unicode_identifier: Incomplete
possible_bytes_identifier: Incomplete
replace_identifier: Incomplete
find_alphanums: Incomplete

class StringConst:
    """Global info about a C string constant held by GlobalState.
    """
    cname: Incomplete
    text: Incomplete
    escaped_value: Incomplete
    py_strings: Incomplete
    py_versions: Incomplete
    def __init__(self, cname, text, byte_string) -> None: ...
    def add_py_version(self, version) -> None: ...
    def get_py_string_const(self, encoding, identifier: Incomplete | None = None, is_str: bool = False, py3str_cstring: Incomplete | None = None): ...

class PyStringConst:
    """Global info about a Python string constant held by GlobalState.
    """
    cname: Incomplete
    py3str_cstring: Incomplete
    encoding: Incomplete
    is_str: Incomplete
    is_unicode: Incomplete
    intern: Incomplete
    def __init__(self, cname, encoding, is_unicode, is_str: bool = False, py3str_cstring: Incomplete | None = None, intern: bool = False) -> None: ...
    def __lt__(self, other): ...

class GlobalState:
    directives: Incomplete
    code_layout: Incomplete
    h_code_layout: Incomplete
    filename_table: Incomplete
    filename_list: Incomplete
    input_file_contents: Incomplete
    utility_codes: Incomplete
    declared_cnames: Incomplete
    in_utility_code_generation: bool
    code_config: Incomplete
    common_utility_include_dir: Incomplete
    parts: Incomplete
    module_node: Incomplete
    const_cnames_used: Incomplete
    string_const_index: Incomplete
    dedup_const_index: Incomplete
    pyunicode_ptr_const_index: Incomplete
    num_const_index: Incomplete
    py_constants: Incomplete
    cached_cmethods: Incomplete
    initialised_constants: Incomplete
    rootwriter: Incomplete
    def __init__(self, writer, module_node, code_config, common_utility_include_dir: Incomplete | None = None) -> None: ...
    def initialize_main_c_code(self) -> None: ...
    def initialize_main_h_code(self) -> None: ...
    def finalize_main_c_code(self) -> None: ...
    def __getitem__(self, key): ...
    def close_global_decls(self) -> None: ...
    def put_pyobject_decl(self, entry) -> None: ...
    def get_cached_constants_writer(self, target: Incomplete | None = None): ...
    def get_int_const(self, str_value, longness: bool = False): ...
    def get_float_const(self, str_value, value_code): ...
    def get_py_const(self, type, prefix: str = '', cleanup_level: Incomplete | None = None, dedup_key: Incomplete | None = None): ...
    def get_string_const(self, text, py_version: Incomplete | None = None): ...
    def get_pyunicode_ptr_const(self, text): ...
    def get_py_string_const(self, text, identifier: Incomplete | None = None, is_str: bool = False, unicode_value: Incomplete | None = None): ...
    def get_interned_identifier(self, text): ...
    def new_string_const(self, text, byte_string): ...
    def new_num_const(self, value, py_type, value_code: Incomplete | None = None): ...
    def new_py_const(self, type, prefix: str = ''): ...
    def new_string_const_cname(self, bytes_value): ...
    def unique_const_cname(self, format_str: str) -> str: ...
    def new_num_const_cname(self, value: str, py_type: str) -> str: ...
    def new_const_cname(self, prefix: str = '', value: str = ''): ...
    def get_cached_unbound_method(self, type_cname, method_name): ...
    def cached_unbound_method_call_code(self, obj_cname, type_cname, method_name, arg_cnames): ...
    def add_cached_builtin_decl(self, entry) -> None: ...
    def put_cached_builtin_init(self, pos, name, cname) -> None: ...
    def generate_const_declarations(self) -> None: ...
    def generate_object_constant_decls(self) -> None: ...
    def generate_cached_methods_decls(self) -> None: ...
    def generate_string_constants(self) -> None: ...
    def generate_num_constants(self) -> None: ...
    def should_declare(self, cname, entry): ...
    def lookup_filename(self, source_desc): ...
    def commented_file_contents(self, source_desc): ...
    def use_utility_code(self, utility_code) -> None:
        """
        Adds code to the C file. utility_code should
        a) implement __eq__/__hash__ for the purpose of knowing whether the same
           code has already been included
        b) implement put_code, which takes a globalstate instance

        See UtilityCode.
        """
    def use_entry_utility_code(self, entry) -> None: ...

def funccontext_property(func): ...

class CCodeConfig:
    emit_code_comments: Incomplete
    emit_linenums: Incomplete
    c_line_in_traceback: Incomplete
    def __init__(self, emit_linenums: bool = True, emit_code_comments: bool = True, c_line_in_traceback: bool = True) -> None: ...

class CCodeWriter:
    """
    Utility class to output C code.

    When creating an insertion point one must care about the state that is
    kept:
    - formatting state (level, bol) is cloned and used in insertion points
      as well
    - labels, temps, exc_vars: One must construct a scope in which these can
      exist by calling enter_cfunc_scope/exit_cfunc_scope (these are for
      sanity checking and forward compatibility). Created insertion points
      looses this scope and cannot access it.
    - marker: Not copied to insertion point
    - filename_table, filename_list, input_file_contents: All codewriters
      coming from the same root share the same instances simultaneously.
    """
    buffer: Incomplete
    last_pos: Incomplete
    last_marked_pos: Incomplete
    pyclass_stack: Incomplete
    funcstate: Incomplete
    globalstate: Incomplete
    code_config: Incomplete
    level: int
    call_level: int
    bol: int
    def __init__(self, create_from: Incomplete | None = None, buffer: Incomplete | None = None, copy_formatting: bool = False) -> None: ...
    def create_new(self, create_from, buffer, copy_formatting): ...
    def set_global_state(self, global_state) -> None: ...
    def copyto(self, f) -> None: ...
    def getvalue(self): ...
    def write(self, s) -> None: ...
    def insertion_point(self): ...
    def new_writer(self):
        """
        Creates a new CCodeWriter connected to the same global state, which
        can later be inserted using insert.
        """
    def insert(self, writer) -> None:
        """
        Inserts the contents of another code writer (created with
        the same global state) in the current location.

        It is ok to write to the inserted writer also after insertion.
        """
    def label_counter(self) -> None: ...
    def return_label(self) -> None: ...
    def error_label(self) -> None: ...
    def labels_used(self) -> None: ...
    def continue_label(self) -> None: ...
    def break_label(self) -> None: ...
    def return_from_error_cleanup_label(self) -> None: ...
    def yield_labels(self) -> None: ...
    def label_interceptor(self, new_labels, orig_labels, skip_to_label: Incomplete | None = None, pos: Incomplete | None = None, trace: bool = True) -> Generator[Incomplete, None, None]:
        """
        Helper for generating multiple label interceptor code blocks.

        @param new_labels: the new labels that should be intercepted
        @param orig_labels: the original labels that we should dispatch to after the interception
        @param skip_to_label: a label to skip to before starting the code blocks
        @param pos: the node position to mark for each interceptor block
        @param trace: add a trace line for the pos marker or not
        """
    def new_label(self, name: Incomplete | None = None): ...
    def new_error_label(self, *args): ...
    def new_yield_label(self, *args): ...
    def get_loop_labels(self): ...
    def set_loop_labels(self, labels): ...
    def new_loop_labels(self, *args): ...
    def get_all_labels(self): ...
    def set_all_labels(self, labels): ...
    def all_new_labels(self): ...
    def use_label(self, lbl): ...
    def label_used(self, lbl): ...
    def enter_cfunc_scope(self, scope: Incomplete | None = None) -> None: ...
    def exit_cfunc_scope(self) -> None: ...
    def get_py_int(self, str_value, longness): ...
    def get_py_float(self, str_value, value_code): ...
    def get_py_const(self, type, prefix: str = '', cleanup_level: Incomplete | None = None, dedup_key: Incomplete | None = None): ...
    def get_string_const(self, text): ...
    def get_pyunicode_ptr_const(self, text): ...
    def get_py_string_const(self, text, identifier: Incomplete | None = None, is_str: bool = False, unicode_value: Incomplete | None = None): ...
    def get_argument_default_const(self, type): ...
    def intern(self, text): ...
    def intern_identifier(self, text): ...
    def get_cached_constants_writer(self, target: Incomplete | None = None): ...
    def putln(self, code: str = '', safe: bool = False) -> None: ...
    def mark_pos(self, pos, trace: bool = True) -> None: ...
    def emit_marker(self) -> None: ...
    def put_safe(self, code) -> None: ...
    def put_or_include(self, code, name) -> None: ...
    def put(self, code) -> None: ...
    def putln_tempita(self, code, **context) -> None: ...
    def put_tempita(self, code, **context) -> None: ...
    def increase_indent(self) -> None: ...
    def decrease_indent(self) -> None: ...
    def begin_block(self) -> None: ...
    def end_block(self) -> None: ...
    def indent(self) -> None: ...
    def get_py_version_hex(self, pyversion): ...
    def put_label(self, lbl) -> None: ...
    def put_goto(self, lbl) -> None: ...
    def put_var_declaration(self, entry, storage_class: str = '', dll_linkage: Incomplete | None = None, definition: bool = True) -> None: ...
    def put_temp_declarations(self, func_context) -> None: ...
    def put_generated_by(self) -> None: ...
    def put_h_guard(self, guard) -> None: ...
    def unlikely(self, cond): ...
    def build_function_modifiers(self, modifiers, mapper=...): ...
    def entry_as_pyobject(self, entry): ...
    def as_pyobject(self, cname, type): ...
    def put_gotref(self, cname, type) -> None: ...
    def put_giveref(self, cname, type) -> None: ...
    def put_xgiveref(self, cname, type) -> None: ...
    def put_xgotref(self, cname, type) -> None: ...
    def put_incref(self, cname, type, nanny: bool = True) -> None: ...
    def put_xincref(self, cname, type, nanny: bool = True) -> None: ...
    def put_decref(self, cname, type, nanny: bool = True, have_gil: bool = True) -> None: ...
    def put_xdecref(self, cname, type, nanny: bool = True, have_gil: bool = True) -> None: ...
    def put_decref_clear(self, cname, type, clear_before_decref: bool = False, nanny: bool = True, have_gil: bool = True) -> None: ...
    def put_xdecref_clear(self, cname, type, clear_before_decref: bool = False, nanny: bool = True, have_gil: bool = True) -> None: ...
    def put_decref_set(self, cname, type, rhs_cname) -> None: ...
    def put_xdecref_set(self, cname, type, rhs_cname) -> None: ...
    def put_incref_memoryviewslice(self, slice_cname, type, have_gil) -> None: ...
    def put_var_incref_memoryviewslice(self, entry, have_gil) -> None: ...
    def put_var_gotref(self, entry) -> None: ...
    def put_var_giveref(self, entry) -> None: ...
    def put_var_xgotref(self, entry) -> None: ...
    def put_var_xgiveref(self, entry) -> None: ...
    def put_var_incref(self, entry, **kwds) -> None: ...
    def put_var_xincref(self, entry, **kwds) -> None: ...
    def put_var_decref(self, entry, **kwds) -> None: ...
    def put_var_xdecref(self, entry, **kwds) -> None: ...
    def put_var_decref_clear(self, entry, **kwds) -> None: ...
    def put_var_decref_set(self, entry, rhs_cname, **kwds) -> None: ...
    def put_var_xdecref_set(self, entry, rhs_cname, **kwds) -> None: ...
    def put_var_xdecref_clear(self, entry, **kwds) -> None: ...
    def put_var_decrefs(self, entries, used_only: int = 0) -> None: ...
    def put_var_xdecrefs(self, entries) -> None: ...
    def put_var_xdecrefs_clear(self, entries) -> None: ...
    def put_init_to_py_none(self, cname, type, nanny: bool = True) -> None: ...
    def put_init_var_to_py_none(self, entry, template: str = '%s', nanny: bool = True) -> None: ...
    def put_pymethoddef(self, entry, term, allow_skip: bool = True, wrapper_code_writer: Incomplete | None = None) -> None: ...
    def put_pymethoddef_wrapper(self, entry): ...
    def use_fast_gil_utility_code(self) -> None: ...
    def put_ensure_gil(self, declare_gilstate: bool = True, variable: Incomplete | None = None) -> None:
        """
        Acquire the GIL. The generated code is safe even when no PyThreadState
        has been allocated for this thread (for threads not initialized by
        using the Python API). Additionally, the code generated by this method
        may be called recursively.
        """
    def put_release_ensured_gil(self, variable: Incomplete | None = None) -> None:
        """
        Releases the GIL, corresponds to `put_ensure_gil`.
        """
    def put_acquire_gil(self, variable: Incomplete | None = None, unknown_gil_state: bool = True) -> None:
        """
        Acquire the GIL. The thread's thread state must have been initialized
        by a previous `put_release_gil`
        """
    def put_release_gil(self, variable: Incomplete | None = None, unknown_gil_state: bool = True) -> None:
        """Release the GIL, corresponds to `put_acquire_gil`."""
    def declare_gilstate(self) -> None: ...
    def put_error_if_neg(self, pos, value): ...
    def put_error_if_unbound(self, pos, entry, in_nogil_context: bool = False, unbound_check_code: Incomplete | None = None) -> None: ...
    def set_error_info(self, pos, used: bool = False): ...
    def error_goto(self, pos, used: bool = True): ...
    def error_goto_if(self, cond, pos): ...
    def error_goto_if_null(self, cname, pos): ...
    def error_goto_if_neg(self, cname, pos): ...
    def error_goto_if_PyErr(self, pos): ...
    def lookup_filename(self, filename): ...
    def put_declare_refcount_context(self) -> None: ...
    def put_setup_refcount_context(self, name, acquire_gil: bool = False) -> None: ...
    def put_finish_refcount_context(self, nogil: bool = False) -> None: ...
    def put_add_traceback(self, qualified_name, include_cline: bool = True) -> None:
        """
        Build a Python traceback for propagating exceptions.

        qualified_name should be the qualified name of the function.
        """
    def put_unraisable(self, qualified_name, nogil: bool = False) -> None:
        """
        Generate code to print a Python warning for an unraisable exception.

        qualified_name should be the qualified name of the function.
        """
    def put_trace_declarations(self) -> None: ...
    def put_trace_frame_init(self, codeobj: Incomplete | None = None) -> None: ...
    def put_trace_call(self, name, pos, nogil: bool = False) -> None: ...
    def put_trace_exception(self) -> None: ...
    def put_trace_return(self, retvalue_cname, nogil: bool = False) -> None: ...
    def putln_openmp(self, string) -> None: ...
    def undef_builtin_expect(self, cond) -> None:
        """
        Redefine the macros likely() and unlikely to no-ops, depending on
        condition 'cond'
        """
    def redef_builtin_expect(self, cond) -> None: ...

class PyrexCodeWriter:
    f: Incomplete
    level: int
    def __init__(self, outfile_name) -> None: ...
    def putln(self, code) -> None: ...
    def indent(self) -> None: ...
    def dedent(self) -> None: ...

class PyxCodeWriter:
    """
    Can be used for writing out some Cython code.
    """
    buffer: Incomplete
    level: Incomplete
    original_level: Incomplete
    context: Incomplete
    encoding: Incomplete
    def __init__(self, buffer: Incomplete | None = None, indent_level: int = 0, context: Incomplete | None = None, encoding: str = 'ascii') -> None: ...
    def indent(self, levels: int = 1): ...
    def dedent(self, levels: int = 1) -> None: ...
    def indenter(self, line) -> Generator[None, None, None]:
        '''
        with pyx_code.indenter("for i in range(10):"):
            pyx_code.putln("print i")
        '''
    def empty(self): ...
    def getvalue(self): ...
    def putln(self, line, context: Incomplete | None = None) -> None: ...
    def put_chunk(self, chunk, context: Incomplete | None = None) -> None: ...
    def insertion_point(self): ...
    def reset(self) -> None: ...
    def named_insertion_point(self, name) -> None: ...

class ClosureTempAllocator:
    klass: Incomplete
    temps_allocated: Incomplete
    temps_free: Incomplete
    temps_count: int
    def __init__(self, klass) -> None: ...
    def reset(self) -> None: ...
    def allocate_temp(self, type): ...
