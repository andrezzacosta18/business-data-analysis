import unittest
from .. import libcython as libcython, libpython as libpython
from ...Utils import add_metaclass as add_metaclass
from _typeshed import Incomplete

def print_on_call_decorator(func): ...

class TraceMethodCallMeta(type):
    def __init__(self, name, bases, dict) -> None: ...

class DebugTestCase(unittest.TestCase):
    """
    Base class for test cases. On teardown it kills the inferior and unsets
    all breakpoints.
    """
    cy: Incomplete
    module: Incomplete
    ham_func: Incomplete
    eggs_func: Incomplete
    def __init__(self, name) -> None: ...
    def read_var(self, varname, cast_to: Incomplete | None = None): ...
    def local_info(self): ...
    def lineno_equals(self, source_line: Incomplete | None = None, lineno: Incomplete | None = None) -> None: ...
    def break_and_run(self, source_line) -> None: ...
    def tearDown(self) -> None: ...

class TestDebugInformationClasses(DebugTestCase):
    def test_CythonModule(self) -> None:
        """test that debug information was parsed properly into data structures"""
    def test_CythonVariable(self) -> None: ...
    def test_CythonFunction(self) -> None: ...

class TestParameters(unittest.TestCase):
    def test_parameters(self) -> None: ...

class TestBreak(DebugTestCase):
    def test_break(self) -> None: ...
    def test_python_break(self) -> None: ...
    def test_break_lineno(self) -> None: ...

class DebugStepperTestCase(DebugTestCase):
    def step(self, varnames_and_values, source_line: Incomplete | None = None, lineno: Incomplete | None = None) -> None: ...

class TestStep(DebugStepperTestCase):
    """
    Test stepping. Stepping happens in the code found in
    Cython/Debugger/Tests/codefile.
    """
    command: str
    def test_cython_step(self) -> None: ...
    def test_c_step(self) -> None: ...
    def test_python_step(self) -> None: ...

class TestNext(DebugStepperTestCase):
    def test_cython_next(self) -> None: ...

class TestLocalsGlobals(DebugTestCase):
    def test_locals(self) -> None: ...
    def test_globals(self) -> None: ...

class TestBacktrace(DebugTestCase):
    def test_backtrace(self) -> None: ...

class TestFunctions(DebugTestCase):
    def test_functions(self) -> None: ...

class TestPrint(DebugTestCase):
    def test_print(self) -> None: ...

correct_result_test_list_inside_func: str
correct_result_test_list_outside_func: str

class TestList(DebugTestCase):
    def workaround_for_coding_style_checker(self, correct_result_wrong_whitespace) -> None: ...
    def test_list_inside_func(self) -> None: ...
    def test_list_outside_func(self) -> None: ...

class TestUpDown(DebugTestCase):
    def test_updown(self) -> None: ...

class TestExec(DebugTestCase):
    tmpfile: Incomplete
    def setUp(self) -> None: ...
    def tearDown(self) -> None: ...
    def eval_command(self, command): ...
    def test_cython_exec(self) -> None: ...
    def test_python_exec(self) -> None: ...

class CySet(DebugTestCase):
    def test_cyset(self) -> None: ...

class TestCyEval(DebugTestCase):
    """Test the $cy_eval() gdb function."""
    def test_cy_eval(self) -> None: ...

class TestClosure(DebugTestCase):
    def break_and_run_func(self, funcname) -> None: ...
    def test_inner(self) -> None: ...
    def test_outer(self) -> None: ...

def run_unittest_in_module(modulename): ...
def runtests() -> None:
    """
    Run the libcython and libpython tests. Ensure that an appropriate status is
    returned to the parent test process.
    """
def main(version, trace_code: bool = False) -> None: ...
