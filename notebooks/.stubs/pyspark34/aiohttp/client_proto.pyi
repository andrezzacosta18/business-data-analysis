import asyncio
from .base_protocol import BaseProtocol as BaseProtocol
from .client_exceptions import ClientOSError as ClientOSError, ClientPayloadError as ClientPayloadError, ServerDisconnectedError as ServerDisconnectedError, ServerTimeoutError as ServerTimeoutError
from .helpers import BaseTimerContext as BaseTimerContext
from .http import HttpResponseParser as HttpResponseParser, RawResponseMessage as RawResponseMessage
from .streams import DataQueue as DataQueue, EMPTY_PAYLOAD as EMPTY_PAYLOAD, StreamReader as StreamReader
from _typeshed import Incomplete
from typing import Any, Tuple

class ResponseHandler(BaseProtocol, DataQueue[Tuple[RawResponseMessage, StreamReader]]):
    """Helper class to adapt between Protocol and StreamReader."""
    def __init__(self, loop: asyncio.AbstractEventLoop) -> None: ...
    @property
    def upgraded(self) -> bool: ...
    @property
    def should_close(self) -> bool: ...
    def force_close(self) -> None: ...
    transport: Incomplete
    def close(self) -> None: ...
    def is_connected(self) -> bool: ...
    def connection_lost(self, exc: BaseException | None) -> None: ...
    def eof_received(self) -> None: ...
    def pause_reading(self) -> None: ...
    def resume_reading(self) -> None: ...
    def set_exception(self, exc: BaseException) -> None: ...
    def set_parser(self, parser: Any, payload: Any) -> None: ...
    def set_response_params(self, *, timer: BaseTimerContext | None = None, skip_payload: bool = False, read_until_eof: bool = False, auto_decompress: bool = True, read_timeout: float | None = None, read_bufsize: int = ...) -> None: ...
    def data_received(self, data: bytes) -> None: ...
