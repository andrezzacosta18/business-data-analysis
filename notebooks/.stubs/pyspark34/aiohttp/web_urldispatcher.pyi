import abc
from .abc import AbstractMatchInfo, AbstractRouter, AbstractView
from .typedefs import Handler, PathLike, TypedDict
from .web_app import Application
from .web_exceptions import HTTPException
from .web_request import Request
from .web_response import StreamResponse
from .web_routedef import AbstractRouteDef
from _typeshed import Incomplete
from pathlib import Path
from typing import Any, Container, Dict, Generator, Iterable, Iterator, List, Mapping, Pattern, Sized, Tuple, Type
from yarl import URL

__all__ = ['UrlDispatcher', 'UrlMappingMatchInfo', 'AbstractResource', 'Resource', 'PlainResource', 'DynamicResource', 'AbstractRoute', 'ResourceRoute', 'StaticResource', 'View']

BaseDict = Dict[str, str]

class _InfoDict(TypedDict, total=False):
    path: str
    formatter: str
    pattern: Pattern[str]
    directory: Path
    prefix: str
    routes: Mapping[str, 'AbstractRoute']
    app: Application
    domain: str
    rule: AbstractRuleMatching
    http_exception: HTTPException

class AbstractResource(Sized, Iterable['AbstractRoute'], metaclass=abc.ABCMeta):
    def __init__(self, *, name: str | None = None) -> None: ...
    @property
    def name(self) -> str | None: ...
    @property
    @abc.abstractmethod
    def canonical(self) -> str:
        """Exposes the resource's canonical path.

        For example '/foo/bar/{name}'

        """
    @abc.abstractmethod
    def url_for(self, **kwargs: str) -> URL:
        """Construct url for resource with additional params."""
    @abc.abstractmethod
    async def resolve(self, request: Request) -> _Resolve:
        """Resolve resource.

        Return (UrlMappingMatchInfo, allowed_methods) pair.
        """
    @abc.abstractmethod
    def add_prefix(self, prefix: str) -> None:
        """Add a prefix to processed URLs.

        Required for subapplications support.
        """
    @abc.abstractmethod
    def get_info(self) -> _InfoDict:
        """Return a dict with additional info useful for introspection"""
    def freeze(self) -> None: ...
    @abc.abstractmethod
    def raw_match(self, path: str) -> bool:
        """Perform a raw match against path"""

class AbstractRoute(abc.ABC, metaclass=abc.ABCMeta):
    def __init__(self, method: str, handler: Handler | Type[AbstractView], *, expect_handler: _ExpectHandler | None = None, resource: AbstractResource | None = None) -> None: ...
    @property
    def method(self) -> str: ...
    @property
    def handler(self) -> Handler: ...
    @property
    @abc.abstractmethod
    def name(self) -> str | None:
        """Optional route's name, always equals to resource's name."""
    @property
    def resource(self) -> AbstractResource | None: ...
    @abc.abstractmethod
    def get_info(self) -> _InfoDict:
        """Return a dict with additional info useful for introspection"""
    @abc.abstractmethod
    def url_for(self, *args: str, **kwargs: str) -> URL:
        """Construct url for route with additional params."""
    async def handle_expect_header(self, request: Request) -> None: ...

class UrlMappingMatchInfo(BaseDict, AbstractMatchInfo):
    def __init__(self, match_dict: Dict[str, str], route: AbstractRoute) -> None: ...
    @property
    def handler(self) -> Handler: ...
    @property
    def route(self) -> AbstractRoute: ...
    @property
    def expect_handler(self) -> _ExpectHandler: ...
    @property
    def http_exception(self) -> HTTPException | None: ...
    def get_info(self) -> _InfoDict: ...
    @property
    def apps(self) -> Tuple['Application', ...]: ...
    def add_app(self, app: Application) -> None: ...
    @property
    def current_app(self) -> Application: ...
    def set_current_app(self, app: Application) -> Generator[None, None, None]: ...
    def freeze(self) -> None: ...

class MatchInfoError(UrlMappingMatchInfo):
    def __init__(self, http_exception: HTTPException) -> None: ...
    @property
    def http_exception(self) -> HTTPException: ...

class Resource(AbstractResource, metaclass=abc.ABCMeta):
    def __init__(self, *, name: str | None = None) -> None: ...
    def add_route(self, method: str, handler: Type[AbstractView] | Handler, *, expect_handler: _ExpectHandler | None = None) -> ResourceRoute: ...
    def register_route(self, route: ResourceRoute) -> None: ...
    async def resolve(self, request: Request) -> _Resolve: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[AbstractRoute]: ...

class PlainResource(Resource):
    def __init__(self, path: str, *, name: str | None = None) -> None: ...
    @property
    def canonical(self) -> str: ...
    def freeze(self) -> None: ...
    def add_prefix(self, prefix: str) -> None: ...
    def raw_match(self, path: str) -> bool: ...
    def get_info(self) -> _InfoDict: ...
    def url_for(self) -> URL: ...

class DynamicResource(Resource):
    DYN: Incomplete
    DYN_WITH_RE: Incomplete
    GOOD: str
    def __init__(self, path: str, *, name: str | None = None) -> None: ...
    @property
    def canonical(self) -> str: ...
    def add_prefix(self, prefix: str) -> None: ...
    def raw_match(self, path: str) -> bool: ...
    def get_info(self) -> _InfoDict: ...
    def url_for(self, **parts: str) -> URL: ...

class PrefixResource(AbstractResource, metaclass=abc.ABCMeta):
    def __init__(self, prefix: str, *, name: str | None = None) -> None: ...
    @property
    def canonical(self) -> str: ...
    def add_prefix(self, prefix: str) -> None: ...
    def raw_match(self, prefix: str) -> bool: ...

class StaticResource(PrefixResource):
    VERSION_KEY: str
    def __init__(self, prefix: str, directory: PathLike, *, name: str | None = None, expect_handler: _ExpectHandler | None = None, chunk_size: int = ..., show_index: bool = False, follow_symlinks: bool = False, append_version: bool = False) -> None: ...
    def url_for(self, *, filename: str | Path, append_version: bool | None = None) -> URL: ...
    def get_info(self) -> _InfoDict: ...
    def set_options_route(self, handler: Handler) -> None: ...
    async def resolve(self, request: Request) -> _Resolve: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[AbstractRoute]: ...

class PrefixedSubAppResource(PrefixResource):
    def __init__(self, prefix: str, app: Application) -> None: ...
    def add_prefix(self, prefix: str) -> None: ...
    def url_for(self, *args: str, **kwargs: str) -> URL: ...
    def get_info(self) -> _InfoDict: ...
    async def resolve(self, request: Request) -> _Resolve: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[AbstractRoute]: ...

class AbstractRuleMatching(abc.ABC, metaclass=abc.ABCMeta):
    @abc.abstractmethod
    async def match(self, request: Request) -> bool:
        """Return bool if the request satisfies the criteria"""
    @abc.abstractmethod
    def get_info(self) -> _InfoDict:
        """Return a dict with additional info useful for introspection"""
    @property
    @abc.abstractmethod
    def canonical(self) -> str:
        """Return a str"""

class Domain(AbstractRuleMatching):
    re_part: Incomplete
    def __init__(self, domain: str) -> None: ...
    @property
    def canonical(self) -> str: ...
    def validation(self, domain: str) -> str: ...
    async def match(self, request: Request) -> bool: ...
    def match_domain(self, host: str) -> bool: ...
    def get_info(self) -> _InfoDict: ...

class MaskDomain(Domain):
    re_part: Incomplete
    def __init__(self, domain: str) -> None: ...
    @property
    def canonical(self) -> str: ...
    def match_domain(self, host: str) -> bool: ...

class MatchedSubAppResource(PrefixedSubAppResource):
    def __init__(self, rule: AbstractRuleMatching, app: Application) -> None: ...
    @property
    def canonical(self) -> str: ...
    def get_info(self) -> _InfoDict: ...
    async def resolve(self, request: Request) -> _Resolve: ...

class ResourceRoute(AbstractRoute):
    """A route with resource"""
    def __init__(self, method: str, handler: Handler | Type[AbstractView], resource: AbstractResource, *, expect_handler: _ExpectHandler | None = None) -> None: ...
    @property
    def name(self) -> str | None: ...
    def url_for(self, *args: str, **kwargs: str) -> URL:
        """Construct url for route with additional params."""
    def get_info(self) -> _InfoDict: ...

class SystemRoute(AbstractRoute):
    def __init__(self, http_exception: HTTPException) -> None: ...
    def url_for(self, *args: str, **kwargs: str) -> URL: ...
    @property
    def name(self) -> str | None: ...
    def get_info(self) -> _InfoDict: ...
    @property
    def status(self) -> int: ...
    @property
    def reason(self) -> str: ...

class View(AbstractView):
    def __await__(self) -> Generator[Any, None, StreamResponse]: ...

class ResourcesView(Sized, Iterable[AbstractResource], Container[AbstractResource]):
    def __init__(self, resources: List[AbstractResource]) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[AbstractResource]: ...
    def __contains__(self, resource: object) -> bool: ...

class RoutesView(Sized, Iterable[AbstractRoute], Container[AbstractRoute]):
    def __init__(self, resources: List[AbstractResource]) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[AbstractRoute]: ...
    def __contains__(self, route: object) -> bool: ...

class UrlDispatcher(AbstractRouter, Mapping[str, AbstractResource]):
    NAME_SPLIT_RE: Incomplete
    def __init__(self) -> None: ...
    async def resolve(self, request: Request) -> UrlMappingMatchInfo: ...
    def __iter__(self) -> Iterator[str]: ...
    def __len__(self) -> int: ...
    def __contains__(self, resource: object) -> bool: ...
    def __getitem__(self, name: str) -> AbstractResource: ...
    def resources(self) -> ResourcesView: ...
    def routes(self) -> RoutesView: ...
    def named_resources(self) -> Mapping[str, AbstractResource]: ...
    def register_resource(self, resource: AbstractResource) -> None: ...
    def add_resource(self, path: str, *, name: str | None = None) -> Resource: ...
    def add_route(self, method: str, path: str, handler: Handler | Type[AbstractView], *, name: str | None = None, expect_handler: _ExpectHandler | None = None) -> AbstractRoute: ...
    def add_static(self, prefix: str, path: PathLike, *, name: str | None = None, expect_handler: _ExpectHandler | None = None, chunk_size: int = ..., show_index: bool = False, follow_symlinks: bool = False, append_version: bool = False) -> AbstractResource:
        """Add static files view.

        prefix - url prefix
        path - folder with files

        """
    def add_head(self, path: str, handler: Handler, **kwargs: Any) -> AbstractRoute:
        """Shortcut for add_route with method HEAD."""
    def add_options(self, path: str, handler: Handler, **kwargs: Any) -> AbstractRoute:
        """Shortcut for add_route with method OPTIONS."""
    def add_get(self, path: str, handler: Handler, *, name: str | None = None, allow_head: bool = True, **kwargs: Any) -> AbstractRoute:
        """Shortcut for add_route with method GET.

        If allow_head is true, another
        route is added allowing head requests to the same endpoint.
        """
    def add_post(self, path: str, handler: Handler, **kwargs: Any) -> AbstractRoute:
        """Shortcut for add_route with method POST."""
    def add_put(self, path: str, handler: Handler, **kwargs: Any) -> AbstractRoute:
        """Shortcut for add_route with method PUT."""
    def add_patch(self, path: str, handler: Handler, **kwargs: Any) -> AbstractRoute:
        """Shortcut for add_route with method PATCH."""
    def add_delete(self, path: str, handler: Handler, **kwargs: Any) -> AbstractRoute:
        """Shortcut for add_route with method DELETE."""
    def add_view(self, path: str, handler: Type[AbstractView], **kwargs: Any) -> AbstractRoute:
        """Shortcut for add_route with ANY methods for a class-based view."""
    def freeze(self) -> None: ...
    def add_routes(self, routes: Iterable[AbstractRouteDef]) -> List[AbstractRoute]:
        """Append routes to route table.

        Parameter should be a sequence of RouteDef objects.

        Returns a list of registered AbstractRoute instances.
        """
