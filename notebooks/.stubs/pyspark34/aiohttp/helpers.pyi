import abc
import asyncio
from ._helpers import reify as reify_c
from .typedefs import Protocol
from _typeshed import Incomplete
from multidict import MultiDictProxy
from types import TracebackType
from typing import Any, Callable, ContextManager, Generator, Generic, Iterable, Iterator, Mapping, NamedTuple, Type
from yarl import URL

__all__ = ['BasicAuth', 'ChainMapProxy', 'ETag']

all_tasks = asyncio.all_tasks

class noop:
    def __await__(self) -> Generator[None, None, None]: ...

class BasicAuth(NamedTuple('BasicAuth', [('login', Incomplete), ('password', Incomplete), ('encoding', Incomplete)])):
    """Http basic authentication helper."""
    def __new__(cls, login: str, password: str = '', encoding: str = 'latin1') -> BasicAuth: ...
    @classmethod
    def decode(cls, auth_header: str, encoding: str = 'latin1') -> BasicAuth:
        """Create a BasicAuth object from an Authorization HTTP header."""
    @classmethod
    def from_url(cls, url: URL, *, encoding: str = 'latin1') -> BasicAuth | None:
        """Create BasicAuth from url."""
    def encode(self) -> str:
        """Encode credentials."""

class ProxyInfo:
    proxy: URL
    proxy_auth: BasicAuth | None
    def __init__(self) -> None: ...
    def __lt__(self, other): ...
    def __le__(self, other): ...
    def __gt__(self, other): ...
    def __ge__(self, other): ...

class MimeType:
    type: str
    subtype: str
    suffix: str
    parameters: MultiDictProxy[str]
    def __init__(self) -> None: ...
    def __lt__(self, other): ...
    def __le__(self, other): ...
    def __gt__(self, other): ...
    def __ge__(self, other): ...

class _TSelf(Protocol, Generic[_T]): ...

class reify(Generic[_T]):
    """Use as a class method decorator.

    It operates almost exactly like
    the Python `@property` decorator, but it puts the result of the
    method it decorates into the instance dict after the first call,
    effectively replacing the function it decorates with an instance
    variable.  It is, in Python parlance, a data descriptor.
    """
    wrapped: Incomplete
    __doc__: Incomplete
    name: Incomplete
    def __init__(self, wrapped: Callable[..., _T]) -> None: ...
    def __get__(self, inst: _TSelf[_T], owner: Type[Any] | None = None) -> _T: ...
    def __set__(self, inst: _TSelf[_T], value: _T) -> None: ...
reify_py = reify
reify = reify_c

class TimeoutHandle:
    """Timeout handle"""
    def __init__(self, loop: asyncio.AbstractEventLoop, timeout: float | None) -> None: ...
    def register(self, callback: Callable[..., None], *args: Any, **kwargs: Any) -> None: ...
    def close(self) -> None: ...
    def start(self) -> asyncio.Handle | None: ...
    def timer(self) -> BaseTimerContext: ...
    def __call__(self) -> None: ...

class BaseTimerContext(ContextManager['BaseTimerContext'], metaclass=abc.ABCMeta): ...

class TimerNoop(BaseTimerContext):
    def __enter__(self) -> BaseTimerContext: ...
    def __exit__(self, exc_type: Type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None) -> None: ...

class TimerContext(BaseTimerContext):
    """Low resolution timeout context manager"""
    def __init__(self, loop: asyncio.AbstractEventLoop) -> None: ...
    def __enter__(self) -> BaseTimerContext: ...
    def __exit__(self, exc_type: Type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None) -> bool | None: ...
    def timeout(self) -> None: ...

class HeadersMixin:
    ATTRS: Incomplete
    @property
    def content_type(self) -> str:
        """The value of content part for Content-Type HTTP header."""
    @property
    def charset(self) -> str | None:
        """The value of charset part for Content-Type HTTP header."""
    @property
    def content_length(self) -> int | None:
        """The value of Content-Length HTTP header."""

class ChainMapProxy(Mapping[str, Any]):
    def __init__(self, maps: Iterable[Mapping[str, Any]]) -> None: ...
    def __init_subclass__(cls) -> None: ...
    def __getitem__(self, key: str) -> Any: ...
    def get(self, key: str, default: Any = None) -> Any: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[str]: ...
    def __contains__(self, key: object) -> bool: ...
    def __bool__(self) -> bool: ...

class ETag:
    value: str
    is_weak: bool
    def __init__(self) -> None: ...
    def __lt__(self, other): ...
    def __le__(self, other): ...
    def __gt__(self, other): ...
    def __ge__(self, other): ...
