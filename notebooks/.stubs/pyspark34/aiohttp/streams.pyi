import asyncio
from .base_protocol import BaseProtocol
from .helpers import BaseTimerContext
from .typedefs import Final
from _typeshed import Incomplete
from typing import Awaitable, Callable, Generic, Tuple

__all__ = ['EMPTY_PAYLOAD', 'EofStream', 'StreamReader', 'DataQueue', 'FlowControlDataQueue']

class EofStream(Exception):
    """eof stream indication."""

class AsyncStreamIterator(Generic[_T]):
    read_func: Incomplete
    def __init__(self, read_func: Callable[[], Awaitable[_T]]) -> None: ...
    def __aiter__(self) -> AsyncStreamIterator[_T]: ...
    async def __anext__(self) -> _T: ...

class ChunkTupleAsyncStreamIterator:
    def __init__(self, stream: StreamReader) -> None: ...
    def __aiter__(self) -> ChunkTupleAsyncStreamIterator: ...
    async def __anext__(self) -> Tuple[bytes, bool]: ...

class AsyncStreamReaderMixin:
    def __aiter__(self) -> AsyncStreamIterator[bytes]: ...
    def iter_chunked(self, n: int) -> AsyncStreamIterator[bytes]:
        """Returns an asynchronous iterator that yields chunks of size n.

        Python-3.5 available for Python 3.5+ only
        """
    def iter_any(self) -> AsyncStreamIterator[bytes]:
        """Yield all available data as soon as it is received.

        Python-3.5 available for Python 3.5+ only
        """
    def iter_chunks(self) -> ChunkTupleAsyncStreamIterator:
        """Yield chunks of data as they are received by the server.

        The yielded objects are tuples
        of (bytes, bool) as returned by the StreamReader.readchunk method.

        Python-3.5 available for Python 3.5+ only
        """

class StreamReader(AsyncStreamReaderMixin):
    """An enhancement of asyncio.StreamReader.

    Supports asynchronous iteration by line, chunk or as available::

        async for line in reader:
            ...
        async for chunk in reader.iter_chunked(1024):
            ...
        async for slice in reader.iter_any():
            ...

    """
    total_bytes: int
    def __init__(self, protocol: BaseProtocol, limit: int, *, timer: BaseTimerContext | None = None, loop: asyncio.AbstractEventLoop | None = None) -> None: ...
    def get_read_buffer_limits(self) -> Tuple[int, int]: ...
    def exception(self) -> BaseException | None: ...
    def set_exception(self, exc: BaseException) -> None: ...
    def on_eof(self, callback: Callable[[], None]) -> None: ...
    def feed_eof(self) -> None: ...
    def is_eof(self) -> bool:
        """Return True if  'feed_eof' was called."""
    def at_eof(self) -> bool:
        """Return True if the buffer is empty and 'feed_eof' was called."""
    async def wait_eof(self) -> None: ...
    def unread_data(self, data: bytes) -> None:
        """rollback reading some data from stream, inserting it to buffer head."""
    def feed_data(self, data: bytes, size: int = 0) -> None: ...
    def begin_http_chunk_receiving(self) -> None: ...
    def end_http_chunk_receiving(self) -> None: ...
    async def readline(self) -> bytes: ...
    async def readuntil(self, separator: bytes = b'\n') -> bytes: ...
    async def read(self, n: int = -1) -> bytes: ...
    async def readany(self) -> bytes: ...
    async def readchunk(self) -> Tuple[bytes, bool]:
        """Returns a tuple of (data, end_of_http_chunk).

        When chunked transfer
        encoding is used, end_of_http_chunk is a boolean indicating if the end
        of the data corresponds to the end of a HTTP chunk , otherwise it is
        always False.
        """
    async def readexactly(self, n: int) -> bytes: ...
    def read_nowait(self, n: int = -1) -> bytes: ...

class EmptyStreamReader(StreamReader):
    def __init__(self) -> None: ...
    def exception(self) -> BaseException | None: ...
    def set_exception(self, exc: BaseException) -> None: ...
    def on_eof(self, callback: Callable[[], None]) -> None: ...
    def feed_eof(self) -> None: ...
    def is_eof(self) -> bool: ...
    def at_eof(self) -> bool: ...
    async def wait_eof(self) -> None: ...
    def feed_data(self, data: bytes, n: int = 0) -> None: ...
    async def readline(self) -> bytes: ...
    async def read(self, n: int = -1) -> bytes: ...
    async def readany(self) -> bytes: ...
    async def readchunk(self) -> Tuple[bytes, bool]: ...
    async def readexactly(self, n: int) -> bytes: ...
    def read_nowait(self, n: int = -1) -> bytes: ...

EMPTY_PAYLOAD: Final[StreamReader]

class DataQueue(Generic[_T]):
    """DataQueue is a general-purpose blocking queue with one reader."""
    def __init__(self, loop: asyncio.AbstractEventLoop) -> None: ...
    def __len__(self) -> int: ...
    def is_eof(self) -> bool: ...
    def at_eof(self) -> bool: ...
    def exception(self) -> BaseException | None: ...
    def set_exception(self, exc: BaseException) -> None: ...
    def feed_data(self, data: _T, size: int = 0) -> None: ...
    def feed_eof(self) -> None: ...
    async def read(self) -> _T: ...
    def __aiter__(self) -> AsyncStreamIterator[_T]: ...

class FlowControlDataQueue(DataQueue[_T]):
    """FlowControlDataQueue resumes and pauses an underlying stream.

    It is a destination for parsed data.
    """
    def __init__(self, protocol: BaseProtocol, limit: int, *, loop: asyncio.AbstractEventLoop) -> None: ...
    def feed_data(self, data: _T, size: int = 0) -> None: ...
    async def read(self) -> _T: ...
