import asyncio
import logging
from .abc import AbstractAccessLogger
from .web_routedef import AbstractRouteDef
from .web_server import Server
from .web_urldispatcher import AbstractResource, AbstractRoute, UrlDispatcher
from _typeshed import Incomplete
from typing import Any, Iterable, Iterator, List, Mapping, MutableMapping, Type

__all__ = ['Application', 'CleanupError']

class Application(MutableMapping[str, Any]):
    ATTRS: Incomplete
    logger: Incomplete
    def __init__(self, *, logger: logging.Logger = ..., router: UrlDispatcher | None = None, middlewares: Iterable[_Middleware] = (), handler_args: Mapping[str, Any] | None = None, client_max_size: int = ..., loop: asyncio.AbstractEventLoop | None = None, debug: Any = ...) -> None: ...
    def __init_subclass__(cls) -> None: ...
    def __setattr__(self, name: str, val: Any) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, key: str) -> Any: ...
    def __setitem__(self, key: str, value: Any) -> None: ...
    def __delitem__(self, key: str) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[str]: ...
    @property
    def loop(self) -> asyncio.AbstractEventLoop: ...
    @property
    def pre_frozen(self) -> bool: ...
    def pre_freeze(self) -> None: ...
    @property
    def frozen(self) -> bool: ...
    def freeze(self) -> None: ...
    @property
    def debug(self) -> bool: ...
    def add_subapp(self, prefix: str, subapp: Application) -> AbstractResource: ...
    def add_domain(self, domain: str, subapp: Application) -> AbstractResource: ...
    def add_routes(self, routes: Iterable[AbstractRouteDef]) -> List[AbstractRoute]: ...
    @property
    def on_response_prepare(self) -> _RespPrepareSignal: ...
    @property
    def on_startup(self) -> _AppSignal: ...
    @property
    def on_shutdown(self) -> _AppSignal: ...
    @property
    def on_cleanup(self) -> _AppSignal: ...
    @property
    def cleanup_ctx(self) -> CleanupContext: ...
    @property
    def router(self) -> UrlDispatcher: ...
    @property
    def middlewares(self) -> _Middlewares: ...
    def make_handler(self, *, loop: asyncio.AbstractEventLoop | None = None, access_log_class: Type[AbstractAccessLogger] = ..., **kwargs: Any) -> Server: ...
    async def startup(self) -> None:
        """Causes on_startup signal

        Should be called in the event loop along with the request handler.
        """
    async def shutdown(self) -> None:
        """Causes on_shutdown signal

        Should be called before cleanup()
        """
    async def cleanup(self) -> None:
        """Causes on_cleanup signal

        Should be called after shutdown()
        """
    def __call__(self) -> Application:
        """gunicorn compatibility"""
    def __bool__(self) -> bool: ...

class CleanupError(RuntimeError):
    @property
    def exceptions(self) -> List[BaseException]: ...

class CleanupContext(_CleanupContextBase):
    def __init__(self) -> None: ...
