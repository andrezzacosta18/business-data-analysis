import threading
from _multiprocessing import SemLock
from _typeshed import Incomplete

__all__ = ['Lock', 'RLock', 'Semaphore', 'BoundedSemaphore', 'Condition', 'Event']

class SemLock:
    def __init__(self, kind, value, maxvalue, *, ctx) -> None: ...
    def __enter__(self): ...
    def __exit__(self, *args): ...

class Semaphore(SemLock):
    def __init__(self, value: int = 1, *, ctx) -> None: ...
    def get_value(self): ...

class BoundedSemaphore(Semaphore):
    def __init__(self, value: int = 1, *, ctx) -> None: ...

class Lock(SemLock):
    def __init__(self, *, ctx) -> None: ...

class RLock(SemLock):
    def __init__(self, *, ctx) -> None: ...

class Condition:
    def __init__(self, lock: Incomplete | None = None, *, ctx) -> None: ...
    def __enter__(self): ...
    def __exit__(self, *args): ...
    def wait(self, timeout: Incomplete | None = None): ...
    def notify(self, n: int = 1) -> None: ...
    def notify_all(self) -> None: ...
    def wait_for(self, predicate, timeout: Incomplete | None = None): ...

class Event:
    def __init__(self, *, ctx) -> None: ...
    def is_set(self): ...
    def set(self) -> None: ...
    def clear(self) -> None: ...
    def wait(self, timeout: Incomplete | None = None): ...

class Barrier(threading.Barrier):
    def __init__(self, parties, action: Incomplete | None = None, timeout: Incomplete | None = None, *, ctx) -> None: ...
