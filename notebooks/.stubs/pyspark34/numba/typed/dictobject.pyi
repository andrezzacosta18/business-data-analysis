from _typeshed import Incomplete
from enum import IntEnum
from numba.core import cgutils as cgutils, types as types, typing as typing
from numba.core.errors import LoweringError as LoweringError, TypingError as TypingError
from numba.core.extending import intrinsic as intrinsic, lower_builtin as lower_builtin, lower_cast as lower_cast, make_attribute_wrapper as make_attribute_wrapper, models as models, overload as overload, overload_attribute as overload_attribute, overload_method as overload_method, register_model as register_model
from numba.core.imputils import RefType as RefType, impl_ret_borrowed as impl_ret_borrowed, impl_ret_untracked as impl_ret_untracked, iternext_impl as iternext_impl
from numba.core.types import DictItemsIterableType as DictItemsIterableType, DictIteratorType as DictIteratorType, DictKeysIterableType as DictKeysIterableType, DictType as DictType, DictValuesIterableType as DictValuesIterableType, Type as Type

ll_dict_type: Incomplete
ll_dictiter_type: Incomplete
ll_voidptr_type: Incomplete
ll_status: Incomplete
ll_ssize_t: Incomplete
ll_hash = ll_ssize_t
ll_bytes: Incomplete

class DKIX(IntEnum):
    """Special return value of dict lookup.
    """
    EMPTY: int

class Status(IntEnum):
    """Status code for other dict operations.
    """
    OK: int
    OK_REPLACED: int
    ERR_NO_MEMORY: int
    ERR_DICT_MUTATED: int
    ERR_ITER_EXHAUSTED: int
    ERR_DICT_EMPTY: int
    ERR_CMP_FAILED: int

def new_dict(key, value, n_keys: int = 0):
    """Construct a new dict with enough space for *n_keys* without a resize.

    Parameters
    ----------
    key, value : TypeRef
        Key type and value type of the new dict.
    n_keys : int, default 0
        The number of keys to insert without needing a resize.
        A value of 0 creates a dict with minimum size.
    """

class DictModel(models.StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

class DictIterModel(models.StructModel):
    def __init__(self, dmm, fe_type) -> None: ...

def impl_new_dict(key, value, n_keys: int = 0):
    """Creates a new dictionary with *key* and *value* as the type
    of the dictionary key and value, respectively. *n_keys* is the
    number of keys to insert without requiring a resize, where a
    value of 0 creates a dictionary with minimum size.
    """
def impl_len(d):
    """len(dict)
    """
def impl_len_iters(d):
    """len(dict.keys()), len(dict.values()), len(dict.items())
    """
def impl_setitem(d, key, value): ...
def impl_get(dct, key, default: Incomplete | None = None): ...
def impl_hash(dct): ...
def impl_getitem(d, key): ...
def impl_popitem(d): ...
def impl_pop(dct, key, default: Incomplete | None = None): ...
def impl_delitem(d, k): ...
def impl_contains(d, k): ...
def impl_clear(d): ...
def impl_copy(d): ...
def impl_setdefault(dct, key, default: Incomplete | None = None): ...
def impl_items(d): ...
def impl_keys(d): ...
def impl_values(d): ...
def ol_dict_update(d, other): ...
def impl_equal(da, db): ...
def impl_not_equal(da, db): ...
def impl_iterable_getiter(context, builder, sig, args):
    """Implement iter() for .keys(), .values(), .items()
    """
def impl_dict_getiter(context, builder, sig, args):
    """Implement iter(Dict).  Semantically equivalent to dict.keys()
    """
def impl_iterator_iternext(context, builder, sig, args, result) -> None: ...
def build_map(context, builder, dict_type, item_types, items): ...
def literalstrkeydict_impl_values(d): ...
def literalstrkeydict_impl_keys(d): ...
def literalstrkeydict_impl_equals(context, builder, sig, args): ...
def literalstrkeydict_impl_get(dct, *args) -> None: ...
def literalstrkeydict_impl_copy(d): ...
def literalstrkeydict_impl_items(d): ...
def literalstrkeydict_impl_contains(d, k): ...
def literalstrkeydict_impl_len(d): ...
def literalstrkeydict_banned_impl_setitem(d, key, value) -> None: ...
def literalstrkeydict_banned_impl_delitem(d, k) -> None: ...
def literalstrkeydict_banned_impl_mutators(d, *args) -> None: ...
def cast_LiteralStrKeyDict_LiteralStrKeyDict(context, builder, fromty, toty, val): ...
def cast_DictType_DictType(context, builder, fromty, toty, val): ...
