from _typeshed import Incomplete
from collections.abc import Generator
from numba.core.controlflow import CFGraph as CFGraph, NEW_BLOCKERS as NEW_BLOCKERS
from numba.core.errors import UnsupportedError as UnsupportedError
from numba.core.ir import Loc as Loc
from numba.core.utils import ALL_BINOPS_TO_OPERATORS as ALL_BINOPS_TO_OPERATORS, PYVERSION as PYVERSION, UniqueDict as UniqueDict
from typing import NamedTuple

class BlockKind:
    """Kinds of block to make related code safer than just `str`.
    """
    def __init__(self, value) -> None: ...
    def __hash__(self): ...
    def __lt__(self, other): ...
    def __eq__(self, other): ...

class _lazy_pformat:
    args: Incomplete
    kwargs: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class Flow:
    """Data+Control Flow analysis.

    Simulate execution to recover dataflow and controlflow information.
    """
    block_infos: Incomplete
    def __init__(self, bytecode) -> None: ...
    def run(self):
        """Run a trace over the bytecode over all reachable path.

        The trace starts at bytecode offset 0 and gathers stack and control-
        flow information by partially interpreting each bytecode.
        Each ``State`` instance in the trace corresponds to a basic-block.
        The State instances forks when a jump instruction is encountered.
        A newly forked state is then added to the list of pending states.
        The trace ends when there are no more pending states.
        """

class TraceRunner:
    """Trace runner contains the states for the trace and the opcode dispatch.
    """
    debug_filename: Incomplete
    pending: Incomplete
    finished: Incomplete
    def __init__(self, debug_filename) -> None: ...
    def get_debug_loc(self, lineno): ...
    def dispatch(self, state) -> None: ...
    def op_NOP(self, state, inst) -> None: ...
    def op_RESUME(self, state, inst) -> None: ...
    def op_CACHE(self, state, inst) -> None: ...
    def op_PRECALL(self, state, inst) -> None: ...
    def op_PUSH_NULL(self, state, inst) -> None: ...
    def op_RETURN_GENERATOR(self, state, inst) -> None: ...
    def op_FORMAT_VALUE(self, state, inst) -> None:
        """
        FORMAT_VALUE(flags): flags argument specifies format spec which is
        not supported yet. Currently, we just call str() on the value.
        Pops a value from stack and pushes results back.
        Required for supporting f-strings.
        https://docs.python.org/3/library/dis.html#opcode-FORMAT_VALUE
        """
    def op_BUILD_STRING(self, state, inst) -> None:
        """
        BUILD_STRING(count): Concatenates count strings from the stack and
        pushes the resulting string onto the stack.
        Required for supporting f-strings.
        https://docs.python.org/3/library/dis.html#opcode-BUILD_STRING
        """
    def op_POP_TOP(self, state, inst) -> None: ...
    def op_LOAD_GLOBAL(self, state, inst) -> None: ...
    def op_LOAD_GLOBAL(self, state, inst) -> None: ...
    def op_COPY_FREE_VARS(self, state, inst) -> None: ...
    def op_MAKE_CELL(self, state, inst) -> None: ...
    def op_LOAD_DEREF(self, state, inst) -> None: ...
    def op_LOAD_CONST(self, state, inst) -> None: ...
    def op_LOAD_ATTR(self, state, inst) -> None: ...
    def op_LOAD_FAST(self, state, inst) -> None: ...
    def op_DELETE_FAST(self, state, inst) -> None: ...
    def op_DELETE_ATTR(self, state, inst) -> None: ...
    def op_STORE_ATTR(self, state, inst) -> None: ...
    def op_STORE_DEREF(self, state, inst) -> None: ...
    def op_STORE_FAST(self, state, inst) -> None: ...
    def op_SLICE_1(self, state, inst) -> None:
        """
        TOS = TOS1[TOS:]
        """
    def op_SLICE_2(self, state, inst) -> None:
        """
        TOS = TOS1[:TOS]
        """
    def op_SLICE_3(self, state, inst) -> None:
        """
        TOS = TOS2[TOS1:TOS]
        """
    def op_STORE_SLICE_0(self, state, inst) -> None:
        """
        TOS[:] = TOS1
        """
    def op_STORE_SLICE_1(self, state, inst) -> None:
        """
        TOS1[TOS:] = TOS2
        """
    def op_STORE_SLICE_2(self, state, inst) -> None:
        """
        TOS1[:TOS] = TOS2
        """
    def op_STORE_SLICE_3(self, state, inst) -> None:
        """
        TOS2[TOS1:TOS] = TOS3
        """
    def op_DELETE_SLICE_0(self, state, inst) -> None:
        """
        del TOS[:]
        """
    def op_DELETE_SLICE_1(self, state, inst) -> None:
        """
        del TOS1[TOS:]
        """
    def op_DELETE_SLICE_2(self, state, inst) -> None:
        """
        del TOS1[:TOS]
        """
    def op_DELETE_SLICE_3(self, state, inst) -> None:
        """
        del TOS2[TOS1:TOS]
        """
    def op_BUILD_SLICE(self, state, inst) -> None:
        """
        slice(TOS1, TOS) or slice(TOS2, TOS1, TOS)
        """
    op_POP_JUMP_IF_TRUE: Incomplete
    op_POP_JUMP_IF_FALSE: Incomplete
    op_JUMP_IF_FALSE_OR_POP: Incomplete
    op_JUMP_IF_TRUE_OR_POP: Incomplete
    def op_POP_JUMP_FORWARD_IF_NONE(self, state, inst) -> None: ...
    def op_POP_JUMP_FORWARD_IF_NOT_NONE(self, state, inst) -> None: ...
    def op_POP_JUMP_BACKWARD_IF_NONE(self, state, inst) -> None: ...
    def op_POP_JUMP_BACKWARD_IF_NOT_NONE(self, state, inst) -> None: ...
    def op_POP_JUMP_FORWARD_IF_FALSE(self, state, inst) -> None: ...
    def op_POP_JUMP_FORWARD_IF_TRUE(self, state, inst) -> None: ...
    def op_POP_JUMP_BACKWARD_IF_FALSE(self, state, inst) -> None: ...
    def op_POP_JUMP_BACKWARD_IF_TRUE(self, state, inst) -> None: ...
    def op_JUMP_FORWARD(self, state, inst) -> None: ...
    def op_JUMP_BACKWARD(self, state, inst) -> None: ...
    def op_JUMP_ABSOLUTE(self, state, inst) -> None: ...
    def op_BREAK_LOOP(self, state, inst) -> None: ...
    def op_RETURN_VALUE(self, state, inst) -> None: ...
    def op_YIELD_VALUE(self, state, inst) -> None: ...
    def op_RAISE_VARARGS(self, state, inst) -> None: ...
    def op_RAISE_VARARGS(self, state, inst) -> None: ...
    def op_BEGIN_FINALLY(self, state, inst) -> None: ...
    def op_END_FINALLY(self, state, inst) -> None: ...
    def op_POP_FINALLY(self, state, inst) -> None: ...
    def op_CALL_FINALLY(self, state, inst) -> None: ...
    def op_WITH_EXCEPT_START(self, state, inst) -> None: ...
    def op_WITH_CLEANUP_START(self, state, inst) -> None: ...
    def op_WITH_CLEANUP_FINISH(self, state, inst) -> None: ...
    def op_SETUP_LOOP(self, state, inst) -> None: ...
    def op_BEFORE_WITH(self, state, inst) -> None: ...
    def op_SETUP_WITH(self, state, inst) -> None: ...
    def op_PUSH_EXC_INFO(self, state, inst) -> None: ...
    def op_SETUP_FINALLY(self, state, inst) -> None: ...
    def op_POP_EXCEPT(self, state, inst) -> None: ...
    def op_POP_EXCEPT(self, state, inst) -> None: ...
    def op_POP_BLOCK(self, state, inst) -> None: ...
    def op_BINARY_SUBSCR(self, state, inst) -> None: ...
    def op_STORE_SUBSCR(self, state, inst) -> None: ...
    def op_DELETE_SUBSCR(self, state, inst) -> None: ...
    def op_CALL(self, state, inst) -> None: ...
    def op_KW_NAMES(self, state, inst) -> None: ...
    def op_CALL_FUNCTION(self, state, inst) -> None: ...
    def op_CALL_FUNCTION_KW(self, state, inst) -> None: ...
    def op_CALL_FUNCTION_EX(self, state, inst) -> None: ...
    def op_DUP_TOPX(self, state, inst) -> None: ...
    def op_DUP_TOP(self, state, inst) -> None: ...
    def op_DUP_TOP_TWO(self, state, inst) -> None: ...
    def op_COPY(self, state, inst) -> None: ...
    def op_SWAP(self, state, inst) -> None: ...
    def op_ROT_TWO(self, state, inst) -> None: ...
    def op_ROT_THREE(self, state, inst) -> None: ...
    def op_ROT_FOUR(self, state, inst) -> None: ...
    def op_UNPACK_SEQUENCE(self, state, inst) -> None: ...
    def op_BUILD_TUPLE(self, state, inst) -> None: ...
    def op_BUILD_TUPLE_UNPACK_WITH_CALL(self, state, inst) -> None: ...
    def op_BUILD_TUPLE_UNPACK(self, state, inst) -> None: ...
    def op_LIST_TO_TUPLE(self, state, inst) -> None: ...
    def op_BUILD_CONST_KEY_MAP(self, state, inst) -> None: ...
    def op_BUILD_LIST(self, state, inst) -> None: ...
    def op_LIST_APPEND(self, state, inst) -> None: ...
    def op_LIST_EXTEND(self, state, inst) -> None: ...
    def op_BUILD_MAP(self, state, inst) -> None: ...
    def op_MAP_ADD(self, state, inst) -> None: ...
    def op_BUILD_SET(self, state, inst) -> None: ...
    def op_SET_UPDATE(self, state, inst) -> None: ...
    def op_DICT_UPDATE(self, state, inst) -> None: ...
    def op_GET_ITER(self, state, inst) -> None: ...
    def op_FOR_ITER(self, state, inst) -> None: ...
    def op_GEN_START(self, state, inst) -> None:
        """Pops TOS. If TOS was not None, raises an exception. The kind
        operand corresponds to the type of generator or coroutine and
        determines the error message. The legal kinds are 0 for generator,
        1 for coroutine, and 2 for async generator.

        New in version 3.10.
        """
    def op_BINARY_OP(self, state, inst) -> None: ...
    op_UNARY_NEGATIVE: Incomplete
    op_UNARY_POSITIVE: Incomplete
    op_UNARY_NOT: Incomplete
    op_UNARY_INVERT: Incomplete
    op_COMPARE_OP: Incomplete
    op_IS_OP: Incomplete
    op_CONTAINS_OP: Incomplete
    op_INPLACE_ADD: Incomplete
    op_INPLACE_SUBTRACT: Incomplete
    op_INPLACE_MULTIPLY: Incomplete
    op_INPLACE_DIVIDE: Incomplete
    op_INPLACE_TRUE_DIVIDE: Incomplete
    op_INPLACE_FLOOR_DIVIDE: Incomplete
    op_INPLACE_MODULO: Incomplete
    op_INPLACE_POWER: Incomplete
    op_INPLACE_MATRIX_MULTIPLY: Incomplete
    op_INPLACE_LSHIFT: Incomplete
    op_INPLACE_RSHIFT: Incomplete
    op_INPLACE_AND: Incomplete
    op_INPLACE_OR: Incomplete
    op_INPLACE_XOR: Incomplete
    op_BINARY_ADD: Incomplete
    op_BINARY_SUBTRACT: Incomplete
    op_BINARY_MULTIPLY: Incomplete
    op_BINARY_DIVIDE: Incomplete
    op_BINARY_TRUE_DIVIDE: Incomplete
    op_BINARY_FLOOR_DIVIDE: Incomplete
    op_BINARY_MODULO: Incomplete
    op_BINARY_POWER: Incomplete
    op_BINARY_MATRIX_MULTIPLY: Incomplete
    op_BINARY_LSHIFT: Incomplete
    op_BINARY_RSHIFT: Incomplete
    op_BINARY_AND: Incomplete
    op_BINARY_OR: Incomplete
    op_BINARY_XOR: Incomplete
    def op_MAKE_FUNCTION(self, state, inst, MAKE_CLOSURE: bool = False) -> None: ...
    def op_MAKE_CLOSURE(self, state, inst) -> None: ...
    def op_LOAD_CLOSURE(self, state, inst) -> None: ...
    def op_LOAD_ASSERTION_ERROR(self, state, inst) -> None: ...
    def op_CHECK_EXC_MATCH(self, state, inst) -> None: ...
    def op_JUMP_IF_NOT_EXC_MATCH(self, state, inst) -> None: ...
    def op_RERAISE(self, state, inst) -> None: ...
    def op_RERAISE(self, state, inst) -> None: ...
    def op_LOAD_METHOD(self, state, inst) -> None: ...
    def op_LOAD_METHOD(self, state, inst) -> None: ...
    def op_CALL_METHOD(self, state, inst) -> None: ...

class _State:
    """State of the trace
    """
    def __init__(self, bytecode, pc, nstack, blockstack, nullvals=()) -> None:
        """
        Parameters
        ----------
        bytecode : numba.bytecode.ByteCode
            function bytecode
        pc : int
            program counter
        nstack : int
            stackdepth at entry
        blockstack : Sequence[Dict]
            A sequence of dictionary denoting entries on the blockstack.
        """
    def get_identity(self): ...
    def __hash__(self): ...
    def __lt__(self, other): ...
    def __eq__(self, other): ...
    @property
    def pc_initial(self):
        """The starting bytecode offset of this State.
        The PC given to the constructor.
        """
    @property
    def instructions(self):
        """The list of instructions information as a 2-tuple of
        ``(pc : int, register_map : Dict)``
        """
    @property
    def outgoing_edges(self):
        """The list of outgoing edges.

        Returns
        -------
        edges : List[State]
        """
    @property
    def outgoing_phis(self):
        """The dictionary of outgoing phi nodes.

        The keys are the name of the PHI nodes.
        The values are the outgoing states.
        """
    @property
    def blockstack_initial(self):
        """A copy of the initial state of the blockstack
        """
    @property
    def stack_depth(self):
        """The current size of the stack

        Returns
        -------
        res : int
        """
    def find_initial_try_block(self):
        """Find the initial *try* block.
        """
    def has_terminated(self): ...
    def get_inst(self): ...
    def advance_pc(self) -> None: ...
    def make_temp(self, prefix: str = ''): ...
    def append(self, inst, **kwargs) -> None:
        """Append new inst"""
    def get_tos(self): ...
    def peek(self, k):
        """Return the k'th element on the stack
        """
    def push(self, item) -> None:
        """Push to stack"""
    def pop(self):
        """Pop the stack"""
    def swap(self, idx) -> None:
        """Swap stack[idx] with the tos"""
    def push_block(self, synblk) -> None:
        """Push a block to blockstack
        """
    def reset_stack(self, depth):
        """Reset the stack to the given stack depth.
        Returning the popped items.
        """
    def make_block(self, kind, end, reset_stack: bool = True, handler: Incomplete | None = None):
        """Make a new block
        """
    def pop_block(self):
        """Pop a block and unwind the stack
        """
    def pop_block_and_above(self, blk) -> None:
        """Find *blk* in the blockstack and remove it and all blocks above it
        from the stack.
        """
    def get_top_block(self, kind):
        """Find the first block that matches *kind*
        """
    def get_top_block_either(self, *kinds):
        """Find the first block that matches *kind*
        """
    def has_active_try(self):
        """Returns a boolean indicating if the top-block is a *try* block
        """
    def get_varname(self, inst):
        """Get referenced variable name from the oparg
        """
    def terminate(self) -> None:
        """Mark block as terminated
        """
    def fork(self, pc, npop: int = 0, npush: int = 0, extra_block: Incomplete | None = None) -> None:
        """Fork the state
        """
    def split_new_block(self) -> None:
        """Split the state
        """
    def get_outgoing_states(self):
        """Get states for each outgoing edges
        """
    def get_outgoing_edgepushed(self):
        """
        Returns
        -------
        Dict[int, int]
            where keys are the PC
            values are the edge-pushed stack values
        """

class StatePy311(_State):
    def __init__(self, *args, **kwargs) -> None: ...
    def pop_kw_names(self): ...
    def set_kw_names(self, val) -> None: ...
    def is_in_exception(self): ...
    def get_exception(self): ...
    def in_with(self): ...
    def make_null(self): ...
State = StatePy311

class Edge(NamedTuple):
    pc: Incomplete
    stack: Incomplete
    blockstack: Incomplete
    npush: Incomplete

class AdaptDFA:
    """Adapt Flow to the old DFA class expected by Interpreter
    """
    def __init__(self, flow) -> None: ...
    @property
    def infos(self): ...

class AdaptBlockInfo(NamedTuple):
    insts: Incomplete
    outgoing_phis: Incomplete
    blockstack: Incomplete
    active_try_block: Incomplete
    outgoing_edgepushed: Incomplete

def adapt_state_infos(state): ...

class AdaptCFA:
    """Adapt Flow to the old CFA class expected by Interpreter
    """
    def __init__(self, flow) -> None: ...
    @property
    def graph(self): ...
    @property
    def backbone(self): ...
    @property
    def blocks(self): ...
    def iterliveblocks(self) -> Generator[Incomplete, None, None]: ...
    def dump(self) -> None: ...

class AdaptCFBlock:
    offset: Incomplete
    body: Incomplete
    def __init__(self, blockinfo, offset) -> None: ...
