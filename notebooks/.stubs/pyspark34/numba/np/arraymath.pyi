from _typeshed import Incomplete
from enum import IntEnum
from numba.core import cgutils as cgutils, types as types
from numba.core.errors import NumbaDeprecationWarning as NumbaDeprecationWarning, NumbaNotImplementedError as NumbaNotImplementedError, NumbaTypeError as NumbaTypeError, NumbaValueError as NumbaValueError, RequireLiteralValue as RequireLiteralValue, TypingError as TypingError
from numba.core.extending import intrinsic as intrinsic, overload as overload, overload_method as overload_method, register_jitable as register_jitable
from numba.core.imputils import impl_ret_borrowed as impl_ret_borrowed, impl_ret_new_ref as impl_ret_new_ref, impl_ret_untracked as impl_ret_untracked, lower_builtin as lower_builtin
from numba.cpython.unsafe.tuple import tuple_setitem as tuple_setitem
from numba.np.arrayobj import load_item as load_item, make_array as make_array, store_item as store_item
from numba.np.linalg import ensure_blas as ensure_blas
from numba.np.numpy_support import as_dtype as as_dtype, check_is_integer as check_is_integer, is_nonelike as is_nonelike, numpy_version as numpy_version, type_can_asarray as type_can_asarray, type_is_scalar as type_is_scalar

def array_sum(context, builder, sig, args): ...
def gen_sum_axis_impl(is_axis_const, const_axis_val, op, zero): ...
def array_sum_axis_dtype(context, builder, sig, args): ...
def array_sum_dtype(context, builder, sig, args): ...
def array_sum_axis(context, builder, sig, args): ...
def get_accumulator(dtype, value): ...
def array_prod(a): ...
def array_cumsum(a): ...
def array_cumprod(a): ...
def array_mean(a): ...
def array_var(a): ...
def array_std(a): ...
def min_comparator(a, min_val): ...
def max_comparator(a, min_val): ...
def return_false(a): ...
def npy_min(a): ...
def npy_max(a): ...
def array_argmin_impl_datetime(arry): ...
def array_argmin_impl_float(arry): ...
def array_argmin_impl_generic(arry): ...
def array_argmin(arr, axis: Incomplete | None = None): ...
def array_argmax_impl_datetime(arry): ...
def array_argmax_impl_float(arry): ...
def array_argmax_impl_generic(arry): ...
def build_argmax_or_argmin_with_axis_impl(arr, axis, flatten_impl):
    """
    Given a function that implements the logic for handling a flattened
    array, return the implementation function.
    """
def array_argmax(arr, axis: Incomplete | None = None): ...
def np_all(a): ...
def np_allclose(a, b, rtol: float = 1e-05, atol: float = 1e-08, equal_nan: bool = False): ...
def np_any(a): ...
def np_average(arr, axis: Incomplete | None = None, weights: Incomplete | None = None): ...
def get_isnan(dtype):
    """
    A generic isnan() function
    """
def np_iscomplex(x): ...
def np_isreal(x): ...
def iscomplexobj(x): ...
def isrealobj(x): ...
def np_isscalar(num): ...
def is_np_inf_impl(x, out, fn): ...
def isneginf(x, out: Incomplete | None = None): ...
def isposinf(x, out: Incomplete | None = None): ...
def less_than(a, b): ...
def greater_than(a, b): ...
def check_array(a) -> None: ...
def nan_min_max_factory(comparison_op, is_complex_dtype): ...

real_nanmin: Incomplete
real_nanmax: Incomplete
complex_nanmin: Incomplete
complex_nanmax: Incomplete

def isclose(a, b, rtol: float = 1e-05, atol: float = 1e-08, equal_nan: bool = False): ...
def np_nanmin(a): ...
def np_nanmax(a): ...
def np_nanmean(a): ...
def np_nanvar(a): ...
def np_nanstd(a): ...
def np_nansum(a): ...
def np_nanprod(a): ...
def np_nancumprod(a): ...
def np_nancumsum(a): ...
def prepare_ptp_input(a): ...
def np_ptp(a): ...
def nan_aware_less_than(a, b): ...
def np_median(a): ...
def check_valid(q, q_upper_bound): ...
def percentile_is_valid(q) -> None: ...
def quantile_is_valid(q) -> None: ...
def np_percentile(a, q): ...
def np_nanpercentile(a, q): ...
def np_quantile(a, q): ...
def np_nanquantile(a, q): ...
def np_nanmedian(a): ...
def np_partition_impl_inner(a, kth_array): ...
def np_argpartition_impl_inner(a, kth_array): ...
def valid_kths(a, kth):
    """
    Returns a sorted, unique array of kth values which serve
    as indexers for partitioning the input array, a.

    If the absolute value of any of the provided values
    is greater than a.shape[-1] an exception is raised since
    we are partitioning along the last axis (per Numpy default
    behaviour).

    Values less than 0 are transformed to equivalent positive
    index values.
    """
def np_partition(a, kth): ...
def np_argpartition(a, kth): ...
def np_tri(N, M: Incomplete | None = None, k: int = 0): ...
def np_tril_impl_2d(m, k: int = 0): ...
def my_tril(m, k: int = 0): ...
def np_tril_indices(n, k: int = 0, m: Incomplete | None = None): ...
def np_tril_indices_from(arr, k: int = 0): ...
def np_triu_impl_2d(m, k: int = 0): ...
def my_triu(m, k: int = 0): ...
def np_triu_indices(n, k: int = 0, m: Incomplete | None = None): ...
def np_triu_indices_from(arr, k: int = 0): ...
def np_ediff1d(ary, to_end: Incomplete | None = None, to_begin: Incomplete | None = None): ...
def get_d_impl(x, dx): ...
def np_trapz(y, x: Incomplete | None = None, dx: float = 1.0): ...
def np_vander(x, N: Incomplete | None = None, increasing: bool = False): ...
def np_roll(a, shift): ...

LIKELY_IN_CACHE_SIZE: int

def binary_search_with_guess(key, arr, length, guess): ...
def np_interp_impl_complex_inner(x, xp, fp, dtype): ...
def np_interp_impl_inner(x, xp, fp, dtype): ...
def np_interp(x, xp, fp): ...
def row_wise_average(a): ...
def np_cov_impl_inner(X, bias, ddof): ...
def determine_dtype(array_like): ...
def check_dimensions(array_like, name) -> None: ...
def scalar_result_expected(mandatory_input, optional_input): ...
def np_cov(m, y: Incomplete | None = None, rowvar: bool = True, bias: bool = False, ddof: Incomplete | None = None): ...
def np_corrcoef(x, y: Incomplete | None = None, rowvar: bool = True): ...
def np_argwhere(a): ...
def np_flatnonzero(a): ...
def np_fill_diagonal(a, val, wrap: bool = False): ...
def round_ndigits(x, ndigits): ...
def impl_np_round(a, decimals: int = 0, out: Incomplete | None = None): ...
def impl_np_sinc(x): ...
def ov_np_angle(z, deg: bool = False): ...
def array_nonzero(context, builder, sig, args): ...
def ov_np_where(condition): ...
def ov_np_where_x_y(condition, x, y): ...
def np_real(a): ...
def np_imag(a): ...
def np_contains(arr, key): ...
def np_count_nonzero(arr, axis: Incomplete | None = None): ...

np_delete_handler_isslice: Incomplete
np_delete_handler_isarray: Incomplete

def np_delete(arr, obj): ...
def np_diff_impl(a, n: int = 1): ...
def np_array_equal(a, b): ...
def jit_np_intersect1d(ar1, ar2): ...
def validate_1d_array_like(func_name, seq) -> None: ...
def np_bincount(a, weights: Incomplete | None = None, minlength: int = 0): ...
def searchsorted(a, v, side: str = 'left'): ...
def np_digitize(x, bins, right: bool = False): ...
def np_histogram(a, bins: int = 10, range: Incomplete | None = None): ...
MachAr: Incomplete
finfo: Incomplete
iinfo: Incomplete

def generate_xinfo(np_func, container, attr): ...

class _corr_conv_Mode(IntEnum):
    """
    Enumerated modes for correlate/convolve as per:
    https://github.com/numpy/numpy/blob/ac6b1a902b99e340cf7eeeeb7392c91e38db9dd8/numpy/core/numeric.py#L862-L870    # noqa: E501
    """
    VALID: int
    SAME: int
    FULL: int

def np_convolve(a, v): ...
def np_asarray(a, dtype: Incomplete | None = None): ...
def np_asfarray(a, dtype=...): ...
def np_extract(condition, arr): ...
def np_select(condlist, choicelist, default: int = 0): ...
def np_union1d(arr1, arr2): ...
def np_asarray_chkfinite(a, dtype: Incomplete | None = None): ...
def np_bartlett_impl(M): ...
def np_blackman_impl(M): ...
def np_hamming_impl(M): ...
def np_hanning_impl(M): ...
def window_generator(func): ...
def np_kaiser(M, beta): ...
def np_cross(a, b): ...
def cross2d(a, b) -> None: ...
def cross2d_impl(a, b): ...
