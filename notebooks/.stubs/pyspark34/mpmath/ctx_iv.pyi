from . import libmp as libmp
from .ctx_base import StandardBaseContext as StandardBaseContext
from .libmp import ComplexResult as ComplexResult, MPZ_ONE as MPZ_ONE, dps_to_prec as dps_to_prec, finf as finf, fnan as fnan, fninf as fninf, from_float as from_float, from_int as from_int, from_rational as from_rational, from_str as from_str, fzero as fzero, int_types as int_types, mpc_hash as mpc_hash, mpci_abs as mpci_abs, mpci_add as mpci_add, mpci_div as mpci_div, mpci_exp as mpci_exp, mpci_log as mpci_log, mpci_mul as mpci_mul, mpci_neg as mpci_neg, mpci_pos as mpci_pos, mpci_pow as mpci_pow, mpci_sub as mpci_sub, mpf_hash as mpf_hash, mpf_le as mpf_le, mpf_neg as mpf_neg, mpi_abs as mpi_abs, mpi_add as mpi_add, mpi_delta as mpi_delta, mpi_div as mpi_div, mpi_from_str as mpi_from_str, mpi_mid as mpi_mid, mpi_mul as mpi_mul, mpi_neg as mpi_neg, mpi_pos as mpi_pos, mpi_pow as mpi_pow, mpi_pow_int as mpi_pow_int, mpi_str as mpi_str, mpi_sub as mpi_sub, prec_to_dps as prec_to_dps, repr_dps as repr_dps, round_ceiling as round_ceiling, round_floor as round_floor
from .libmp.backend import basestring as basestring
from _typeshed import Incomplete

mpi_zero: Incomplete
new: Incomplete

def convert_mpf_(x, prec, rounding): ...

class ivmpf:
    """
    Interval arithmetic class. Precision is controlled by iv.prec.
    """
    def __new__(cls, x: int = 0): ...
    def cast(self, cls, f_convert): ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __complex__(self) -> complex: ...
    def __hash__(self): ...
    @property
    def real(self): ...
    @property
    def imag(self): ...
    def conjugate(self): ...
    @property
    def a(self): ...
    @property
    def b(self): ...
    @property
    def mid(self): ...
    @property
    def delta(self): ...
    __gt__: Incomplete
    __le__: Incomplete
    __ge__: Incomplete
    def __contains__(self, t) -> bool: ...
    def __eq__(s, t): ...
    def __ne__(s, t): ...
    def __lt__(s, t): ...
    def __le__(s, t): ...
    def __gt__(s, t): ...
    def __ge__(s, t): ...
    def __abs__(self): ...
    def __pos__(self): ...
    def __neg__(self): ...
    def ae(s, t, rel_eps: Incomplete | None = None, abs_eps: Incomplete | None = None): ...

class ivmpc:
    def __new__(cls, re: int = 0, im: int = 0): ...
    def __hash__(self): ...
    @property
    def a(self): ...
    @property
    def b(self): ...
    @property
    def c(self): ...
    @property
    def d(self): ...
    @property
    def real(s): ...
    @property
    def imag(s): ...
    def conjugate(s): ...
    def overlap(s, t): ...
    def __contains__(s, t) -> bool: ...
    def __eq__(s, t): ...
    def __ne__(s, t): ...
    def __lt__(s, t): ...
    __le__ = __lt__
    __gt__ = __lt__
    __ge__ = __lt__
    def __neg__(s): ...
    def __pos__(s): ...
    def __abs__(s): ...
    def ae(s, t, rel_eps: Incomplete | None = None, abs_eps: Incomplete | None = None): ...

class ivmpf_constant(ivmpf):
    def __new__(cls, f): ...

class MPIntervalContext(StandardBaseContext):
    def __init__(ctx) -> None: ...
    prec: Incomplete
    dps: Incomplete
    def make_mpf(ctx, v): ...
    def make_mpc(ctx, v): ...
    def convert(ctx, x): ...
    def nstr(ctx, x, n: int = 5, **kwargs): ...
    def mag(ctx, x): ...
    def isnan(ctx, x): ...
    def isinf(ctx, x): ...
    def isint(ctx, x): ...
    def ldexp(ctx, x, n): ...
    def absmin(ctx, x): ...
    def absmax(ctx, x): ...
    def atan2(ctx, y, x): ...
    def hypsum(ctx, p, q, types, coeffs, z, maxterms: int = 6000, **kwargs): ...
