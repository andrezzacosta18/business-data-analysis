import tensorflow as tf
from _typeshed import Incomplete
from keras.integration_test.models.input_spec import InputSpec as InputSpec
from tensorflow import keras

INPUT_DIM: int
NUM_CLASSES: int

def get_data_spec(batch_size): ...
def get_input_preprocessor() -> None: ...

class Linear(keras.layers.Layer):
    units: Incomplete
    def __init__(self, units: int = 32, name: Incomplete | None = None) -> None: ...
    w: Incomplete
    b: Incomplete
    def build(self, input_shape) -> None: ...
    def call(self, inputs): ...

class BinaryTruePositives(tf.keras.metrics.Metric):
    true_positives: Incomplete
    def __init__(self, name: str = 'binary_true_positives', **kwargs) -> None: ...
    def update_state(self, y_true, y_pred, sample_weight: Incomplete | None = None) -> None: ...
    def result(self): ...
    def reset_state(self) -> None: ...

class CustomModel(keras.Model):
    loss_tracker: Incomplete
    btp_metric: Incomplete
    linear_1: Incomplete
    linear_2: Incomplete
    def __init__(self) -> None: ...
    def call(self, inputs, training: bool = False): ...
    def train_step(self, data): ...
    def test_step(self, data): ...
    @property
    def metrics(self): ...

class CustomLRSchedule(keras.optimizers.schedules.LearningRateSchedule):
    initial_learning_rate: Incomplete
    def __init__(self, initial_learning_rate) -> None: ...
    def __call__(self, step): ...
    def get_config(self): ...

def custom_loss(y_true, y_pred): ...
def get_model(build: bool = False, compile: bool = False, jit_compile: bool = False, include_preprocessing: bool = True): ...
def get_custom_objects(): ...
