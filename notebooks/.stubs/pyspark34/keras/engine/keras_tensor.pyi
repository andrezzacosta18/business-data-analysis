import tensorflow.compat.v2 as tf
from _typeshed import Incomplete
from keras.utils import object_identity as object_identity

class KerasTensor:
    """A representation of a Keras in/output during Functional API construction.

    `KerasTensor`s are tensor-like objects that represent the symbolic inputs
    and outputs of Keras layers during Functional model construction. They are
    comprised of the `tf.TypeSpec` of the (Composite)Tensor that will be
    consumed/produced in the corresponding location of the Functional model.

    KerasTensors are intended as a private API, so users should never need to
    directly instantiate `KerasTensor`s.

    **Building Functional Models with KerasTensors**
    `tf.keras.Input` produces `KerasTensor`s that represent the symbolic inputs
    to your model.

    Passing a `KerasTensor` to a `tf.keras.Layer` `__call__` lets the layer know
    that you are building a Functional model. The layer __call__ will
    infer the output signature and return `KerasTensor`s with `tf.TypeSpec`s
    corresponding to the symbolic outputs of that layer call. These output
    `KerasTensor`s will have all of the internal KerasHistory metadata attached
    to them that Keras needs to construct a Functional Model.

    Currently, layers infer the output signature by:
      * creating a scratch `FuncGraph`
      * making placeholders in the scratch graph that match the input typespecs
      * Calling `layer.call` on these placeholders
      * extracting the signatures of the outputs before clearing the scratch
        graph

    (Note: names assigned to KerasTensors by this process are not guaranteed to
    be unique, and are subject to implementation details).

    `tf.nest` methods are used to insure all of the inputs/output data
    structures get maintained, with elements swapped between KerasTensors and
    placeholders.

    In rare cases (such as when directly manipulating shapes using Keras
    layers), the layer may be able to partially infer the value of the output in
    addition to just inferring the signature.
    When this happens, the returned KerasTensor will also contain the inferred
    value information. Follow-on layers can use this information.
    during their own output signature inference.
    E.g. if one layer produces a symbolic `KerasTensor` that the next layer uses
    as the shape of its outputs, partially knowing the value helps infer the
    output shape.

    **Automatically converting TF APIs to layers**:
    If you passing a `KerasTensor` to a TF API that supports dispatching,
    Keras will automatically turn that API call into a lambda
    layer in the Functional model, and return KerasTensors representing the
    symbolic outputs.

    Most TF APIs that take only tensors as input and produce output tensors
    will support dispatching.

    Calling a `tf.function` does not support dispatching, so you cannot pass
    `KerasTensor`s as inputs to a `tf.function`.

    Higher-order APIs that take methods which produce tensors (e.g. `tf.while`,
    `tf.map_fn`, `tf.cond`) also do not currently support dispatching. So, you
    cannot directly pass KerasTensors as inputs to these APIs either. If you
    want to use these APIs inside of a Functional model, you must put them
    inside of a custom layer.

    Args:
      type_spec: The `tf.TypeSpec` for the symbolic input created by
        `tf.keras.Input`, or symbolically inferred for the output
        during a symbolic layer `__call__`.
      inferred_value: (Optional) a non-symbolic static value, possibly partially
        specified, that could be symbolically inferred for the outputs during
        a symbolic layer `__call__`. This will generally only happen when
        grabbing and manipulating `tf.int32` shapes directly as tensors.
        Statically inferring values in this way and storing them in the
        KerasTensor allows follow-on layers to infer output signatures
        more effectively. (e.g. when using a symbolic shape tensor to later
        construct a tensor with that shape).
      name: (optional) string name for this KerasTensor. Names automatically
        generated by symbolic layer `__call__`s are not guaranteed to be unique,
        and are subject to implementation details.
    """
    def __init__(self, type_spec, inferred_value: Incomplete | None = None, name: Incomplete | None = None) -> None:
        """Constructs a KerasTensor."""
    @property
    def type_spec(self):
        """Returns the `tf.TypeSpec` symbolically inferred for Keras output."""
    @property
    def shape(self):
        """Returns the `TensorShape` symbolically inferred for Keras output."""
    @classmethod
    def from_tensor(cls, tensor):
        """Convert a traced (composite)tensor to a representative
        KerasTensor."""
    @classmethod
    def from_type_spec(cls, type_spec, name: Incomplete | None = None): ...
    def get_shape(self): ...
    def __len__(self) -> int: ...
    @property
    def op(self) -> None: ...
    def __hash__(self): ...
    __array_priority__: int
    def __array__(self, dtype: Incomplete | None = None) -> None: ...
    @property
    def is_tensor_like(self): ...
    def set_shape(self, shape) -> None:
        """Updates the shape of this KerasTensor. Mimics
        `tf.Tensor.set_shape()`."""
    @property
    def dtype(self):
        """Returns the `dtype` symbolically inferred for this Keras output."""
    def ref(self):
        """Returns a hashable reference object to this KerasTensor.

        The primary use case for this API is to put KerasTensors in a
        set/dictionary. We can't put tensors in a set/dictionary as
        `tensor.__hash__()` is not available and tensor equality (`==`) is
        supposed to produce a tensor representing if the two inputs are equal.

        See the documentation of `tf.Tensor.ref()` for more info.
        """
    @property
    def node(self):
        """Find the corresponding `Node` that produce this keras_tensor.

        During functional model construction, Keras will attach `KerasHistory`
        to keras tensor to track the connectivity between calls of layers.
        Return None if there isn't any KerasHistory attached to this tensor.
        """
    def __iter__(self): ...
    @property
    def name(self):
        """Returns the (non-unique, optional) name of this symbolic Keras
        value."""

class SparseKerasTensor(KerasTensor):
    """A specialized KerasTensor representation for `tf.sparse.SparseTensor`s.

    Specifically, it specializes the conversion to a placeholder in order
    to maintain dense shape information.
    """

class RaggedKerasTensor(KerasTensor):
    """A specialized KerasTensor representation for `tf.RaggedTensor`s.

    Specifically, it:

    1. Specializes the conversion to a placeholder in order
    to maintain shape information for non-ragged dimensions.
    2. Overloads the KerasTensor's operators with the RaggedTensor versions
    when they don't match the `tf.Tensor` versions
    3. Exposes some of the instance method/attribute that are unique to
    the RaggedTensor API (such as ragged_rank).
    """
    @property
    def ragged_rank(self): ...

class UserRegisteredSpec(tf.TypeSpec):
    """TypeSpec to represent user-registered symbolic objects."""
    shape: Incomplete
    dtype: Incomplete
    def __init__(self, shape, dtype) -> None: ...
    def value_type(self) -> None: ...

class UserRegisteredTypeKerasTensor(KerasTensor):
    """KerasTensor that represents legacy register_symbolic_tensor_type."""
    def __init__(self, user_registered_symbolic_object) -> None: ...
    @classmethod
    def from_tensor(cls, tensor): ...
    @classmethod
    def from_type_spec(cls, type_spec, name: Incomplete | None = None) -> None: ...

class _KerasTensorIterator:
    """Iterates over the leading dim of a KerasTensor. Performs 0 error
    checks."""
    def __init__(self, tensor, dim0) -> None: ...
    def __iter__(self): ...
    def __next__(self): ...

keras_tensor_classes: Incomplete

def register_keras_tensor_specialization(cls, keras_tensor_subclass) -> None:
    """Register a specialized KerasTensor subclass for a Tensor type."""
def keras_tensor_to_placeholder(x):
    """Construct a graph placeholder to represent a KerasTensor when tracing."""
def keras_tensor_from_tensor(tensor):
    """Convert a traced (composite)tensor to a representative KerasTensor."""
def keras_tensor_from_type_spec(type_spec, name: Incomplete | None = None):
    """Convert a TypeSpec to a representative KerasTensor."""
def type_spec_with_shape(spec, shape):
    """Returns a copy of TypeSpec `spec` with its shape set to `shape`."""
