import abc
from _typeshed import Incomplete
from abc import ABC, abstractmethod
from typing import List, Optional

class Constraint(ABC, metaclass=abc.ABCMeta):
    """Abstract base class for all constraints that can be applied during generation.
    It must define how the constraint can be satisfied.

    All classes that inherit Constraint must follow the requirement that

    ```py
    completed = False
    while not completed:
        _, completed = constraint.update(constraint.advance())
    ```

    will always terminate (halt).
    """
    def __init__(self) -> None: ...
    def test(self) -> None:
        """
        Tests whether this constraint has been properly defined.
        """
    @abstractmethod
    def advance(self):
        """
        When called, returns the token that would take this constraint one step closer to being fulfilled.

        Return:
            token_ids(`torch.tensor`): Must be a tensor of a list of indexable tokens, not some integer.
        """
    @abstractmethod
    def does_advance(self, token_id: int):
        """
        Reads in a token and returns whether it creates progress.
        """
    @abstractmethod
    def update(self, token_id: int):
        """
        Reads in a token and returns booleans that indicate the progress made by it. This function will update the
        state of this object unlikes `does_advance(self, token_id: int)`.

        This isn't to test whether a certain token will advance the progress; it's to update its state as if it has
        been generated. This becomes important if token_id != desired token (refer to else statement in
        PhrasalConstraint)

        Args:
            token_id(`int`):
                The id of a newly generated token in the beam search.
        Return:
            stepped(`bool`):
                Whether this constraint has become one step closer to being fulfuilled.
            completed(`bool`):
                Whether this constraint has been completely fulfilled by this token being generated.
            reset (`bool`):
                Whether this constraint has reset its progress by this token being generated.
        """
    @abstractmethod
    def reset(self):
        """
        Resets the state of this constraint to its initialization. We would call this in cases where the fulfillment of
        a constraint is abrupted by an unwanted token.
        """
    @abstractmethod
    def remaining(self):
        """
        Returns the number of remaining steps of `advance()` in order to complete this constraint.
        """
    @abstractmethod
    def copy(self, stateful: bool = False):
        """
        Creates a new instance of this constraint.

        Args:
            stateful(`bool`): Whether to not only copy the constraint for new instance, but also its state.

        Return:
            constraint(`Constraint`): The same constraint as the one being called from.
        """

class PhrasalConstraint(Constraint):
    """
    [`Constraint`] enforcing that an ordered sequence of tokens is included in the output.

    Args:
        token_ids (`List[int]`):
            The id of the token that must be generated by the output.
    """
    token_ids: Incomplete
    seqlen: Incomplete
    fulfilled_idx: int
    completed: bool
    def __init__(self, token_ids: List[int]) -> None: ...
    def advance(self): ...
    def does_advance(self, token_id: int): ...
    def update(self, token_id: int): ...
    def reset(self) -> None: ...
    def remaining(self): ...
    def copy(self, stateful: bool = False): ...

class DisjunctiveTrie:
    max_height: Incomplete
    trie: Incomplete
    def __init__(self, nested_token_ids: List[List[int]], no_subsets: bool = True) -> None:
        """
        A helper class that builds a trie with the words represented in `nested_token_ids`.
        """
    def next_tokens(self, current_seq):
        """
        The next possible tokens that will progress the trie, given the current sequence of tokens in `current_seq`.
        """
    def reached_leaf(self, current_seq): ...
    def count_leaves(self, root): ...
    def has_subsets(self, trie, nested_token_ids):
        """
        Returns whether # of leaves == # of words. Otherwise some word is a subset of another.
        """

class DisjunctiveConstraint(Constraint):
    """
    A special [`Constraint`] that is fulfilled by fulfilling just one of several constraints.

    Args:
        nested_token_ids (`List[List[int]]`): a list of words, where each word is a list of ids. This constraint
        is fulfilled by generating just one from the list of words.
    """
    trie: Incomplete
    token_ids: Incomplete
    seqlen: Incomplete
    current_seq: Incomplete
    completed: bool
    def __init__(self, nested_token_ids: List[List[int]]) -> None: ...
    def advance(self): ...
    def does_advance(self, token_id: int): ...
    def update(self, token_id: int): ...
    def reset(self) -> None: ...
    def remaining(self): ...
    def copy(self, stateful: bool = False): ...

class ConstraintListState:
    """
    A class for beam scorers to track its progress through a list of constraints.

    Args:
        constraints (`List[Constraint]`):
            A list of [`Constraint`] objects that must be fulfilled by the beam scorer.
    """
    constraints: Incomplete
    max_seqlen: Incomplete
    n_constraints: Incomplete
    completed: bool
    def __init__(self, constraints: List[Constraint]) -> None: ...
    complete_constraints: Incomplete
    inprogress_constraint: Incomplete
    pending_constraints: Incomplete
    def init_state(self) -> None: ...
    def get_bank(self): ...
    def advance(self):
        '''The list of tokens to generate such that we can make progress.
        By "list" we don\'t mean the list of token that will fully fulfill a constraint.

        Given constraints `c_i = {t_ij | j == # of tokens}`, If we\'re not in the middle of progressing through a
        specific constraint `c_i`, we return:

        `[t_k1 for k in indices of unfulfilled constraints]`

        If we are in the middle of a constraint, then we return:
            `[t_ij]`, where `i` is the index of the inprogress constraint, `j` is the next step for the constraint.

        Though we don\'t care which constraint is fulfilled first, if we are in the progress of fulfilling a constraint,
        that\'s the only one we\'ll return.
        '''
    def reset(self, token_ids: Optional[List[int]]):
        """
        token_ids: the tokens generated thus far to reset the state of the progress through constraints.
        """
    def add(self, token_id: int): ...
    def copy(self, stateful: bool = True): ...
