from . import logging as logging
from _typeshed import Incomplete
from transformers.utils.versions import importlib_metadata as importlib_metadata
from types import ModuleType
from typing import Any

logger: Incomplete
ENV_VARS_TRUE_VALUES: Incomplete
ENV_VARS_TRUE_AND_AUTO_VALUES: Incomplete
USE_TF: Incomplete
USE_TORCH: Incomplete
USE_JAX: Incomplete
FORCE_TF_AVAILABLE: Incomplete
candidates: Incomplete
_: Incomplete
coloredlogs: Incomplete
sympy_available: Incomplete
ccl_version: str
TORCH_FX_REQUIRED_VERSION: Incomplete
TORCH_ONNX_DICT_INPUTS_MINIMUM_VERSION: Incomplete

def is_kenlm_available(): ...
def is_torch_available(): ...
def is_pyctcdecode_available(): ...
def is_librosa_available(): ...
def is_torch_cuda_available(): ...
def is_torch_bf16_gpu_available(): ...
def is_torch_bf16_cpu_available(): ...
def is_torch_bf16_available(): ...
def is_torch_tf32_available(): ...

torch_version: Incomplete

def is_torch_fx_available(): ...
def is_bs4_available(): ...
def is_torch_onnx_dict_inputs_support_available(): ...
def is_tf_available(): ...
def is_coloredlogs_available(): ...
def is_tf2onnx_available(): ...
def is_onnx_available(): ...
def is_flax_available(): ...
def is_ftfy_available(): ...
def is_torch_tpu_available(check_device: bool = True):
    """Checks if `torch_xla` is installed and potentially if a TPU is in the environment"""
def is_torch_neuroncore_available(check_device: bool = True): ...
def is_torchdynamo_available(): ...
def is_torch_compile_available(): ...
def is_torch_tensorrt_fx_available(): ...
def is_datasets_available(): ...
def is_detectron2_available(): ...
def is_more_itertools_available(): ...
def is_rjieba_available(): ...
def is_psutil_available(): ...
def is_py3nvml_available(): ...
def is_sacremoses_available(): ...
def is_apex_available(): ...
def is_ninja_available(): ...
def is_ipex_available(): ...
def is_bitsandbytes_available(): ...
def is_torchdistx_available(): ...
def is_faiss_available(): ...
def is_scipy_available(): ...
def is_sklearn_available(): ...
def is_sentencepiece_available(): ...
def is_protobuf_available(): ...
def is_accelerate_available(): ...
def is_optimum_available(): ...
def is_safetensors_available(): ...
def is_tokenizers_available(): ...
def is_vision_available(): ...
def is_pytesseract_available(): ...
def is_spacy_available(): ...
def is_tensorflow_text_available(): ...
def is_keras_nlp_available(): ...
def is_in_notebook(): ...
def is_pytorch_quantization_available(): ...
def is_tensorflow_probability_available(): ...
def is_pandas_available(): ...
def is_sagemaker_dp_enabled(): ...
def is_sagemaker_mp_enabled(): ...
def is_training_run_on_sagemaker(): ...
def is_soundfile_availble(): ...
def is_timm_available(): ...
def is_natten_available(): ...
def is_torchaudio_available(): ...
def is_speech_available(): ...
def is_phonemizer_available(): ...
def torch_only_method(fn): ...
def is_ccl_available(): ...
def is_decord_available(): ...
def is_sudachi_available(): ...
def is_jumanpp_available(): ...
def is_cython_available(): ...

DATASETS_IMPORT_ERROR: str
TOKENIZERS_IMPORT_ERROR: str
SENTENCEPIECE_IMPORT_ERROR: str
PROTOBUF_IMPORT_ERROR: str
FAISS_IMPORT_ERROR: str
PYTORCH_IMPORT_ERROR: str
PYTORCH_IMPORT_ERROR_WITH_TF: str
TF_IMPORT_ERROR_WITH_PYTORCH: str
BS4_IMPORT_ERROR: str
SKLEARN_IMPORT_ERROR: str
TENSORFLOW_IMPORT_ERROR: str
DETECTRON2_IMPORT_ERROR: str
FLAX_IMPORT_ERROR: str
FTFY_IMPORT_ERROR: str
PYTORCH_QUANTIZATION_IMPORT_ERROR: str
TENSORFLOW_PROBABILITY_IMPORT_ERROR: str
TENSORFLOW_TEXT_IMPORT_ERROR: str
PANDAS_IMPORT_ERROR: str
PHONEMIZER_IMPORT_ERROR: str
SACREMOSES_IMPORT_ERROR: str
SCIPY_IMPORT_ERROR: str
SPEECH_IMPORT_ERROR: str
TIMM_IMPORT_ERROR: str
NATTEN_IMPORT_ERROR: str
VISION_IMPORT_ERROR: str
PYTESSERACT_IMPORT_ERROR: str
PYCTCDECODE_IMPORT_ERROR: str
ACCELERATE_IMPORT_ERROR: str
CCL_IMPORT_ERROR: str
DECORD_IMPORT_ERROR: str
BACKENDS_MAPPING: Incomplete

def requires_backends(obj, backends) -> None: ...

class DummyObject(type):
    """
    Metaclass for the dummy objects. Any class inheriting from it will return the ImportError generated by
    `requires_backend` each time a user tries to access any method of that class.
    """
    def __getattribute__(cls, key): ...

def is_torch_fx_proxy(x): ...

class _LazyModule(ModuleType):
    """
    Module class that surfaces all objects but only performs associated imports when the objects are requested.
    """
    def __init__(self, name, module_file, import_structure, module_spec: Incomplete | None = None, extra_objects: Incomplete | None = None) -> None: ...
    def __dir__(self): ...
    def __getattr__(self, name: str) -> Any: ...
    def __reduce__(self): ...

class OptionalDependencyNotAvailable(BaseException):
    """Internally used error class for signalling an optional dependency was not found."""
