from _typeshed import Incomplete
from collections.abc import Callable as Callable, Sequence
from typing import Generic, Self, overload

def check_direct_subclass(exc: BaseException, parents: tuple[type[BaseException]]) -> bool: ...
def get_condition_filter(condition: type[_BaseExceptionT] | tuple[type[_BaseExceptionT], ...] | Callable[[_BaseExceptionT_co], bool]) -> Callable[[_BaseExceptionT_co], bool]: ...

class BaseExceptionGroup(BaseException, Generic[_BaseExceptionT_co]):
    """A combination of multiple unrelated exceptions."""
    def __new__(cls, __message: str, __exceptions: Sequence[_BaseExceptionT_co]) -> Self: ...
    __notes__: Incomplete
    def add_note(self, note: str) -> None: ...
    @property
    def message(self) -> str: ...
    @property
    def exceptions(self) -> tuple[_BaseExceptionT_co | BaseExceptionGroup[_BaseExceptionT_co], ...]: ...
    @overload
    def subgroup(self, __condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...]) -> ExceptionGroup[_ExceptionT] | None: ...
    @overload
    def subgroup(self, __condition: type[_BaseExceptionT] | tuple[type[_BaseExceptionT], ...]) -> BaseExceptionGroup[_BaseExceptionT] | None: ...
    @overload
    def subgroup(self, __condition: Callable[[_BaseExceptionT_co | Self], bool]) -> BaseExceptionGroup[_BaseExceptionT_co] | None: ...
    @overload
    def split(self, __condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...]) -> tuple[ExceptionGroup[_ExceptionT] | None, BaseExceptionGroup[_BaseExceptionT_co] | None]: ...
    @overload
    def split(self, __condition: type[_BaseExceptionT] | tuple[type[_BaseExceptionT], ...]) -> tuple[BaseExceptionGroup[_BaseExceptionT] | None, BaseExceptionGroup[_BaseExceptionT_co] | None]: ...
    @overload
    def split(self, __condition: Callable[[_BaseExceptionT_co | Self], bool]) -> tuple[BaseExceptionGroup[_BaseExceptionT_co] | None, BaseExceptionGroup[_BaseExceptionT_co] | None]: ...
    @overload
    def derive(self, __excs: Sequence[_ExceptionT]) -> ExceptionGroup[_ExceptionT]: ...
    @overload
    def derive(self, __excs: Sequence[_BaseExceptionT]) -> BaseExceptionGroup[_BaseExceptionT]: ...

class ExceptionGroup(BaseExceptionGroup[_ExceptionT_co], Exception):
    def __new__(cls, __message: str, __exceptions: Sequence[_ExceptionT_co]) -> Self: ...
    @property
    def exceptions(self) -> tuple[_ExceptionT_co | ExceptionGroup[_ExceptionT_co], ...]: ...
    @overload
    def subgroup(self, __condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...]) -> ExceptionGroup[_ExceptionT] | None: ...
    @overload
    def subgroup(self, __condition: Callable[[_ExceptionT_co | Self], bool]) -> ExceptionGroup[_ExceptionT_co] | None: ...
    @overload
    def split(self, __condition: type[_ExceptionT] | tuple[type[_ExceptionT], ...]) -> tuple[ExceptionGroup[_ExceptionT] | None, ExceptionGroup[_ExceptionT_co] | None]: ...
    @overload
    def split(self, __condition: Callable[[_ExceptionT_co | Self], bool]) -> tuple[ExceptionGroup[_ExceptionT_co] | None, ExceptionGroup[_ExceptionT_co] | None]: ...
