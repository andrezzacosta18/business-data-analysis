import enum
from _typeshed import Incomplete

__all__ = ['A', 'ASCII', 'B', 'BESTMATCH', 'D', 'DEBUG', 'E', 'ENHANCEMATCH', 'F', 'FULLCASE', 'I', 'IGNORECASE', 'L', 'LOCALE', 'M', 'MULTILINE', 'P', 'POSIX', 'R', 'REVERSE', 'S', 'DOTALL', 'T', 'TEMPLATE', 'U', 'UNICODE', 'V0', 'VERSION0', 'V1', 'VERSION1', 'W', 'WORD', 'X', 'VERBOSE', 'error', 'Scanner', 'RegexFlag']

class error(Exception):
    """Exception raised for invalid regular expressions.

    Attributes:

        msg: The unformatted error message
        pattern: The regular expression pattern
        pos: The position in the pattern where compilation failed, or None
        lineno: The line number where compilation failed, unless pos is None
        colno: The column number where compilation failed, unless pos is None
    """
    msg: Incomplete
    pattern: Incomplete
    pos: Incomplete
    lineno: Incomplete
    colno: Incomplete
    def __init__(self, message, pattern: Incomplete | None = None, pos: Incomplete | None = None) -> None: ...

class _UnscopedFlagSet(Exception): ...
class ParseError(Exception): ...
class _FirstSetError(Exception): ...

class RegexFlag(enum.IntFlag):
    A: int
    ASCII: int
    B: int
    BESTMATCH: int
    D: int
    DEBUG: int
    E: int
    ENHANCEMATCH: int
    F: int
    FULLCASE: int
    I: int
    IGNORECASE: int
    L: int
    LOCALE: int
    M: int
    MULTILINE: int
    P: int
    POSIX: int
    R: int
    REVERSE: int
    S: int
    DOTALL: int
    U: int
    UNICODE: int
    V0: int
    VERSION0: int
    V1: int
    VERSION1: int
    W: int
    WORD: int
    X: int
    VERBOSE: int
    T: int
    TEMPLATE: int
DEFAULT_VERSION = VERSION1

class Namespace: ...

class RegexBase:
    def __init__(self) -> None: ...
    def with_flags(self, positive: Incomplete | None = None, case_flags: Incomplete | None = None, zerowidth: Incomplete | None = None): ...
    def fix_groups(self, pattern, reverse, fuzzy) -> None: ...
    def optimise(self, info, reverse): ...
    def pack_characters(self, info): ...
    def remove_captures(self): ...
    def is_atomic(self): ...
    def can_be_affix(self): ...
    def contains_group(self): ...
    def get_firstset(self, reverse) -> None: ...
    def has_simple_start(self): ...
    def compile(self, reverse: bool = False, fuzzy: bool = False): ...
    def is_empty(self): ...
    def __hash__(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def get_required_string(self, reverse): ...

class ZeroWidthBase(RegexBase):
    positive: Incomplete
    def __init__(self, positive: bool = True) -> None: ...
    def get_firstset(self, reverse): ...
    def dump(self, indent, reverse) -> None: ...
    def max_width(self): ...

class Any(RegexBase):
    def has_simple_start(self): ...
    def dump(self, indent, reverse) -> None: ...
    def max_width(self): ...

class AnyAll(Any): ...
class AnyU(Any): ...

class Atomic(RegexBase):
    subpattern: Incomplete
    def __init__(self, subpattern) -> None: ...
    def fix_groups(self, pattern, reverse, fuzzy) -> None: ...
    def optimise(self, info, reverse): ...
    def pack_characters(self, info): ...
    def remove_captures(self): ...
    def can_be_affix(self): ...
    def contains_group(self): ...
    def get_firstset(self, reverse): ...
    def has_simple_start(self): ...
    def dump(self, indent, reverse) -> None: ...
    def is_empty(self): ...
    def __eq__(self, other): ...
    def max_width(self): ...
    def get_required_string(self, reverse): ...

class Boundary(ZeroWidthBase): ...

class Branch(RegexBase):
    branches: Incomplete
    def __init__(self, branches) -> None: ...
    def fix_groups(self, pattern, reverse, fuzzy) -> None: ...
    def optimise(self, info, reverse): ...
    def pack_characters(self, info): ...
    def remove_captures(self): ...
    def is_atomic(self): ...
    def can_be_affix(self): ...
    def contains_group(self): ...
    def get_firstset(self, reverse): ...
    def dump(self, indent, reverse) -> None: ...
    def is_empty(self): ...
    def __eq__(self, other): ...
    def max_width(self): ...

class CallGroup(RegexBase):
    info: Incomplete
    group: Incomplete
    position: Incomplete
    def __init__(self, info, group, position) -> None: ...
    def fix_groups(self, pattern, reverse, fuzzy) -> None: ...
    def remove_captures(self) -> None: ...
    def dump(self, indent, reverse) -> None: ...
    def __eq__(self, other): ...
    def max_width(self): ...
    def __del__(self) -> None: ...

class CallRef(RegexBase):
    ref: Incomplete
    parsed: Incomplete
    def __init__(self, ref, parsed) -> None: ...

class Character(RegexBase):
    value: Incomplete
    positive: Incomplete
    case_flags: Incomplete
    zerowidth: Incomplete
    folded: Incomplete
    def __init__(self, value, positive: bool = True, case_flags=..., zerowidth: bool = False) -> None: ...
    def rebuild(self, positive, case_flags, zerowidth): ...
    def optimise(self, info, reverse, in_set: bool = False): ...
    def get_firstset(self, reverse): ...
    def has_simple_start(self): ...
    def dump(self, indent, reverse) -> None: ...
    def matches(self, ch): ...
    def max_width(self): ...
    folded_characters: Incomplete
    def get_required_string(self, reverse): ...

class Conditional(RegexBase):
    info: Incomplete
    group: Incomplete
    yes_item: Incomplete
    no_item: Incomplete
    position: Incomplete
    def __init__(self, info, group, yes_item, no_item, position) -> None: ...
    def fix_groups(self, pattern, reverse, fuzzy) -> None: ...
    def optimise(self, info, reverse): ...
    def pack_characters(self, info): ...
    def remove_captures(self) -> None: ...
    def is_atomic(self): ...
    def can_be_affix(self): ...
    def contains_group(self): ...
    def get_firstset(self, reverse): ...
    def dump(self, indent, reverse) -> None: ...
    def is_empty(self): ...
    def __eq__(self, other): ...
    def max_width(self): ...
    def __del__(self) -> None: ...

class DefaultBoundary(ZeroWidthBase): ...
class DefaultEndOfWord(ZeroWidthBase): ...
class DefaultStartOfWord(ZeroWidthBase): ...
class EndOfLine(ZeroWidthBase): ...
class EndOfLineU(EndOfLine): ...
class EndOfString(ZeroWidthBase): ...
class EndOfStringLine(ZeroWidthBase): ...
class EndOfStringLineU(EndOfStringLine): ...
class EndOfWord(ZeroWidthBase): ...
class Failure(ZeroWidthBase): ...

class Fuzzy(RegexBase):
    subpattern: Incomplete
    constraints: Incomplete
    def __init__(self, subpattern, constraints: Incomplete | None = None) -> None: ...
    def fix_groups(self, pattern, reverse, fuzzy) -> None: ...
    def pack_characters(self, info): ...
    def remove_captures(self): ...
    def is_atomic(self): ...
    def contains_group(self): ...
    def dump(self, indent, reverse) -> None: ...
    def is_empty(self): ...
    def __eq__(self, other): ...
    def max_width(self): ...

class Grapheme(RegexBase):
    def dump(self, indent, reverse) -> None: ...
    def max_width(self): ...

class GraphemeBoundary:
    def compile(self, reverse, fuzzy): ...

class GreedyRepeat(RegexBase):
    subpattern: Incomplete
    min_count: Incomplete
    max_count: Incomplete
    def __init__(self, subpattern, min_count, max_count) -> None: ...
    def fix_groups(self, pattern, reverse, fuzzy) -> None: ...
    def optimise(self, info, reverse): ...
    def pack_characters(self, info): ...
    def remove_captures(self): ...
    def is_atomic(self): ...
    def can_be_affix(self): ...
    def contains_group(self): ...
    def get_firstset(self, reverse): ...
    def dump(self, indent, reverse) -> None: ...
    def is_empty(self): ...
    def __eq__(self, other): ...
    def max_width(self): ...
    def get_required_string(self, reverse): ...

class PossessiveRepeat(GreedyRepeat):
    def is_atomic(self): ...
    def dump(self, indent, reverse) -> None: ...

class Group(RegexBase):
    info: Incomplete
    group: Incomplete
    subpattern: Incomplete
    call_ref: Incomplete
    def __init__(self, info, group, subpattern) -> None: ...
    def fix_groups(self, pattern, reverse, fuzzy) -> None: ...
    def optimise(self, info, reverse): ...
    def pack_characters(self, info): ...
    def remove_captures(self): ...
    def is_atomic(self): ...
    def can_be_affix(self): ...
    def contains_group(self): ...
    def get_firstset(self, reverse): ...
    def has_simple_start(self): ...
    def dump(self, indent, reverse) -> None: ...
    def __eq__(self, other): ...
    def max_width(self): ...
    def get_required_string(self, reverse): ...
    def __del__(self) -> None: ...

class Keep(ZeroWidthBase): ...
class LazyRepeat(GreedyRepeat): ...

class LookAround(RegexBase):
    behind: Incomplete
    positive: Incomplete
    subpattern: Incomplete
    def __init__(self, behind, positive, subpattern) -> None: ...
    def fix_groups(self, pattern, reverse, fuzzy) -> None: ...
    def optimise(self, info, reverse): ...
    def pack_characters(self, info): ...
    def remove_captures(self): ...
    def is_atomic(self): ...
    def can_be_affix(self): ...
    def contains_group(self): ...
    def get_firstset(self, reverse): ...
    def dump(self, indent, reverse) -> None: ...
    def is_empty(self): ...
    def __eq__(self, other): ...
    def max_width(self): ...

class LookAroundConditional(RegexBase):
    behind: Incomplete
    positive: Incomplete
    subpattern: Incomplete
    yes_item: Incomplete
    no_item: Incomplete
    def __init__(self, behind, positive, subpattern, yes_item, no_item) -> None: ...
    def fix_groups(self, pattern, reverse, fuzzy) -> None: ...
    def optimise(self, info, reverse): ...
    def pack_characters(self, info): ...
    def remove_captures(self) -> None: ...
    def is_atomic(self): ...
    def can_be_affix(self): ...
    def contains_group(self): ...
    def dump(self, indent, reverse) -> None: ...
    def is_empty(self): ...
    def __eq__(self, other): ...
    def max_width(self): ...
    def get_required_string(self, reverse): ...

class PrecompiledCode(RegexBase):
    code: Incomplete
    def __init__(self, code) -> None: ...

class Property(RegexBase):
    value: Incomplete
    positive: Incomplete
    case_flags: Incomplete
    zerowidth: Incomplete
    def __init__(self, value, positive: bool = True, case_flags=..., zerowidth: bool = False) -> None: ...
    def rebuild(self, positive, case_flags, zerowidth): ...
    def optimise(self, info, reverse, in_set: bool = False): ...
    def get_firstset(self, reverse): ...
    def has_simple_start(self): ...
    def dump(self, indent, reverse) -> None: ...
    def matches(self, ch): ...
    def max_width(self): ...

class Prune(ZeroWidthBase): ...

class Range(RegexBase):
    lower: Incomplete
    upper: Incomplete
    positive: Incomplete
    case_flags: Incomplete
    zerowidth: Incomplete
    def __init__(self, lower, upper, positive: bool = True, case_flags=..., zerowidth: bool = False) -> None: ...
    def rebuild(self, positive, case_flags, zerowidth): ...
    def optimise(self, info, reverse, in_set: bool = False): ...
    def dump(self, indent, reverse) -> None: ...
    def matches(self, ch): ...
    def max_width(self): ...

class RefGroup(RegexBase):
    info: Incomplete
    group: Incomplete
    position: Incomplete
    case_flags: Incomplete
    def __init__(self, info, group, position, case_flags=...) -> None: ...
    def fix_groups(self, pattern, reverse, fuzzy) -> None: ...
    def remove_captures(self) -> None: ...
    def dump(self, indent, reverse) -> None: ...
    def max_width(self): ...
    def __del__(self) -> None: ...

class SearchAnchor(ZeroWidthBase): ...

class Sequence(RegexBase):
    items: Incomplete
    def __init__(self, items: Incomplete | None = None) -> None: ...
    def fix_groups(self, pattern, reverse, fuzzy) -> None: ...
    def optimise(self, info, reverse): ...
    def pack_characters(self, info):
        """Packs sequences of characters into strings."""
    def remove_captures(self): ...
    def is_atomic(self): ...
    def can_be_affix(self): ...
    def contains_group(self): ...
    def get_firstset(self, reverse): ...
    def has_simple_start(self): ...
    def dump(self, indent, reverse) -> None: ...
    def is_empty(self): ...
    def __eq__(self, other): ...
    def max_width(self): ...
    def get_required_string(self, reverse): ...

class SetBase(RegexBase):
    info: Incomplete
    items: Incomplete
    positive: Incomplete
    case_flags: Incomplete
    zerowidth: Incomplete
    char_width: int
    def __init__(self, info, items, positive: bool = True, case_flags=..., zerowidth: bool = False) -> None: ...
    def rebuild(self, positive, case_flags, zerowidth): ...
    def get_firstset(self, reverse): ...
    def has_simple_start(self): ...
    def dump(self, indent, reverse) -> None: ...
    def max_width(self): ...
    def __del__(self) -> None: ...

class SetDiff(SetBase):
    items: Incomplete
    def optimise(self, info, reverse, in_set: bool = False): ...
    def matches(self, ch): ...

class SetInter(SetBase):
    items: Incomplete
    def optimise(self, info, reverse, in_set: bool = False): ...
    def matches(self, ch): ...

class SetSymDiff(SetBase):
    items: Incomplete
    def optimise(self, info, reverse, in_set: bool = False): ...
    def matches(self, ch): ...

class SetUnion(SetBase):
    items: Incomplete
    def optimise(self, info, reverse, in_set: bool = False): ...
    def matches(self, ch): ...

class Skip(ZeroWidthBase): ...
class StartOfLine(ZeroWidthBase): ...
class StartOfLineU(StartOfLine): ...
class StartOfString(ZeroWidthBase): ...
class StartOfWord(ZeroWidthBase): ...

class String(RegexBase):
    characters: Incomplete
    case_flags: Incomplete
    folded_characters: Incomplete
    required: bool
    def __init__(self, characters, case_flags=...) -> None: ...
    def get_firstset(self, reverse): ...
    def has_simple_start(self): ...
    def dump(self, indent, reverse) -> None: ...
    def max_width(self): ...
    def get_required_string(self, reverse): ...

class Literal(String):
    def dump(self, indent, reverse) -> None: ...

class StringSet(Branch):
    info: Incomplete
    name: Incomplete
    case_flags: Incomplete
    set_key: Incomplete
    branches: Incomplete
    def __init__(self, info, name, case_flags=...) -> None: ...
    def dump(self, indent, reverse) -> None: ...
    def __del__(self) -> None: ...

class Source:
    """Scanner for the regular expression source string."""
    string: Incomplete
    char_type: Incomplete
    pos: int
    ignore_space: bool
    sep: Incomplete
    def __init__(self, string) -> None: ...
    def get(self, override_ignore: bool = False): ...
    def get_many(self, count: int = 1): ...
    def get_while(self, test_set, include: bool = True): ...
    def skip_while(self, test_set, include: bool = True) -> None: ...
    def match(self, substring): ...
    def expect(self, substring) -> None: ...
    def at_end(self): ...

class Info:
    """Info about the regular expression."""
    flags: Incomplete
    global_flags: Incomplete
    inline_locale: bool
    kwargs: Incomplete
    group_count: int
    group_index: Incomplete
    group_name: Incomplete
    char_type: Incomplete
    named_lists_used: Incomplete
    open_groups: Incomplete
    open_group_count: Incomplete
    defined_groups: Incomplete
    group_calls: Incomplete
    private_groups: Incomplete
    def __init__(self, flags: int = 0, char_type: Incomplete | None = None, kwargs={}) -> None: ...
    def open_group(self, name: Incomplete | None = None): ...
    def close_group(self) -> None: ...
    def is_open_group(self, name): ...

class Scanner:
    lexicon: Incomplete
    scanner: Incomplete
    def __init__(self, lexicon, flags: int = 0) -> None: ...
    match: Incomplete
    def scan(self, string): ...

# Names in __all__ with no definition:
#   A
#   ASCII
#   B
#   BESTMATCH
#   D
#   DEBUG
#   DOTALL
#   E
#   ENHANCEMATCH
#   F
#   FULLCASE
#   I
#   IGNORECASE
#   L
#   LOCALE
#   M
#   MULTILINE
#   P
#   POSIX
#   R
#   REVERSE
#   S
#   T
#   TEMPLATE
#   U
#   UNICODE
#   V0
#   V1
#   VERBOSE
#   VERSION0
#   VERSION1
#   W
#   WORD
#   X
