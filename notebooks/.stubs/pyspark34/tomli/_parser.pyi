from ._re import RE_DATETIME as RE_DATETIME, RE_LOCALTIME as RE_LOCALTIME, RE_NUMBER as RE_NUMBER, match_to_datetime as match_to_datetime, match_to_localtime as match_to_localtime, match_to_number as match_to_number
from ._types import Key as Key, ParseFloat as ParseFloat, Pos as Pos
from _typeshed import Incomplete
from collections.abc import Iterable
from typing import Any, BinaryIO, NamedTuple

ASCII_CTRL: Incomplete
ILLEGAL_BASIC_STR_CHARS: Incomplete
ILLEGAL_MULTILINE_BASIC_STR_CHARS: Incomplete
ILLEGAL_LITERAL_STR_CHARS = ILLEGAL_BASIC_STR_CHARS
ILLEGAL_MULTILINE_LITERAL_STR_CHARS = ILLEGAL_MULTILINE_BASIC_STR_CHARS
ILLEGAL_COMMENT_CHARS = ILLEGAL_BASIC_STR_CHARS
TOML_WS: Incomplete
TOML_WS_AND_NEWLINE: Incomplete
BARE_KEY_CHARS: Incomplete
KEY_INITIAL_CHARS: Incomplete
HEXDIGIT_CHARS: Incomplete
BASIC_STR_ESCAPE_REPLACEMENTS: Incomplete

class TOMLDecodeError(ValueError):
    """An error raised if a document is not valid TOML."""

def load(__fp: BinaryIO, *, parse_float: ParseFloat = ...) -> dict[str, Any]:
    """Parse TOML from a binary file object."""
def loads(__s: str, *, parse_float: ParseFloat = ...) -> dict[str, Any]:
    """Parse TOML from a string."""

class Flags:
    """Flags that map to parsed keys/namespaces."""
    FROZEN: int
    EXPLICIT_NEST: int
    def __init__(self) -> None: ...
    def add_pending(self, key: Key, flag: int) -> None: ...
    def finalize_pending(self) -> None: ...
    def unset_all(self, key: Key) -> None: ...
    def set(self, key: Key, flag: int, *, recursive: bool) -> None: ...
    def is_(self, key: Key, flag: int) -> bool: ...

class NestedDict:
    dict: Incomplete
    def __init__(self) -> None: ...
    def get_or_create_nest(self, key: Key, *, access_lists: bool = True) -> dict: ...
    def append_nest_to_list(self, key: Key) -> None: ...

class Output(NamedTuple):
    data: NestedDict
    flags: Flags

def skip_chars(src: str, pos: Pos, chars: Iterable[str]) -> Pos: ...
def skip_until(src: str, pos: Pos, expect: str, *, error_on: frozenset[str], error_on_eof: bool) -> Pos: ...
def skip_comment(src: str, pos: Pos) -> Pos: ...
def skip_comments_and_array_ws(src: str, pos: Pos) -> Pos: ...
def create_dict_rule(src: str, pos: Pos, out: Output) -> tuple[Pos, Key]: ...
def create_list_rule(src: str, pos: Pos, out: Output) -> tuple[Pos, Key]: ...
def key_value_rule(src: str, pos: Pos, out: Output, header: Key, parse_float: ParseFloat) -> Pos: ...
def parse_key_value_pair(src: str, pos: Pos, parse_float: ParseFloat) -> tuple[Pos, Key, Any]: ...
def parse_key(src: str, pos: Pos) -> tuple[Pos, Key]: ...
def parse_key_part(src: str, pos: Pos) -> tuple[Pos, str]: ...
def parse_one_line_basic_str(src: str, pos: Pos) -> tuple[Pos, str]: ...
def parse_array(src: str, pos: Pos, parse_float: ParseFloat) -> tuple[Pos, list]: ...
def parse_inline_table(src: str, pos: Pos, parse_float: ParseFloat) -> tuple[Pos, dict]: ...
def parse_basic_str_escape(src: str, pos: Pos, *, multiline: bool = False) -> tuple[Pos, str]: ...
def parse_basic_str_escape_multiline(src: str, pos: Pos) -> tuple[Pos, str]: ...
def parse_hex_char(src: str, pos: Pos, hex_len: int) -> tuple[Pos, str]: ...
def parse_literal_str(src: str, pos: Pos) -> tuple[Pos, str]: ...
def parse_multiline_str(src: str, pos: Pos, *, literal: bool) -> tuple[Pos, str]: ...
def parse_basic_str(src: str, pos: Pos, *, multiline: bool) -> tuple[Pos, str]: ...
def parse_value(src: str, pos: Pos, parse_float: ParseFloat) -> tuple[Pos, Any]: ...
def suffixed_err(src: str, pos: Pos, msg: str) -> TOMLDecodeError:
    """Return a `TOMLDecodeError` where error message is suffixed with
    coordinates in source."""
def is_unicode_scalar_value(codepoint: int) -> bool: ...
def make_safe_parse_float(parse_float: ParseFloat) -> ParseFloat:
    """A decorator to make `parse_float` safe.

    `parse_float` must not return dicts or lists, because these types
    would be mixed with parsed TOML tables and arrays, thus confusing
    the parser. The returned decorated callable raises `ValueError`
    instead of returning illegal types.
    """
