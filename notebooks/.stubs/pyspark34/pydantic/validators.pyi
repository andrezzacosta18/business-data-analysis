from . import errors as errors
from .config import BaseConfig as BaseConfig
from .datetime_parse import parse_date as parse_date, parse_datetime as parse_datetime, parse_duration as parse_duration, parse_time as parse_time
from .fields import ModelField as ModelField
from .types import ConstrainedDecimal as ConstrainedDecimal, ConstrainedFloat as ConstrainedFloat, ConstrainedInt as ConstrainedInt
from .typing import AnyCallable as AnyCallable, all_literal_values as all_literal_values, display_as_type as display_as_type, get_class as get_class, is_callable_type as is_callable_type, is_literal_type as is_literal_type, is_namedtuple as is_namedtuple, is_none_type as is_none_type, is_typeddict as is_typeddict
from .utils import almost_equal_floats as almost_equal_floats, lenient_issubclass as lenient_issubclass, sequence_like as sequence_like
from _typeshed import Incomplete
from collections import OrderedDict
from decimal import Decimal
from enum import Enum, IntEnum
from ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network
from pathlib import Path
from typing import Any, Callable, Deque, Dict, FrozenSet, Generator, Hashable, List, NamedTuple, Pattern, Set, Tuple, Type, TypeVar
from typing_extensions import Literal, TypedDict
from uuid import UUID

ConstrainedNumber = ConstrainedDecimal | ConstrainedFloat | ConstrainedInt
AnyOrderedDict = OrderedDict[Any, Any]
Number = int | float | Decimal
StrBytes = str | bytes

def str_validator(v: Any) -> str: ...
def strict_str_validator(v: Any) -> str: ...
def bytes_validator(v: Any) -> bytes: ...
def strict_bytes_validator(v: Any) -> bytes: ...

BOOL_FALSE: Incomplete
BOOL_TRUE: Incomplete

def bool_validator(v: Any) -> bool: ...

max_str_int: int

def int_validator(v: Any) -> int: ...
def strict_int_validator(v: Any) -> int: ...
def float_validator(v: Any) -> float: ...
def strict_float_validator(v: Any) -> float: ...
def float_finite_validator(v: Number, field: ModelField, config: BaseConfig) -> Number: ...
def number_multiple_validator(v: Number, field: ModelField) -> Number: ...
def number_size_validator(v: Number, field: ModelField) -> Number: ...
def constant_validator(v: Any, field: ModelField) -> Any:
    """Validate ``const`` fields.

    The value provided for a ``const`` field must be equal to the default value
    of the field. This is to support the keyword of the same name in JSON
    Schema.
    """
def anystr_length_validator(v: StrBytes, config: BaseConfig) -> StrBytes: ...
def anystr_strip_whitespace(v: StrBytes) -> StrBytes: ...
def anystr_upper(v: StrBytes) -> StrBytes: ...
def anystr_lower(v: StrBytes) -> StrBytes: ...
def ordered_dict_validator(v: Any) -> AnyOrderedDict: ...
def dict_validator(v: Any) -> Dict[Any, Any]: ...
def list_validator(v: Any) -> List[Any]: ...
def tuple_validator(v: Any) -> Tuple[Any, ...]: ...
def set_validator(v: Any) -> Set[Any]: ...
def frozenset_validator(v: Any) -> FrozenSet[Any]: ...
def deque_validator(v: Any) -> Deque[Any]: ...
def enum_member_validator(v: Any, field: ModelField, config: BaseConfig) -> Enum: ...
def uuid_validator(v: Any, field: ModelField) -> UUID: ...
def decimal_validator(v: Any) -> Decimal: ...
def hashable_validator(v: Any) -> Hashable: ...
def ip_v4_address_validator(v: Any) -> IPv4Address: ...
def ip_v6_address_validator(v: Any) -> IPv6Address: ...
def ip_v4_network_validator(v: Any) -> IPv4Network:
    """
    Assume IPv4Network initialised with a default ``strict`` argument

    See more:
    https://docs.python.org/library/ipaddress.html#ipaddress.IPv4Network
    """
def ip_v6_network_validator(v: Any) -> IPv6Network:
    """
    Assume IPv6Network initialised with a default ``strict`` argument

    See more:
    https://docs.python.org/library/ipaddress.html#ipaddress.IPv6Network
    """
def ip_v4_interface_validator(v: Any) -> IPv4Interface: ...
def ip_v6_interface_validator(v: Any) -> IPv6Interface: ...
def path_validator(v: Any) -> Path: ...
def path_exists_validator(v: Any) -> Path: ...
def callable_validator(v: Any) -> AnyCallable:
    """
    Perform a simple check if the value is callable.

    Note: complete matching of argument type hints and return types is not performed
    """
def enum_validator(v: Any) -> Enum: ...
def int_enum_validator(v: Any) -> IntEnum: ...
def make_literal_validator(type_: Any) -> Callable[[Any], Any]: ...
def constr_length_validator(v: StrBytes, field: ModelField, config: BaseConfig) -> StrBytes: ...
def constr_strip_whitespace(v: StrBytes, field: ModelField, config: BaseConfig) -> StrBytes: ...
def constr_upper(v: StrBytes, field: ModelField, config: BaseConfig) -> StrBytes: ...
def constr_lower(v: StrBytes, field: ModelField, config: BaseConfig) -> StrBytes: ...
def validate_json(v: Any, config: BaseConfig) -> Any: ...
T = TypeVar('T')

def make_arbitrary_type_validator(type_: Type[T]) -> Callable[[T], T]: ...
def make_class_validator(type_: Type[T]) -> Callable[[Any], Type[T]]: ...
def any_class_validator(v: Any) -> Type[T]: ...
def none_validator(v: Any) -> Literal[None]: ...
def pattern_validator(v: Any) -> Pattern[str]: ...
NamedTupleT = TypeVar('NamedTupleT', bound=NamedTuple)

def make_namedtuple_validator(namedtuple_cls: Type[NamedTupleT], config: Type['BaseConfig']) -> Callable[[Tuple[Any, ...]], NamedTupleT]: ...
def make_typeddict_validator(typeddict_cls: Type['TypedDict'], config: Type['BaseConfig']) -> Callable[[Any], Dict[str, Any]]: ...

class IfConfig:
    validator: Incomplete
    config_attr_names: Incomplete
    ignored_value: Incomplete
    def __init__(self, validator: AnyCallable, *config_attr_names: str, ignored_value: Any = False) -> None: ...
    def check(self, config: Type['BaseConfig']) -> bool: ...

def find_validators(type_: Type[Any], config: Type['BaseConfig']) -> Generator[AnyCallable, None, None]: ...
