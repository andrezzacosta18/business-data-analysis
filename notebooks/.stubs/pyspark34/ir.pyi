from typing import Any, Callable, Dict, FrozenSet, Generic, Iterable, Iterator, List, Mapping, Protocol, Sequence, Set, Tuple, TypeVar, overload

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)
S = TypeVar('S')
K = TypeVar('K')
V = TypeVar('V')

class __SupportsAbs(Protocol[T_co]):
    def __abs__(self) -> T_co: ...

class __SupportsDivMod(Protocol[T_contra, T_co]):
    def __divmod__(self, other: T_contra) -> T_co: ...

class __SupportsRDivMod(Protocol[T_contra, T_co]):
    def __rdivmod__(self, other: T_contra) -> T_co: ...

class __SupportsPow2(Protocol[T_contra, T_co]):
    def __pow__(self, other: T_contra) -> T_co: ...

class __SupportsPow3NoneOnly(Protocol[T_contra, T_co]):
    def __pow__(self, other: T_contra, modulo: None = ...) -> T_co: ...

class __SupportsPow3(Protocol[T_contra, _M, T_co]):
    def __pow__(self, other: T_contra, modulo: _M) -> T_co: ...

class object:
    def __init__(self) -> None: ...
    def __eq__(self, x: object) -> bool: ...
    def __ne__(self, x: object) -> bool: ...

class type:
    def __init__(self, o: object) -> None: ...
    __annotations__: Dict[str, Any]

class ellipsis: ...

class int:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: object, base: int = 10) -> None: ...
    def __add__(self, n: int) -> int: ...
    def __sub__(self, n: int) -> int: ...
    def __mul__(self, n: int) -> int: ...
    def __pow__(self, n: int, modulo: int | None = None) -> int: ...
    def __floordiv__(self, x: int) -> int: ...
    def __truediv__(self, x: float) -> float: ...
    def __mod__(self, x: int) -> int: ...
    def __divmod__(self, x: float) -> Tuple[float, float]: ...
    def __neg__(self) -> int: ...
    def __pos__(self) -> int: ...
    def __abs__(self) -> int: ...
    def __invert__(self) -> int: ...
    def __and__(self, n: int) -> int: ...
    def __or__(self, n: int) -> int: ...
    def __xor__(self, n: int) -> int: ...
    def __lshift__(self, x: int) -> int: ...
    def __rshift__(self, x: int) -> int: ...
    def __eq__(self, n: object) -> bool: ...
    def __ne__(self, n: object) -> bool: ...
    def __lt__(self, n: int) -> bool: ...
    def __gt__(self, n: int) -> bool: ...
    def __le__(self, n: int) -> bool: ...
    def __ge__(self, n: int) -> bool: ...

class str:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: object) -> None: ...
    def __add__(self, x: str) -> str: ...
    def __mul__(self, x: int) -> str: ...
    def __rmul__(self, x: int) -> str: ...
    def __eq__(self, x: object) -> bool: ...
    def __ne__(self, x: object) -> bool: ...
    def __lt__(self, x: str) -> bool: ...
    def __le__(self, x: str) -> bool: ...
    def __gt__(self, x: str) -> bool: ...
    def __ge__(self, x: str) -> bool: ...
    @overload
    def __getitem__(self, i: int) -> str: ...
    @overload
    def __getitem__(self, i: slice) -> str: ...
    def __contains__(self, item: str) -> bool: ...
    def __iter__(self) -> Iterator[str]: ...
    def split(self, sep: str | None = None, max: int | None = None) -> List[str]: ...
    def strip(self, item: str) -> str: ...
    def join(self, x: Iterable[str]) -> str: ...
    def format(self, *args: Any, **kwargs: Any) -> str: ...
    def upper(self) -> str: ...
    def startswith(self, x: str, start: int = ..., end: int = ...) -> bool: ...
    def endswith(self, x: str, start: int = ..., end: int = ...) -> bool: ...
    def replace(self, old: str, new: str, maxcount: int = ...) -> str: ...
    def encode(self, x: str = ..., y: str = ...) -> bytes: ...

class float:
    def __init__(self, x: object) -> None: ...
    def __add__(self, n: float) -> float: ...
    def __radd__(self, n: float) -> float: ...
    def __sub__(self, n: float) -> float: ...
    def __rsub__(self, n: float) -> float: ...
    def __mul__(self, n: float) -> float: ...
    def __truediv__(self, n: float) -> float: ...
    def __floordiv__(self, n: float) -> float: ...
    def __mod__(self, n: float) -> float: ...
    def __pow__(self, n: float) -> float: ...
    def __neg__(self) -> float: ...
    def __pos__(self) -> float: ...
    def __abs__(self) -> float: ...
    def __invert__(self) -> float: ...
    def __eq__(self, x: object) -> bool: ...
    def __ne__(self, x: object) -> bool: ...
    def __lt__(self, x: float) -> bool: ...
    def __le__(self, x: float) -> bool: ...
    def __gt__(self, x: float) -> bool: ...
    def __ge__(self, x: float) -> bool: ...

class complex:
    def __init__(self, x: object, y: object = None) -> None: ...
    def __add__(self, n: complex) -> complex: ...
    def __radd__(self, n: float) -> complex: ...
    def __sub__(self, n: complex) -> complex: ...
    def __rsub__(self, n: float) -> complex: ...
    def __mul__(self, n: complex) -> complex: ...
    def __truediv__(self, n: complex) -> complex: ...
    def __neg__(self) -> complex: ...

class bytes:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: object) -> None: ...
    def __add__(self, x: bytes) -> bytes: ...
    def __mul__(self, x: int) -> bytes: ...
    def __rmul__(self, x: int) -> bytes: ...
    def __eq__(self, x: object) -> bool: ...
    def __ne__(self, x: object) -> bool: ...
    @overload
    def __getitem__(self, i: int) -> int: ...
    @overload
    def __getitem__(self, i: slice) -> bytes: ...
    def join(self, x: Iterable[object]) -> bytes: ...
    def decode(self, x: str = ..., y: str = ...) -> str: ...

class bytearray:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, x: object) -> None: ...
    @overload
    def __init__(self, string: str, encoding: str, err: str = ...) -> None: ...
    def __add__(self, s: bytes) -> bytearray: ...
    def __setitem__(self, i: int, o: int) -> None: ...
    def __getitem__(self, i: int) -> int: ...
    def decode(self, x: str = ..., y: str = ...) -> str: ...

class bool(int):
    def __init__(self, o: object = ...) -> None: ...
    @overload
    def __and__(self, n: bool) -> bool: ...
    @overload
    def __and__(self, n: int) -> int: ...
    @overload
    def __or__(self, n: bool) -> bool: ...
    @overload
    def __or__(self, n: int) -> int: ...
    @overload
    def __xor__(self, n: bool) -> bool: ...
    @overload
    def __xor__(self, n: int) -> int: ...

class tuple(Sequence[T_co], Iterable[T_co], Generic[T_co]):
    def __init__(self, i: Iterable[T_co]) -> None: ...
    @overload
    def __getitem__(self, i: int) -> T_co: ...
    @overload
    def __getitem__(self, i: slice) -> Tuple[T_co, ...]: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[T_co]: ...
    def __contains__(self, item: object) -> int: ...

class function: ...

class list(Sequence[T], Iterable[T], Generic[T]):
    def __init__(self, i: Iterable[T] | None = None) -> None: ...
    @overload
    def __getitem__(self, i: int) -> T: ...
    @overload
    def __getitem__(self, s: slice) -> List[T]: ...
    def __setitem__(self, i: int, o: T) -> None: ...
    def __delitem__(self, i: int) -> None: ...
    def __mul__(self, i: int) -> List[T]: ...
    def __rmul__(self, i: int) -> List[T]: ...
    def __iter__(self) -> Iterator[T]: ...
    def __len__(self) -> int: ...
    def __contains__(self, item: object) -> int: ...
    def __add__(self, x: List[T]) -> List[T]: ...
    def append(self, x: T) -> None: ...
    def pop(self, i: int = -1) -> T: ...
    def count(self, T) -> int: ...
    def extend(self, l: Iterable[T]) -> None: ...
    def insert(self, i: int, x: T) -> None: ...
    def sort(self) -> None: ...
    def reverse(self) -> None: ...
    def remove(self, o: T) -> None: ...
    def index(self, o: T) -> int: ...

class dict(Mapping[K, V]):
    @overload
    def __init__(self, **kwargs: K) -> None: ...
    @overload
    def __init__(self, map: Mapping[K, V], **kwargs: V) -> None: ...
    @overload
    def __init__(self, iterable: Iterable[Tuple[K, V]], **kwargs: V) -> None: ...
    def __getitem__(self, key: K) -> V: ...
    def __setitem__(self, k: K, v: V) -> None: ...
    def __delitem__(self, k: K) -> None: ...
    def __contains__(self, item: object) -> int: ...
    def __iter__(self) -> Iterator[K]: ...
    def __len__(self) -> int: ...
    @overload
    def update(self, __m: Mapping[K, V], **kwargs: V) -> None: ...
    @overload
    def update(self, __m: Iterable[Tuple[K, V]], **kwargs: V) -> None: ...
    @overload
    def update(self, **kwargs: V) -> None: ...
    def pop(self, x: int) -> K: ...
    def keys(self) -> Iterable[K]: ...
    def values(self) -> Iterable[V]: ...
    def items(self) -> Iterable[Tuple[K, V]]: ...
    def clear(self) -> None: ...
    def copy(self) -> Dict[K, V]: ...
    def setdefault(self, key: K, val: V = ...) -> V: ...

class set(Generic[T]):
    def __init__(self, i: Iterable[T] | None = None) -> None: ...
    def __iter__(self) -> Iterator[T]: ...
    def __len__(self) -> int: ...
    def add(self, x: T) -> None: ...
    def remove(self, x: T) -> None: ...
    def discard(self, x: T) -> None: ...
    def clear(self) -> None: ...
    def pop(self) -> T: ...
    def update(self, x: Iterable[S]) -> None: ...
    def __or__(self, s: Set[S] | FrozenSet[S]) -> Set[T | S]: ...
    def __xor__(self, s: Set[S] | FrozenSet[S]) -> Set[T | S]: ...

class frozenset(Generic[T]):
    def __init__(self, i: Iterable[T] | None = None) -> None: ...
    def __iter__(self) -> Iterator[T]: ...
    def __len__(self) -> int: ...
    def __or__(self, s: Set[S] | FrozenSet[S]) -> FrozenSet[T | S]: ...
    def __xor__(self, s: Set[S] | FrozenSet[S]) -> FrozenSet[T | S]: ...

class slice: ...

class range(Iterable[int]):
    def __init__(self, x: int, y: int = ..., z: int = ...) -> None: ...
    def __iter__(self) -> Iterator[int]: ...
    def __len__(self) -> int: ...
    def __next__(self) -> int: ...

class property:
    def __init__(self, fget: Callable[[Any], Any] | None = ..., fset: Callable[[Any, Any], None] | None = ..., fdel: Callable[[Any], None] | None = ..., doc: str | None = ...) -> None: ...
    def getter(self, fget: Callable[[Any], Any]) -> property: ...
    def setter(self, fset: Callable[[Any, Any], None]) -> property: ...
    def deleter(self, fdel: Callable[[Any], None]) -> property: ...
    def __get__(self, obj: Any, type: type | None = ...) -> Any: ...
    def __set__(self, obj: Any, value: Any) -> None: ...
    def __delete__(self, obj: Any) -> None: ...
    def fget(self) -> Any: ...
    def fset(self, value: Any) -> None: ...
    def fdel(self) -> None: ...

class BaseException: ...

class Exception(BaseException):
    def __init__(self, message: str | None = None) -> None: ...

class Warning(Exception): ...
class UserWarning(Warning): ...
class TypeError(Exception): ...
class ValueError(Exception): ...
class AttributeError(Exception): ...
class ImportError(Exception): ...
class NameError(Exception): ...
class UnboundLocalError(NameError): ...
class LookupError(Exception): ...
class KeyError(LookupError): ...
class IndexError(LookupError): ...
class RuntimeError(Exception): ...
class UnicodeEncodeError(RuntimeError): ...
class UnicodeDecodeError(RuntimeError): ...
class NotImplementedError(RuntimeError): ...

class StopIteration(Exception):
    value: Any

class ArithmeticError(Exception): ...
class ZeroDivisionError(ArithmeticError): ...
class OverflowError(ArithmeticError): ...
class GeneratorExit(BaseException): ...

def any(i: Iterable[T]) -> bool: ...
def all(i: Iterable[T]) -> bool: ...
def sum(i: Iterable[T]) -> int: ...
def reversed(object: Sequence[T]) -> Iterator[T]: ...
def id(o: object) -> int: ...
def len(o: object) -> int: ...
def print(*object) -> None: ...
def isinstance(x: object, t: object) -> bool: ...
def iter(i: Iterable[T]) -> Iterator[T]: ...
@overload
def next(i: Iterator[T]) -> T: ...
@overload
def next(i: Iterator[T], default: T) -> T: ...
def hash(o: object) -> int: ...
def globals() -> Dict[str, Any]: ...
def getattr(obj: object, name: str, default: Any = None) -> Any: ...
def setattr(obj: object, name: str, value: Any) -> None: ...
def enumerate(x: Iterable[T]) -> Iterator[Tuple[int, T]]: ...
@overload
def zip(x: Iterable[T], y: Iterable[S]) -> Iterator[Tuple[T, S]]: ...
@overload
def zip(x: Iterable[T], y: Iterable[S], z: Iterable[V]) -> Iterator[Tuple[T, S, V]]: ...
def eval(e: str) -> Any: ...
def abs(x: __SupportsAbs[T]) -> T: ...
@overload
def divmod(x: __SupportsDivMod[T_contra, T_co], y: T_contra) -> T_co: ...
@overload
def divmod(x: T_contra, y: __SupportsRDivMod[T_contra, T_co]) -> T_co: ...
@overload
def pow(base: __SupportsPow2[T_contra, T_co], exp: T_contra, mod: None = None) -> T_co: ...
@overload
def pow(base: __SupportsPow3NoneOnly[T_contra, T_co], exp: T_contra, mod: None = None) -> T_co: ...
@overload
def pow(base: __SupportsPow3[T_contra, _M, T_co], exp: T_contra, mod: _M) -> T_co: ...
def exit() -> None: ...
def min(x: T, y: T) -> T: ...
def max(x: T, y: T) -> T: ...
def repr(o: object) -> str: ...
def ascii(o: object) -> str: ...
def ord(o: object) -> int: ...
def chr(i: int) -> str: ...

class classmethod: ...
class staticmethod: ...

NotImplemented: Any
