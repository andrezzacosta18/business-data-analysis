from .node_util import ExplicitNodeVisitor as ExplicitNodeVisitor
from .op_util import Precedence as Precedence, get_op_precedence as get_op_precedence, get_op_symbol as get_op_symbol
from .source_repr import pretty_source as pretty_source
from .string_repr import pretty_string as pretty_string
from _typeshed import Incomplete

def to_source(node, indent_with=..., add_line_information: bool = False, pretty_string=..., pretty_source=..., source_generator_class: Incomplete | None = None):
    """This function can convert a node tree back into python sourcecode.
    This is useful for debugging purposes, especially if you're dealing with
    custom asts not generated by python itself.

    It could be that the sourcecode is evaluable when the AST itself is not
    compilable / evaluable.  The reason for this is that the AST contains some
    more data than regular sourcecode does, which is dropped during
    conversion.

    Each level of indentation is replaced with `indent_with`.  Per default this
    parameter is equal to four spaces as suggested by PEP 8, but it might be
    adjusted to match the application's styleguide.

    If `add_line_information` is set to `True` comments for the line numbers
    of the nodes are added to the output.  This can be used to spot wrong line
    number information of statement nodes.

    `source_generator_class` defaults to `SourceGenerator`, and specifies the
    class that will be instantiated and used to generate the source code.

    """
def precedence_setter(AST=..., get_op_precedence=..., isinstance=..., list=...):
    """ This only uses a closure for performance reasons,
        to reduce the number of attribute lookups.  (set_precedence
        is called a lot of times.)
    """

set_precedence: Incomplete

class Delimit:
    """A context manager that can add enclosing
       delimiters around the output of a
       SourceGenerator method.  By default, the
       parentheses are added, but the enclosed code
       may set discard=True to get rid of them.
    """
    discard: bool
    index: Incomplete
    closing: Incomplete
    p: Incomplete
    pp: Incomplete
    def __init__(self, tree, *args) -> None:
        """ use write instead of using result directly
            for initial data, because it may flush
            preceding data into result.
        """
    def __enter__(self): ...
    def __exit__(self, *exc_info) -> None: ...

class SourceGenerator(ExplicitNodeVisitor):
    """This visitor is able to transform a well formed syntax tree into Python
    sourcecode.

    For more details have a look at the docstring of the `node_to_source`
    function.

    """
    using_unicode_literals: bool
    result: Incomplete
    indent_with: Incomplete
    add_line_information: Incomplete
    indentation: int
    new_lines: int
    colinfo: Incomplete
    pretty_string: Incomplete
    write: Incomplete
    def __init__(self, indent_with, add_line_information: bool = False, pretty_string=..., len=..., isinstance=..., callable=...) -> None: ...
    def __getattr__(self, name, defaults=...):
        """ Get an attribute of the node.
            like dict.get (returns None if doesn't exist)
        """
    def delimit(self, *args): ...
    def conditional_write(self, *stuff): ...
    def newline(self, node: Incomplete | None = None, extra: int = 0) -> None: ...
    def body(self, statements) -> None: ...
    def else_body(self, elsewhat) -> None: ...
    def body_or_else(self, node) -> None: ...
    def visit_arguments(self, node) -> None: ...
    def statement(self, node, *params, **kw) -> None: ...
    def decorators(self, node, extra) -> None: ...
    def comma_list(self, items, trailing: bool = False) -> None: ...
    def visit_Assign(self, node) -> None: ...
    def visit_AugAssign(self, node) -> None: ...
    def visit_AnnAssign(self, node) -> None: ...
    def visit_ImportFrom(self, node) -> None: ...
    def visit_Import(self, node) -> None: ...
    def visit_Expr(self, node) -> None: ...
    def visit_FunctionDef(self, node, is_async: bool = False) -> None: ...
    def visit_AsyncFunctionDef(self, node) -> None: ...
    def visit_ClassDef(self, node) -> None: ...
    def visit_If(self, node) -> None: ...
    def visit_For(self, node, is_async: bool = False) -> None: ...
    def visit_AsyncFor(self, node) -> None: ...
    def visit_While(self, node) -> None: ...
    def visit_With(self, node, is_async: bool = False) -> None: ...
    def visit_AsyncWith(self, node) -> None: ...
    def visit_withitem(self, node) -> None: ...
    def visit_NameConstant(self, node) -> None: ...
    def visit_Pass(self, node) -> None: ...
    def visit_Print(self, node) -> None: ...
    def visit_Delete(self, node) -> None: ...
    def visit_TryExcept(self, node) -> None: ...
    def visit_Try(self, node) -> None: ...
    def visit_ExceptHandler(self, node) -> None: ...
    def visit_TryFinally(self, node) -> None: ...
    def visit_Exec(self, node) -> None: ...
    def visit_Assert(self, node) -> None: ...
    def visit_Global(self, node) -> None: ...
    def visit_Nonlocal(self, node) -> None: ...
    def visit_Return(self, node) -> None: ...
    def visit_Break(self, node) -> None: ...
    def visit_Continue(self, node) -> None: ...
    def visit_Raise(self, node) -> None: ...
    def visit_Attribute(self, node) -> None: ...
    def visit_Call(self, node, len=...) -> None: ...
    def visit_Name(self, node) -> None: ...
    def visit_Constant(self, node) -> None: ...
    def visit_JoinedStr(self, node) -> None: ...
    def visit_Str(self, node) -> None: ...
    def visit_Bytes(self, node) -> None: ...
    def visit_Num(self, node, new=...) -> None: ...
    def visit_Tuple(self, node) -> None: ...
    def visit_List(self, node) -> None: ...
    def visit_Set(self, node) -> None: ...
    def visit_Dict(self, node) -> None: ...
    def visit_BinOp(self, node) -> None: ...
    def visit_BoolOp(self, node) -> None: ...
    def visit_Compare(self, node) -> None: ...
    def visit_NamedExpr(self, node) -> None: ...
    def visit_UnaryOp(self, node) -> None: ...
    def visit_Subscript(self, node) -> None: ...
    def visit_Slice(self, node) -> None: ...
    def visit_Index(self, node) -> None: ...
    def visit_ExtSlice(self, node) -> None: ...
    def visit_Yield(self, node) -> None: ...
    def visit_YieldFrom(self, node) -> None: ...
    def visit_Await(self, node) -> None: ...
    def visit_Lambda(self, node) -> None: ...
    def visit_Ellipsis(self, node) -> None: ...
    def visit_ListComp(self, node) -> None: ...
    def visit_GeneratorExp(self, node) -> None: ...
    def visit_SetComp(self, node) -> None: ...
    def visit_DictComp(self, node) -> None: ...
    def visit_IfExp(self, node) -> None: ...
    def visit_Starred(self, node) -> None: ...
    def visit_Repr(self, node) -> None: ...
    def visit_Module(self, node) -> None: ...
    visit_Interactive = visit_Module
    def visit_Expression(self, node) -> None: ...
    def visit_arg(self, node) -> None: ...
    def visit_alias(self, node) -> None: ...
    def visit_comprehension(self, node) -> None: ...
