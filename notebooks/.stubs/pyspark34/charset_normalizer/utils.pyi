from .constant import ENCODING_MARKS as ENCODING_MARKS, IANA_SUPPORTED_SIMILAR as IANA_SUPPORTED_SIMILAR, RE_POSSIBLE_ENCODING_INDICATION as RE_POSSIBLE_ENCODING_INDICATION, UNICODE_RANGES_COMBINED as UNICODE_RANGES_COMBINED, UNICODE_SECONDARY_RANGE_KEYWORD as UNICODE_SECONDARY_RANGE_KEYWORD, UTF8_MAXIMAL_ALLOCATION as UTF8_MAXIMAL_ALLOCATION
from typing import Generator, List, Tuple

def is_accentuated(character: str) -> bool: ...
def remove_accent(character: str) -> str: ...
def unicode_range(character: str) -> str | None:
    """
    Retrieve the Unicode range official name from a single character.
    """
def is_latin(character: str) -> bool: ...
def is_punctuation(character: str) -> bool: ...
def is_symbol(character: str) -> bool: ...
def is_emoticon(character: str) -> bool: ...
def is_separator(character: str) -> bool: ...
def is_case_variable(character: str) -> bool: ...
def is_cjk(character: str) -> bool: ...
def is_hiragana(character: str) -> bool: ...
def is_katakana(character: str) -> bool: ...
def is_hangul(character: str) -> bool: ...
def is_thai(character: str) -> bool: ...
def is_unicode_range_secondary(range_name: str) -> bool: ...
def is_unprintable(character: str) -> bool: ...
def any_specified_encoding(sequence: bytes, search_zone: int = 8192) -> str | None:
    """
    Extract using ASCII-only decoder any specified encoding in the first n-bytes.
    """
def is_multi_byte_encoding(name: str) -> bool:
    """
    Verify is a specific encoding is a multi byte one based on it IANA name
    """
def identify_sig_or_bom(sequence: bytes) -> Tuple[str | None, bytes]:
    """
    Identify and extract SIG/BOM in given sequence.
    """
def should_strip_sig_or_bom(iana_encoding: str) -> bool: ...
def iana_name(cp_name: str, strict: bool = True) -> str: ...
def range_scan(decoded_sequence: str) -> List[str]: ...
def cp_similarity(iana_name_a: str, iana_name_b: str) -> float: ...
def is_cp_similar(iana_name_a: str, iana_name_b: str) -> bool:
    """
    Determine if two code page are at least 80% similar. IANA_SUPPORTED_SIMILAR dict was generated using
    the function cp_similarity.
    """
def set_logging_handler(name: str = 'charset_normalizer', level: int = ..., format_string: str = '%(asctime)s | %(levelname)s | %(message)s') -> None: ...
def cut_sequence_chunks(sequences: bytes, encoding_iana: str, offsets: range, chunk_size: int, bom_or_sig_available: bool, strip_sig_or_bom: bool, sig_payload: bytes, is_multi_byte_decoder: bool, decoded_payload: str | None = None) -> Generator[str, None, None]: ...
