import jaxlib.mlir.ir as ir
import numpy as np
from _typeshed import Incomplete
from collections.abc import Sequence

def dtype_to_ir_type(dtype) -> ir.Type: ...
def shape_dtype_to_ir_type(shape: Sequence[int], dtype) -> ir.Type: ...

DimensionSize: Incomplete
ShapeTypePair: Incomplete

def mk_result_types_and_shapes(shape_type_pairs: Sequence[ShapeTypePair]) -> tuple[list[ir.Type], list[ir.Value] | None]: ...
def shape_tensor(sizes: Sequence[int | ir.Value]) -> ir.Value: ...
def hlo_const(x: np.ndarray) -> ir.Value: ...
def hlo_u8(x: int): ...
def hlo_s32(x: int): ...
def ensure_hlo_s32(x: DimensionSize): ...
def hlo_min(x: DimensionSize, y: DimensionSize) -> DimensionSize: ...
def hlo_add(x: DimensionSize, y: DimensionSize) -> DimensionSize: ...
def custom_call(call_target_name: str | bytes, out_types: Sequence[ir.Type], operands: Sequence[ir.Value], operand_layouts: Sequence[Sequence[int]] | None = None, result_layouts: Sequence[Sequence[int]] | None = None, backend_config: str = '', has_side_effect: bool = False, api_version: int = 2, operand_output_aliases: dict[int, int] = {}, result_shapes: Sequence[ir.Value] | None = None) -> Sequence[ir.Value]:
    """Wraps a hlo.CustomCall

  Args:
  ...
  operand_output_alias: a dictionary mapping input operand index -> output
    index that must alias.
  result_shapes: 1D integer tensors that represent the result shapes, to be
      used when the results have dynamic shapes. Its length must
      match the number of the results. They are appended to the list
      of operands.
  """
