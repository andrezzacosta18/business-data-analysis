import pathlib
from _typeshed import Incomplete
from dataclasses import dataclass
from torchgen.api import cpp as cpp
from torchgen.api.translate import translate as translate
from torchgen.api.types import Binding as Binding, CppSignature as CppSignature, CppSignatureGroup as CppSignatureGroup, DispatcherSignature as DispatcherSignature, NamedCType as NamedCType, NativeSignature as NativeSignature, SpecialArgName as SpecialArgName
from torchgen.context import method_with_native_function as method_with_native_function, native_function_manager as native_function_manager, with_native_function as with_native_function, with_native_function_and_indices as with_native_function_and_indices
from torchgen.gen_functionalization_type import GenCompositeViewCopyKernel as GenCompositeViewCopyKernel, gen_functionalization_definition as gen_functionalization_definition, gen_functionalization_registration as gen_functionalization_registration, gen_functionalization_view_inverse_declaration as gen_functionalization_view_inverse_declaration
from torchgen.gen_vmap_plumbing import gen_all_vmap_plumbing as gen_all_vmap_plumbing
from torchgen.model import Argument as Argument, BackendIndex as BackendIndex, BackendMetadata as BackendMetadata, BaseOperatorName as BaseOperatorName, DEFAULT_KERNEL_NAMESPACE as DEFAULT_KERNEL_NAMESPACE, DispatchKey as DispatchKey, FRAGMENT_NAMESPACES as FRAGMENT_NAMESPACES, FunctionSchema as FunctionSchema, Location as Location, NativeFunction as NativeFunction, NativeFunctionsGroup as NativeFunctionsGroup, NativeFunctionsViewGroup as NativeFunctionsViewGroup, OperatorName as OperatorName, OptionalType as OptionalType, STRUCTURED_DISPATCH_KEYS as STRUCTURED_DISPATCH_KEYS, SchemaKind as SchemaKind, SelfArgument as SelfArgument, TensorOptionsArguments as TensorOptionsArguments, Type as Type, Variant as Variant, ViewSchemaKind as ViewSchemaKind, is_cuda_dispatch_key as is_cuda_dispatch_key, is_generic_dispatch_key as is_generic_dispatch_key, is_ufunc_dispatch_key as is_ufunc_dispatch_key
from torchgen.native_function_generation import add_generated_native_functions as add_generated_native_functions, gen_composite_functional_kernel as gen_composite_functional_kernel, gen_composite_out_kernel as gen_composite_out_kernel, pre_group_native_functions as pre_group_native_functions
from torchgen.selective_build.selector import SelectiveBuilder as SelectiveBuilder
from torchgen.utils import FileManager as FileManager, NamespaceHelper as NamespaceHelper, Target as Target, YamlDumper as YamlDumper, YamlLoader as YamlLoader, assert_never as assert_never, concatMap as concatMap, context as context, make_file_manager as make_file_manager, mapMaybe as mapMaybe
from typing import Callable, Dict, List, NamedTuple, Sequence, Set, Tuple, TypeVar
from typing_extensions import Literal

T = TypeVar('T')

class LineLoader(YamlLoader):
    def construct_mapping(self, node, deep: bool = False): ...

class ParsedYaml(NamedTuple):
    native_functions: Incomplete
    backend_indices: Incomplete

def parse_native_yaml_struct(es: object, valid_tags: Set[str], ignore_keys: Set[DispatchKey] | None = None, path: str = '<stdin>', skip_native_fns_gen: bool = False) -> ParsedYaml: ...
def parse_tags_yaml_struct(es: object, path: str = '<stdin>') -> Set[str]: ...
def parse_tags_yaml(path: str) -> Set[str]: ...
def parse_native_yaml(path: str, tags_yaml_path: str, ignore_keys: Set[DispatchKey] | None = None, *, skip_native_fns_gen: bool = False) -> ParsedYaml: ...
def error_check_native_functions(funcs: Sequence[NativeFunction]) -> None: ...
def cpp_string(s: str) -> str:
    """Convert a python string into a c++ string literal"""
def static_dispatch_keys(backends: List[BackendIndex]) -> List[DispatchKey]: ...
def get_static_dispatch_backend(f: NativeFunction, backend_index: BackendIndex) -> DispatchKey | None: ...
def static_dispatch_ops_header(f: NativeFunction, backend_index: List[BackendIndex]) -> str | None: ...
def static_dispatch_extra_headers(backends: List[BackendIndex]) -> List[str]: ...
def translate_args(sig: CppSignature | DispatcherSignature, cpp_sig: CppSignature) -> str: ...
def generate_static_dispatch_backend_call(sig: CppSignature | DispatcherSignature, f: NativeFunction, backend_index: BackendIndex) -> str: ...
def generate_static_dispatch_fallback_call(sig: CppSignature | DispatcherSignature, f: NativeFunction, backend_indices: List[BackendIndex]) -> str: ...
def static_dispatch(sig: CppSignature | DispatcherSignature, f: NativeFunction, backend_indices: List[BackendIndex]) -> str:
    '''
    For a given `NativeFunction`, find out the corresponding backend and dispatch to it. If more than one
    backends exsit, fallback to static dispatch by determining dispatch key from inputs.
    Arguments:
        sig: A CppSignature or DispatcherSignature for this native function we want to use.
        f: NativeFunction to generate static dispatch.
        backend_indices: All available backends.
    Return:
        C++ code to call backend-specific functions, e.g., "return at::cpu::add(self, other, scale);"
    '''

@dataclass(frozen=True)
class RegisterSchema:
    selector: SelectiveBuilder
    def __call__(self, f: NativeFunction) -> str | None: ...
    def __init__(self, selector) -> None: ...

@dataclass(frozen=True)
class ComputeOperators:
    target: Literal[Target.DECLARATION, Target.DEFINITION]
    static_dispatch_backend_indices: List[BackendIndex]
    def __call__(self, f: NativeFunction) -> str: ...
    def __init__(self, target, static_dispatch_backend_indices) -> None: ...

@dataclass(frozen=True)
class ComputeFunction:
    def __call__(self, f: NativeFunction) -> str | None: ...

@dataclass(frozen=True)
class ComputeTensorMethod:
    target: Literal[Target.DECLARATION, Target.DEFINITION]
    static_dispatch_backend_indices: List[BackendIndex]
    def __call__(self, f: NativeFunction) -> str | None: ...
    def __init__(self, target, static_dispatch_backend_indices) -> None: ...

@dataclass(frozen=True)
class ComputeRedispatchFunction:
    def __call__(self, f: NativeFunction) -> str | None: ...

def compute_aten_op(f: NativeFunction) -> str: ...
def compute_meta_function_declaration(g: NativeFunctionsGroup) -> str | None: ...
def needs_backend_select(f: NativeFunction, selector: SelectiveBuilder) -> bool: ...

@dataclass(frozen=True)
class ComputeBackendSelect:
    target: Literal[Target.DEFINITION, Target.REGISTRATION]
    selector: SelectiveBuilder
    def __call__(self, f: NativeFunction) -> str | None: ...
    def __init__(self, target, selector) -> None: ...

def format_yaml(data: object) -> str: ...
def pythonify_default(s: str) -> object: ...
def dynamic_type(t: Type) -> str: ...
def compute_method_of_yaml(variants: Set[Variant]) -> List[str]: ...
def compute_returns_yaml(f: NativeFunction) -> Tuple[List[Dict[str, str]], Dict[str, str]]: ...
def compute_cpp_argument_yaml(cpp_a: Binding, *, schema_order: bool, kwarg_only_set: Set[str], out_arg_set: Set[str], name_to_field_name: Dict[str, str]) -> object: ...
def compute_argument_yaml(a: Argument, *, schema_order: bool, kwarg_only_set: Set[str], out_arg_set: Set[str], name_to_field_name: Dict[str, str]) -> object: ...
def compute_declaration_yaml(f: NativeFunction) -> object: ...
def has_autogenerated_composite_kernel(f: NativeFunction) -> bool: ...
def compute_registration_declarations(f: NativeFunction, backend_indices: Dict[DispatchKey, BackendIndex]) -> str: ...
def get_custom_build_selector(provided_op_registration_allowlist: List[str] | None, op_selection_yaml_path: str | None) -> SelectiveBuilder: ...
def get_grouped_by_view_native_functions(native_functions: Sequence[NativeFunction]) -> Sequence[NativeFunction | NativeFunctionsViewGroup]: ...
def get_grouped_native_functions(native_functions: Sequence[NativeFunction]) -> Sequence[NativeFunction | NativeFunctionsGroup]: ...
def get_native_function_declarations(*, grouped_native_functions: Sequence[NativeFunction | NativeFunctionsGroup], backend_indices: Dict[DispatchKey, BackendIndex], native_function_decl_gen: Callable[[NativeFunctionsGroup | NativeFunction, BackendIndex], List[str]] = ...) -> List[str]:
    """
    Generate kernel declarations, in `NativeFunction(s).h`.
    :param grouped_native_functions: a sequence of `NativeFunction` or `NativeFunctionGroup`.
    :param backend_indices: kernel collections grouped by dispatch key.
    :param native_function_decl_gen: callable to generate kernel declaration for each `NativeFunction`.
    :return: a list of string, from the string with all declarations, grouped by namespaces, split by newline.
    """
def get_kernel_namespace(*, f: NativeFunction | NativeFunctionsGroup, backend_idx: BackendIndex) -> str: ...
def get_native_function_definitions(*, fm: FileManager, grouped_native_functions: Sequence[NativeFunction | NativeFunctionsGroup], dispatch_key: DispatchKey, backend_idx: BackendIndex, selector: SelectiveBuilder, rocm: bool, symint: bool, skip_dispatcher_op_registration: bool, gen_dispatch_helpers: bool) -> List[str]: ...
def get_namespaced_declaration(*, grouped_native_functions: Sequence[NativeFunction | NativeFunctionsGroup], dispatch_key: DispatchKey, backend_idx: BackendIndex, selector: SelectiveBuilder, rocm: bool, symint: bool) -> List[str]: ...
def get_native_function_schema_registrations(*, native_functions: Sequence[NativeFunction], schema_selector: SelectiveBuilder) -> Tuple[List[str], str]: ...
def gen_aggregated_headers(*, native_functions: Sequence[NativeFunction], grouped_native_functions: Sequence[NativeFunction | NativeFunctionsGroup], structured_native_functions: Sequence[NativeFunctionsGroup], static_dispatch_idx: List[BackendIndex], selector: SelectiveBuilder, backend_indices: Dict[DispatchKey, BackendIndex], cpu_fm: FileManager, cuda_fm: FileManager, functions_keys: Set[DispatchKey], dispatch_keys: Sequence[DispatchKey], rocm: bool) -> None: ...
def gen_per_operator_headers(*, native_functions: Sequence[NativeFunction], grouped_native_functions: Sequence[NativeFunction | NativeFunctionsGroup], static_dispatch_idx: List[BackendIndex], selector: SelectiveBuilder, backend_indices: Dict[DispatchKey, BackendIndex], cpu_fm: FileManager, cuda_fm: FileManager, ops_fm: FileManager, functions_keys: Set[DispatchKey], dispatch_keys: Sequence[DispatchKey], rocm: bool) -> None: ...
def gen_headers(*, native_functions: Sequence[NativeFunction], valid_tags: Set[str], grouped_native_functions: Sequence[NativeFunction | NativeFunctionsGroup], structured_native_functions: Sequence[NativeFunctionsGroup], static_dispatch_idx: List[BackendIndex], selector: SelectiveBuilder, backend_indices: Dict[DispatchKey, BackendIndex], core_fm: FileManager, cpu_fm: FileManager, cuda_fm: FileManager, ops_fm: FileManager, dispatch_keys: Sequence[DispatchKey], functions_keys: Set[DispatchKey], rocm: bool, per_operator_headers: bool) -> None: ...
def gen_source_files(*, native_functions: Sequence[NativeFunction], grouped_native_functions: Sequence[NativeFunction | NativeFunctionsGroup], structured_native_functions: Sequence[NativeFunctionsGroup], view_groups: Sequence[NativeFunctionsViewGroup], selector: SelectiveBuilder, static_dispatch_idx: List[BackendIndex], backend_indices: Dict[DispatchKey, BackendIndex], core_fm: FileManager, cpu_fm: FileManager, cpu_vec_fm: FileManager, cuda_fm: FileManager, dispatch_keys: Sequence[DispatchKey], functions_keys: Set[DispatchKey], rocm: bool, force_schema_registration: bool, per_operator_headers: bool, skip_dispatcher_op_registration: bool) -> None: ...
def gen_declarations_yaml(cpu_fm: FileManager, native_functions: Sequence[NativeFunction]) -> None: ...
def get_torchgen_root() -> pathlib.Path:
    """
    If you're depending on torchgen out-of-tree, you can use the root to figure
    out the path to native_functions.yaml
    """
def main() -> None: ...
