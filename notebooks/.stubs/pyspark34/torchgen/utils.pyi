from _typeshed import Incomplete
from argparse import Namespace
from enum import Enum
from torchgen.code_template import CodeTemplate as CodeTemplate
from typing import Any, Callable, Dict, Generic, Iterable, Iterator, List, NoReturn, Sequence, Set, Tuple, TypeVar
from typing_extensions import Literal
from yaml import SafeDumper as Dumper, SafeLoader as Loader

YamlDumper = Dumper

class YamlLoader(Loader):
    def construct_mapping(self, node, deep: bool = False): ...

class Target(Enum):
    DEFINITION: Incomplete
    DECLARATION: Incomplete
    REGISTRATION: Incomplete
    ANONYMOUS_DEFINITION: Incomplete
    NAMESPACED_DEFINITION: Incomplete
    NAMESPACED_DECLARATION: Incomplete

IDENT_REGEX: str

def split_name_params(schema: str) -> Tuple[str, List[str]]: ...
T = TypeVar('T')
S = TypeVar('S')

def mapMaybe(func: Callable[[T], S | None], xs: Iterable[T]) -> Iterator[S]: ...
def concatMap(func: Callable[[T], Sequence[S]], xs: Iterable[T]) -> Iterator[S]: ...
def context(msg_fn: Callable[[], str]) -> Iterator[None]: ...
def assert_never(x: NoReturn) -> NoReturn: ...
def string_stable_hash(s: str) -> int: ...

class FileManager:
    install_dir: str
    template_dir: str
    dry_run: bool
    filenames: Set[str]
    def __init__(self, install_dir: str, template_dir: str, dry_run: bool) -> None: ...
    def substitute_with_template(self, template_fn: str, env_callable: Callable[[], str | Dict[str, Any]]) -> str: ...
    def write_with_template(self, filename: str, template_fn: str, env_callable: Callable[[], str | Dict[str, Any]]) -> None: ...
    def write(self, filename: str, env_callable: Callable[[], str | str | Dict[str, Any]]) -> None: ...
    def write_sharded(self, filename: str, items: Iterable[T], *, key_fn: Callable[[T], str], env_callable: Callable[[T], Dict[str, List[str]]], num_shards: int, base_env: Dict[str, Any] | None = None, sharded_keys: Set[str]) -> None: ...
    def write_outputs(self, variable_name: str, filename: str) -> None:
        """Write a file containing the list of all outputs which are
        generated by this script."""
    def template_dir_for_comments(self) -> str:
        """
        This needs to be deterministic. The template dir is an absolute path
        that varies across builds. So, just use the path relative to this file,
        which will point to the codegen source but will be stable.
        """

def make_file_manager(options: Namespace, install_dir: str | None = None) -> FileManager: ...
def dataclass_repr(obj: Any, indent: int = 0, width: int = 80) -> str: ...

class NamespaceHelper:
    """A helper for constructing the namespace open and close strings for a nested set of namespaces.

    e.g. for namespace_str torch::lazy,

    prologue:
    namespace torch {
    namespace lazy {

    epilogue:
    } // namespace lazy
    } // namespace torch
    """
    cpp_namespace_: Incomplete
    prologue_: Incomplete
    epilogue_: Incomplete
    namespaces_: Incomplete
    entity_name_: Incomplete
    def __init__(self, namespace_str: str, entity_name: str = '', max_level: int = 2) -> None: ...
    @staticmethod
    def from_namespaced_entity(namespaced_entity: str, max_level: int = 2) -> NamespaceHelper:
        '''
        Generate helper from nested namespaces as long as class/function name. E.g.: "torch::lazy::add"
        '''
    @property
    def prologue(self) -> str: ...
    @property
    def epilogue(self) -> str: ...
    @property
    def entity_name(self) -> str: ...
    def get_cpp_namespace(self, default: str = '') -> str:
        '''
        Return the namespace string from joining all the namespaces by "::" (hence no leading "::").
        Return default if namespace string is empty.
        '''

class OrderedSet(Generic[T]):
    storage: Dict[T, Literal[None]]
    def __init__(self, iterable: Iterable[T] | None = None) -> None: ...
    def __contains__(self, item: T) -> bool: ...
    def __iter__(self) -> Iterator[T]: ...
    def update(self, items: OrderedSet[T]) -> None: ...
    def add(self, item: T) -> None: ...
    def copy(self) -> OrderedSet[T]: ...
    @staticmethod
    def union(*args: OrderedSet[T]) -> OrderedSet[T]: ...
    def __or__(self, other: OrderedSet[T]) -> OrderedSet[T]: ...
    def __ior__(self, other: OrderedSet[T]) -> OrderedSet[T]: ...
    def __eq__(self, other: object) -> bool: ...
