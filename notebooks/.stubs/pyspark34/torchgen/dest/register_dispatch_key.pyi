from dataclasses import dataclass
from torchgen.api.translate import translate as translate
from torchgen.api.types import BaseCType as BaseCType, Binding as Binding, ConstRefCType as ConstRefCType, CppSignature as CppSignature, CppSignatureGroup as CppSignatureGroup, DispatcherSignature as DispatcherSignature, Expr as Expr, MutRefCType as MutRefCType, NamedCType as NamedCType, NativeSignature as NativeSignature, kernel_signature as kernel_signature, tensorT as tensorT
from torchgen.context import method_with_native_function as method_with_native_function, native_function_manager as native_function_manager
from torchgen.model import Argument as Argument, BackendIndex as BackendIndex, DeviceCheckType as DeviceCheckType, DispatchKey as DispatchKey, NativeFunction as NativeFunction, NativeFunctionsGroup as NativeFunctionsGroup, SchemaKind as SchemaKind, TensorOptionsArguments as TensorOptionsArguments, gets_generated_out_inplace_wrapper as gets_generated_out_inplace_wrapper, is_cuda_dispatch_key as is_cuda_dispatch_key
from torchgen.selective_build.selector import SelectiveBuilder as SelectiveBuilder
from torchgen.utils import Target as Target, assert_never as assert_never, mapMaybe as mapMaybe
from typing import List, Tuple
from typing_extensions import Literal

def gen_registration_headers(backend_index: BackendIndex, per_operator_headers: bool, rocm: bool) -> List[str]: ...
def gen_empty_impl_names(backend_index: BackendIndex) -> Tuple[str | None, str | None]: ...
def gen_create_out_helper(backend_index: BackendIndex) -> List[str]: ...
def gen_maybe_create_proxy_helper(backend_index: BackendIndex) -> List[str]: ...
def gen_resize_out_helper(backend_index: BackendIndex) -> List[str]: ...
def gen_check_inplace_helper(backend_index: BackendIndex) -> List[str]: ...
def gen_registration_helpers(backend_index: BackendIndex) -> List[str]: ...

@dataclass(frozen=True)
class RegisterDispatchKey:
    backend_index: BackendIndex
    target: Literal[Target.ANONYMOUS_DEFINITION] | Literal[Target.NAMESPACED_DEFINITION] | Literal[Target.NAMESPACED_DECLARATION] | Literal[Target.REGISTRATION]
    selector: SelectiveBuilder
    rocm: bool
    symint: bool
    class_method_name: str | None
    skip_dispatcher_op_registration: bool
    @staticmethod
    def gen_device_check(type: DeviceCheckType, args: List[Argument], method_name: str) -> str: ...
    def __call__(self, f: NativeFunctionsGroup | NativeFunction) -> List[str]: ...
    def wrapper_kernel_sig(self, f: NativeFunction) -> NativeSignature | DispatcherSignature: ...
    def gen_out_inplace_wrapper(self, f: NativeFunction, g: NativeFunctionsGroup | None) -> str | None: ...
    def gen_structured(self, g: NativeFunctionsGroup) -> List[str]: ...
    def gen_unstructured(self, f: NativeFunction, g: NativeFunctionsGroup | None = None) -> str | None: ...
    def __init__(self, backend_index, target, selector, rocm, symint, class_method_name, skip_dispatcher_op_registration) -> None: ...

@dataclass(frozen=True)
class StructuredRegisterDispatchKey(RegisterDispatchKey):
    g: NativeFunctionsGroup
    def gen_class_set_output_functions(self, k: SchemaKind, parent_class: str, generate_super: bool) -> str: ...
    def gen_class_set_output_body(self, k: SchemaKind, maybe_create_proxy: bool) -> str: ...
    def gen_class_ctor(self, k: SchemaKind, class_name: str, returns: int) -> str: ...
    def gen_class(self, f: NativeFunction, k: SchemaKind, *, class_name: str, parent_class: str, generate_super: bool) -> str: ...
    def gen_one(self, f: NativeFunction) -> str | None: ...
    def __init__(self, backend_index, target, selector, rocm, symint, class_method_name, skip_dispatcher_op_registration, g) -> None: ...
