from _typeshed import Incomplete
from dataclasses import dataclass
from torchgen.api import cpp as cpp, dispatcher as dispatcher
from torchgen.api.translate import translate as translate
from torchgen.api.types import BaseCType as BaseCType, Binding as Binding, CType as CType, DispatcherSignature as DispatcherSignature, FunctionalizationLambda as FunctionalizationLambda, NativeSignature as NativeSignature, VectorCType as VectorCType, ViewInverseSignature as ViewInverseSignature, iTensorListRefT as iTensorListRefT, tensorListT as tensorListT, tensorT as tensorT
from torchgen.context import method_with_native_function as method_with_native_function, native_function_manager as native_function_manager, with_native_function as with_native_function, with_native_function_and as with_native_function_and
from torchgen.model import Argument as Argument, BackendIndex as BackendIndex, BaseTy as BaseTy, BaseType as BaseType, FunctionSchema as FunctionSchema, ListType as ListType, NativeFunction as NativeFunction, NativeFunctionsGroup as NativeFunctionsGroup, NativeFunctionsViewGroup as NativeFunctionsViewGroup, Return as Return, SchemaKind as SchemaKind, SelfArgument as SelfArgument, TensorOptionsArguments as TensorOptionsArguments
from torchgen.native_function_generation import INPLACE_OPS_THAT_DONT_GET_GROUPED_PROPERLY as INPLACE_OPS_THAT_DONT_GET_GROUPED_PROPERLY, MUTABLE_OPS_THAT_CANNOT_GET_AN_OUT_VARIANT as MUTABLE_OPS_THAT_CANNOT_GET_AN_OUT_VARIANT, OUT_OPS_THAT_DONT_GET_GROUPED_PROPERLY as OUT_OPS_THAT_DONT_GET_GROUPED_PROPERLY
from torchgen.selective_build.selector import SelectiveBuilder as SelectiveBuilder
from typing import Callable, List, Tuple

MUTABLE_OPS_NOT_USING_FUNCTIONALIZATION: Incomplete

@dataclass(frozen=True)
class GenCompositeViewCopyKernel:
    backend_index: BackendIndex
    def __call__(self, g: NativeFunctionsViewGroup) -> str | None: ...
    def __init__(self, backend_index) -> None: ...

def return_str(rets: Tuple[Return, ...], names: List[str]) -> str: ...
def modifies_arguments(f: NativeFunction) -> bool: ...
def wrapper_name(func: FunctionSchema) -> str: ...
def is_tensor_like(a: Argument | TensorOptionsArguments | SelfArgument) -> bool: ...
def get_owning_type(t: CType) -> Tuple[CType, Callable[[str], str]]: ...
def unwrap_tensor_args(sig: DispatcherSignature, *, is_view_op: bool) -> Tuple[str, List[Binding]]: ...
def convert_to_meta_tensors(sig: DispatcherSignature) -> Tuple[str, List[Binding]]: ...
def assert_view_op_properties(func: FunctionSchema) -> None: ...
def emit_view_functionalization_body(g: NativeFunctionsViewGroup, *, view_inplace: bool) -> str: ...
def maybe_create_output(f: NativeFunction, var_name: str) -> str: ...
def get_mutable_redispatch_return_names(f: NativeFunction, inner_return_var: str) -> Tuple[List[str], List[str]]: ...
def return_from_mutable_noop_redispatch(f: NativeFunction, inner_return_var: str) -> str: ...
def wrap_propagate_mutations_and_return(f: NativeFunction, functional_op: NativeFunction, inner_return_var: str) -> str: ...
def emit_inplace_functionalization_body(f: NativeFunction, g: NativeFunctionsGroup) -> str: ...
def gen_functionalization_view_inverse_declaration(selector: SelectiveBuilder, g: NativeFunctionsViewGroup) -> str | None: ...
def gen_functionalization_registration(selector: SelectiveBuilder, g: NativeFunction | NativeFunctionsGroup | NativeFunctionsViewGroup, composite_implicit_autograd_index: BackendIndex) -> List[str]: ...
def gen_functionalization_definition(selector: SelectiveBuilder, g: NativeFunction | NativeFunctionsGroup | NativeFunctionsViewGroup) -> List[str]: ...
