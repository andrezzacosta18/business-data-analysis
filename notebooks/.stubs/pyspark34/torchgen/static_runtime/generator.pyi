import logging
from _typeshed import Incomplete
from torchgen.context import native_function_manager as native_function_manager
from torchgen.model import Argument as Argument, BackendIndex as BackendIndex, BaseTy as BaseTy, BaseType as BaseType, FunctionSchema as FunctionSchema, NativeFunctionsGroup as NativeFunctionsGroup, NativeFunctionsViewGroup as NativeFunctionsViewGroup, OptionalType as OptionalType, SelfArgument as SelfArgument, TensorOptionsArguments as TensorOptionsArguments, Type as Type
from torchgen.static_runtime import config as config
from typing import Dict, List, Sequence, Tuple

logger: logging.Logger

def has_alias(arguments: Sequence[Argument | SelfArgument | TensorOptionsArguments]) -> bool: ...

BLOCKED_OPS: Incomplete

def is_supported(g: NativeFunctionsGroup | NativeFunctionsViewGroup) -> bool: ...
def ivalue_type_conversion_method(arg_type: BaseType | OptionalType | Type) -> Tuple[bool, str] | None:
    '''
    Return the method call expression of `c10::ivalue\' to convert its contained value to
    the expected value of `arg_type` type. For example, for `arg_type` == BaseTy.Tensor,
    this function returns ".toTensor()", so that it can be appended to the ivalue\'s
    variable name to get the value of the expected type.
    '''

should_use_int_tensor_ops_: Incomplete
should_use_complex_tensor_ops_: Incomplete

def should_use_int_tensor(op_name: str) -> bool: ...
def should_use_complex_tensor(op_name: str) -> bool: ...

test_tensor_dim_ops_1_: Incomplete
test_tensor_dim_ops_2_: Incomplete

def test_tensor_dim(op_name: str) -> int: ...

test_tensor_shapes_string: str
test_tensor_shape_json: Dict[str, str]

def test_tensor_shape(op_name: str) -> str: ...
def test_value_expression(arg_type: BaseType | OptionalType | Type, index: int, op_name: str) -> str: ...
def generate_test_value_definitions(schema: FunctionSchema, index: int) -> str: ...
def generate_test_value_names(schema: FunctionSchema, index: int) -> str: ...

generate_test_ir_arguments_base_ty_to_type_str_: Incomplete

def generate_test_ir_arguments(schema: FunctionSchema) -> List[Tuple[str, str | None]]: ...
def generate_arg_extraction(schema: FunctionSchema) -> str: ...
def get_kernel_name(g: NativeFunctionsGroup, backend_index: BackendIndex) -> str: ...
def get_out_kernel_name(g: NativeFunctionsGroup, backend_index: BackendIndex) -> str: ...
def generate_non_out_variant_call(g: NativeFunctionsGroup, backend_index: BackendIndex) -> str: ...
def generate_call_to_view_ops(g: NativeFunctionsViewGroup, backend_index: BackendIndex) -> str: ...
def generate_out_variant_call(g: NativeFunctionsGroup, backend_index: BackendIndex) -> str: ...

no_memory_resize_ops: Incomplete

def should_check_resize(schema: FunctionSchema) -> bool: ...
def op_name_from_group(g: NativeFunctionsGroup) -> str: ...

class GenOpDispatcher:
    def out_variant(self, groups: Sequence[NativeFunctionsGroup], backend_index: BackendIndex) -> str: ...
    def view(self, groups: Sequence[NativeFunctionsViewGroup], backend_index: BackendIndex) -> str: ...
    def out_variant_op_generator(self, g: NativeFunctionsGroup, backend_index: BackendIndex) -> str: ...
    def view_op_generator(self, g: NativeFunctionsViewGroup, backend_index: BackendIndex) -> str: ...

class GenOpTestCase:
    def out_variant(self, groups: Sequence[NativeFunctionsGroup]) -> str: ...
    def view(self, groups: Sequence[NativeFunctionsViewGroup]) -> str: ...
    def out_variant_op_test_case_generator(self, g: NativeFunctionsGroup) -> str: ...
    def view_op_test_case_generator(self, g: NativeFunctionsViewGroup) -> str: ...
