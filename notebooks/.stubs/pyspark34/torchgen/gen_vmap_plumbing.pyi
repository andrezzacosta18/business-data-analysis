from dataclasses import dataclass
from torchgen.api.translate import translate as translate
from torchgen.api.types import DispatcherSignature as DispatcherSignature
from torchgen.context import method_with_native_function as method_with_native_function
from torchgen.model import Argument as Argument, BaseTy as BaseTy, BaseType as BaseType, FunctionSchema as FunctionSchema, ListType as ListType, NativeFunction as NativeFunction, OptionalType as OptionalType, Return as Return, SchemaKind as SchemaKind, Type as Type
from torchgen.utils import mapMaybe as mapMaybe
from typing import List, Sequence, Tuple

def is_tensor(typ: Type) -> bool: ...
def is_optional_tensor(typ: Type) -> bool: ...
def is_tensor_list(typ: Type) -> bool: ...
def unwrap_tensor(name: str, cur_level_var: str) -> List[str]: ...
def unwrap_optional_tensor(name: str, cur_level_var: str) -> List[str]: ...
def gen_unwraps(flat_arguments: Sequence[Argument], cur_level_var: str) -> Tuple[str, List[str]]: ...
def gen_case_where_all_bdims_are_none(outer_sig: DispatcherSignature, schema: FunctionSchema, cur_level_var: str) -> str: ...
def gen_returns(returns: Tuple[Return, ...], cur_level_var: str, results_var: str) -> str: ...
def accepts_at_least_one_tensor_input(schema: FunctionSchema) -> bool: ...
def is_mutated_arg(argument: Argument) -> bool: ...
def gen_vmap_inplace_plumbing(native_function: NativeFunction) -> str | None: ...
def gen_vmap_plumbing_no_returns(native_function: NativeFunction) -> str: ...
def gen_vmap_plumbing(native_function: NativeFunction) -> str | None: ...

@dataclass(frozen=True)
class ComputeBatchRulePlumbing:
    def __call__(self, f: NativeFunction) -> str | None: ...

def gen_all_vmap_plumbing(native_functions: Sequence[NativeFunction]) -> str: ...
