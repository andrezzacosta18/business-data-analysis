from .types import ArrayRefCType as ArrayRefCType, BaseTypeToCppMapping as BaseTypeToCppMapping, OptionalCType as OptionalCType, scalarT as scalarT, tensorListT as tensorListT, tensorT as tensorT
from _typeshed import Incomplete
from torchgen import local as local
from torchgen.api.types import ArgName as ArgName, ArrayCType as ArrayCType, BaseCType as BaseCType, Binding as Binding, CType as CType, ConstRefCType as ConstRefCType, MutRefCType as MutRefCType, NamedCType as NamedCType, SpecialArgName as SpecialArgName, TupleCType as TupleCType, VectorCType as VectorCType, voidT as voidT
from torchgen.model import Argument as Argument, Arguments as Arguments, BaseTy as BaseTy, BaseType as BaseType, ListType as ListType, NativeFunction as NativeFunction, OptionalType as OptionalType, Return as Return, SelfArgument as SelfArgument, TensorOptionsArguments as TensorOptionsArguments, Type as Type
from torchgen.utils import assert_never as assert_never
from typing import List, Sequence, Set

def valuetype_type(t: Type, *, binds: ArgName, remove_non_owning_ref_types: bool = False) -> NamedCType | None: ...
def argumenttype_type(t: Type, *, mutable: bool, binds: ArgName, remove_non_owning_ref_types: bool = False) -> NamedCType: ...
def argument_type(a: Argument, *, binds: ArgName) -> NamedCType: ...
def returntype_type(t: Type, *, mutable: bool) -> CType: ...
def return_type(r: Return) -> CType: ...
def returns_type(rs: Sequence[Return]) -> CType: ...
def return_names(f: NativeFunction, *, fallback_name: str = 'result') -> Sequence[str]: ...

JIT_TO_CPP_DEFAULT: Incomplete

def default_expr(d: str, t: Type) -> str: ...
def argument(a: Argument | TensorOptionsArguments | SelfArgument, *, cpp_no_default_args: Set[str], method: bool, faithful: bool, has_tensor_options: bool) -> List[Binding]: ...
def arguments(arguments: Arguments, *, faithful: bool, method: bool, cpp_no_default_args: Set[str]) -> List[Binding]: ...
