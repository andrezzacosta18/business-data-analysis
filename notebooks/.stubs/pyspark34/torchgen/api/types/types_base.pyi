from _typeshed import Incomplete
from abc import ABC
from dataclasses import dataclass
from enum import Enum
from torchgen.model import Argument as Argument, SelfArgument as SelfArgument, TensorOptionsArguments as TensorOptionsArguments
from typing import List

class SpecialArgName(Enum):
    possibly_redundant_memory_format: Incomplete
ArgName = str | SpecialArgName

@dataclass(frozen=True)
class BaseCppType:
    ns: str | None
    name: str
    def __init__(self, ns, name) -> None: ...

byteT: Incomplete
charT: Incomplete
shortT: Incomplete
int32T: Incomplete
longT: Incomplete
doubleT: Incomplete
floatT: Incomplete
boolT: Incomplete
voidT: Incomplete

class CType(ABC):
    def cpp_type(self, *, strip_ref: bool = False) -> str: ...
    def cpp_type_registration_declarations(self) -> str: ...
    def remove_const_ref(self) -> CType: ...

@dataclass(frozen=True)
class BaseCType(CType):
    type: BaseCppType
    def cpp_type(self, *, strip_ref: bool = False) -> str: ...
    def cpp_type_registration_declarations(self) -> str: ...
    def remove_const_ref(self) -> CType: ...
    def __init__(self, type) -> None: ...

@dataclass(frozen=True)
class ConstRefCType(CType):
    elem: CType
    def cpp_type(self, *, strip_ref: bool = False) -> str: ...
    def cpp_type_registration_declarations(self) -> str: ...
    def remove_const_ref(self) -> CType: ...
    def __init__(self, elem) -> None: ...

@dataclass(frozen=True)
class VectorCType(CType):
    elem: CType
    def cpp_type(self, *, strip_ref: bool = False) -> str: ...
    def cpp_type_registration_declarations(self) -> str: ...
    def remove_const_ref(self) -> CType: ...
    def __init__(self, elem) -> None: ...

@dataclass(frozen=True)
class ArrayCType(CType):
    elem: CType
    size: int
    def cpp_type(self, *, strip_ref: bool = False) -> str: ...
    def cpp_type_registration_declarations(self) -> str: ...
    def remove_const_ref(self) -> CType: ...
    def __init__(self, elem, size) -> None: ...

@dataclass(frozen=True)
class TupleCType(CType):
    elems: List['CType']
    def cpp_type(self, *, strip_ref: bool = False) -> str: ...
    def cpp_type_registration_declarations(self) -> str: ...
    def remove_const_ref(self) -> CType: ...
    def __init__(self, elems) -> None: ...

@dataclass(frozen=True)
class MutRefCType(CType):
    elem: CType
    def cpp_type(self, *, strip_ref: bool = False) -> str: ...
    def cpp_type_registration_declarations(self) -> str: ...
    def remove_const_ref(self) -> CType: ...
    def __init__(self, elem) -> None: ...

@dataclass(frozen=True)
class NamedCType:
    name: ArgName
    type: CType
    def cpp_type(self, *, strip_ref: bool = False) -> str: ...
    def cpp_type_registration_declarations(self) -> str: ...
    def remove_const_ref(self) -> NamedCType: ...
    def with_name(self, name: str) -> NamedCType: ...
    def __init__(self, name, type) -> None: ...

@dataclass(frozen=True)
class Binding:
    name: str
    nctype: NamedCType
    argument: Argument | TensorOptionsArguments | SelfArgument
    default: str | None = ...
    def rename(self, name: str) -> Binding: ...
    @property
    def type(self) -> str: ...
    def no_default(self) -> Binding: ...
    def decl(self, *, func_ptr_cast: bool = False) -> str: ...
    def decl_registration_declarations(self) -> str: ...
    def defn(self) -> str: ...
    def with_name(self, name: str) -> Binding: ...
    def __init__(self, name, nctype, argument, default) -> None: ...

@dataclass(frozen=True)
class Expr:
    expr: str
    type: NamedCType
    def __init__(self, expr, type) -> None: ...
