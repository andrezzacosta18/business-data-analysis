from dataclasses import dataclass
from torchgen.api import cpp as cpp, structured as structured
from torchgen.api.types import ArgName as ArgName, BaseCType as BaseCType, BaseCppType as BaseCppType, Binding as Binding, CType as CType, ConstRefCType as ConstRefCType, NamedCType as NamedCType, scalarT as scalarT
from torchgen.model import Argument as Argument, BaseTy as BaseTy, BaseType as BaseType, DispatchKey as DispatchKey, FunctionSchema as FunctionSchema, NativeFunctionsGroup as NativeFunctionsGroup, Type as Type
from typing import List

def schema_kernel_name(func: FunctionSchema, dispatch_key: DispatchKey) -> str: ...
def kernel_name(g: NativeFunctionsGroup, dispatch_key: DispatchKey) -> str: ...
def dispatchstub_type(t: Type, *, binds: ArgName) -> NamedCType | None: ...
def opmath_type(scalar_t: BaseCppType) -> BaseCppType: ...
def ufunctor_ctor_type(t: Type, *, binds: ArgName, scalar_t: BaseCppType) -> NamedCType: ...
def ufunctor_apply_type(t: Type, *, binds: ArgName, scalar_t: BaseCppType) -> NamedCType: ...
def ufunc_type(t: Type, *, binds: ArgName, compute_t: CType) -> NamedCType: ...
def ufunctor_ctor_argument(a: Argument, scalar_t: BaseCppType) -> Binding: ...
def ufunctor_apply_argument(a: Argument, scalar_t: BaseCppType) -> Binding: ...
def ufunc_argument(a: Argument, compute_t: CType) -> Binding: ...

@dataclass(frozen=True)
class UfunctorBindings:
    ctor: List[Binding]
    apply: List[Binding]
    def __init__(self, ctor, apply) -> None: ...

def ufunctor_arguments(g: NativeFunctionsGroup, *, scalar_tensor_idx: int | None, scalar_t: BaseCppType) -> UfunctorBindings: ...
def ufunc_arguments(g: NativeFunctionsGroup, *, compute_t: CType) -> List[Binding]: ...
def stub_arguments(g: NativeFunctionsGroup) -> List[Binding]: ...
