from _typeshed import Incomplete
from torchgen import local as local
from torchgen.api.types import ArgName as ArgName, ArrayCType as ArrayCType, ArrayRefCType as ArrayRefCType, BaseCType as BaseCType, BaseTypeToCppMapping as BaseTypeToCppMapping, Binding as Binding, CType as CType, ConstRefCType as ConstRefCType, ListCType as ListCType, MutRefCType as MutRefCType, NamedCType as NamedCType, OptionalCType as OptionalCType, SpecialArgName as SpecialArgName, SymIntT as SymIntT, TupleCType as TupleCType, VectorCType as VectorCType, boolT as boolT, dimnameListT as dimnameListT, iTensorListRefT as iTensorListRefT, intArrayRefT as intArrayRefT, longT as longT, optionalIntArrayRefT as optionalIntArrayRefT, optionalSymIntArrayRefT as optionalSymIntArrayRefT, scalarT as scalarT, symIntArrayRefT as symIntArrayRefT, tensorListT as tensorListT, tensorOptionsT as tensorOptionsT, tensorT as tensorT, voidT as voidT
from torchgen.model import Argument as Argument, Arguments as Arguments, BaseTy as BaseTy, BaseType as BaseType, FunctionSchema as FunctionSchema, ListType as ListType, NativeFunction as NativeFunction, OptionalType as OptionalType, Return as Return, SelfArgument as SelfArgument, TensorOptionsArguments as TensorOptionsArguments, Type as Type
from torchgen.utils import assert_never as assert_never
from typing import List, Sequence, Set

def name(func: FunctionSchema, *, faithful_name_for_out_overloads: bool = False, symint_overload: bool = False) -> str: ...
def valuetype_type(t: Type, *, binds: ArgName, remove_non_owning_ref_types: bool = False, symint: bool = False) -> NamedCType | None: ...
def argumenttype_type(t: Type, *, mutable: bool, binds: ArgName, remove_non_owning_ref_types: bool = False, symint: bool = False) -> NamedCType: ...
def argument_type(a: Argument, *, binds: ArgName, symint: bool = False) -> NamedCType: ...
def returntype_type(t: Type, *, mutable: bool, symint: bool = False) -> CType: ...
def return_type(r: Return, *, symint: bool = False) -> CType: ...
def returns_type(rs: Sequence[Return], *, symint: bool = False) -> CType: ...
def return_names(f: NativeFunction, *, fallback_name: str = 'result') -> Sequence[str]: ...

JIT_TO_CPP_DEFAULT: Incomplete

def default_expr(d: str, t: Type, *, symint: bool) -> str: ...
def argument(a: Argument | TensorOptionsArguments | SelfArgument, *, cpp_no_default_args: Set[str], method: bool, faithful: bool, symint: bool = False, has_tensor_options: bool) -> List[Binding]: ...
def arguments(arguments: Arguments, *, faithful: bool, symint: bool = False, method: bool, cpp_no_default_args: Set[str]) -> List[Binding]: ...
