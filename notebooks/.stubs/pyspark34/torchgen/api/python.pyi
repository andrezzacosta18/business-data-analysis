from _typeshed import Incomplete
from dataclasses import dataclass
from torchgen.api import cpp as cpp
from torchgen.api.types import Binding as Binding, CppSignature as CppSignature, CppSignatureGroup as CppSignatureGroup
from torchgen.gen import pythonify_default as pythonify_default
from torchgen.model import Argument as Argument, BaseTy as BaseTy, BaseType as BaseType, FunctionSchema as FunctionSchema, ListType as ListType, NativeFunction as NativeFunction, OptionalType as OptionalType, Return as Return, Type as Type, Variant as Variant
from typing import Dict, List, Sequence, Tuple

@dataclass(frozen=True)
class PythonReturns:
    returns: Tuple[Return, ...]
    def __init__(self, returns) -> None: ...

@dataclass(frozen=True)
class PythonArgument:
    name: str
    type: Type
    default: str | None
    default_init: str | None
    def argument_str(self, *, method: bool = False, symint: bool = True) -> str: ...
    def argument_str_pyi(self, *, method: bool = False, deprecated: bool = False) -> str: ...
    def __init__(self, name, type, default, default_init) -> None: ...

@dataclass(frozen=True)
class PythonOutArgument(PythonArgument):
    outputs: Tuple[PythonArgument, ...]
    @staticmethod
    def from_outputs(outputs: Tuple[PythonArgument, ...]) -> PythonOutArgument | None: ...
    def __init__(self, name, type, default, default_init, outputs) -> None: ...

@dataclass(frozen=True)
class PythonSignature:
    name: str
    input_args: Tuple[PythonArgument, ...]
    input_kwargs: Tuple[PythonArgument, ...]
    output_args: PythonOutArgument | None
    returns: PythonReturns
    tensor_options_args: Tuple[PythonArgument, ...]
    method: bool
    @property
    def deprecated(self) -> bool: ...
    def arguments(self, *, skip_outputs: bool = False, skip_tensor_options: bool = False) -> Tuple[PythonArgument | PythonOutArgument, ...]: ...
    def arguments_count(self) -> int: ...
    def output_idx(self) -> int: ...
    def signature_str(self, *, skip_outputs: bool = False, symint: bool = True) -> str: ...
    def signature_str_pyi(self, *, skip_outputs: bool = False) -> str: ...
    def signature_str_pyi_vararg(self, *, skip_outputs: bool = False) -> str | None: ...
    def __init__(self, name, input_args, input_kwargs, output_args, returns, tensor_options_args, method) -> None: ...

@dataclass(frozen=True)
class PythonSignatureDeprecated(PythonSignature):
    deprecated_schema: FunctionSchema
    deprecated_args_exprs: Tuple[str, ...]
    @property
    def deprecated(self) -> bool: ...
    def signature_str(self, *, skip_outputs: bool = False, symint: bool = True) -> str: ...
    def signature_str_pyi(self, *, skip_outputs: bool = False) -> str: ...
    def signature_str_pyi_vararg(self, *, skip_outputs: bool = False) -> str | None: ...
    def __init__(self, name, input_args, input_kwargs, output_args, returns, tensor_options_args, method, deprecated_schema, deprecated_args_exprs) -> None: ...

@dataclass(frozen=True)
class PythonSignatureNativeFunctionPair:
    signature: PythonSignature
    function: NativeFunction
    def __init__(self, signature, function) -> None: ...

@dataclass(frozen=True)
class PythonSignatureGroup:
    signature: PythonSignature
    base: NativeFunction
    outplace: NativeFunction | None
    @classmethod
    def from_pairs(cls, functional: PythonSignatureNativeFunctionPair, out: PythonSignatureNativeFunctionPair | None) -> PythonSignatureGroup: ...
    def __init__(self, signature, base, outplace) -> None: ...

@dataclass(frozen=True)
class DispatchLambdaArgument:
    name: str
    type_str: str
    is_out_arg: bool
    def __init__(self, name, type_str, is_out_arg) -> None: ...

@dataclass(frozen=True)
class PythonArgParserOutputExpr:
    name: str
    expr: str
    index: int
    argument: PythonArgument
    @property
    def is_none_expr(self) -> str: ...
    def __init__(self, name, expr, index, argument) -> None: ...

@dataclass(frozen=True)
class DispatchLambdaArgumentExprs:
    exprs: Sequence[str]
    inits: Sequence[str]
    def __init__(self, exprs, inits) -> None: ...

def has_tensor_options(f: NativeFunction) -> bool: ...
def argument_type_str(t: Type, *, simple_type: bool = False, symint: bool = True) -> str: ...
def argument_type_size(t: Type) -> int | None: ...
def argument(a: Argument) -> PythonArgument: ...
def signature(f: NativeFunction, *, method: bool = False, pyi: bool = False) -> PythonSignature: ...
def signature_from_schema(func: FunctionSchema, *, category_override: str | None, method: bool = False, pyi: bool = False) -> PythonSignature: ...
def namedtuple_fieldnames(returns: Tuple[Return, ...]) -> List[str]: ...
def argument_type_str_pyi(t: Type) -> str: ...
def return_type_str_pyi(t: Type) -> str: ...
def returns_named_tuple_pyi(signature: PythonSignature) -> Tuple[str, str] | None: ...
def returns_str_pyi(signature: PythonSignature) -> str: ...
def dispatch_lambda_args(ps: PythonSignature, f: NativeFunction, symint: bool = True) -> Tuple[DispatchLambdaArgument, ...]: ...

SUPPORTED_RETURN_TYPES: Incomplete

def dispatch_lambda_return_str(f: NativeFunction) -> str: ...
def cpp_dispatch_target(f: NativeFunction) -> str: ...
def cpp_dispatch_exprs(f: NativeFunction, *, python_signature: PythonSignature | None = None) -> Tuple[str, ...]: ...
def arg_parser_unpack_method(t: Type, default: str | None, default_init: str | None, *, symint: bool = True) -> str: ...
def arg_parser_output_expr(arg_index: int, a: PythonArgument, *, symint: bool = True) -> PythonArgParserOutputExpr: ...
def arg_parser_output_exprs(ps: PythonSignature, f: NativeFunction, *, symint: bool = True) -> Dict[str, PythonArgParserOutputExpr]: ...

TENSOR_OPTIONS_FIELDS: Incomplete

def dispatch_lambda_exprs(ps: PythonSignature, f: NativeFunction, *, symint: bool = True) -> DispatchLambdaArgumentExprs: ...
