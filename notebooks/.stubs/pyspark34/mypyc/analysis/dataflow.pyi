import abc
from _typeshed import Incomplete
from abc import abstractmethod
from mypyc.ir.func_ir import all_values as all_values
from mypyc.ir.ops import Assign as Assign, AssignMulti as AssignMulti, BasicBlock as BasicBlock, Box as Box, Branch as Branch, Call as Call, CallC as CallC, Cast as Cast, ComparisonOp as ComparisonOp, ControlOp as ControlOp, Extend as Extend, Float as Float, FloatComparisonOp as FloatComparisonOp, FloatNeg as FloatNeg, FloatOp as FloatOp, GetAttr as GetAttr, GetElementPtr as GetElementPtr, Goto as Goto, InitStatic as InitStatic, IntOp as IntOp, Integer as Integer, KeepAlive as KeepAlive, LoadAddress as LoadAddress, LoadErrorValue as LoadErrorValue, LoadGlobal as LoadGlobal, LoadLiteral as LoadLiteral, LoadMem as LoadMem, LoadStatic as LoadStatic, MethodCall as MethodCall, Op as Op, OpVisitor as OpVisitor, RaiseStandardError as RaiseStandardError, RegisterOp as RegisterOp, Return as Return, SetAttr as SetAttr, SetMem as SetMem, Truncate as Truncate, TupleGet as TupleGet, TupleSet as TupleSet, Unborrow as Unborrow, Unbox as Unbox, Unreachable as Unreachable, Value as Value
from typing import Dict, Generic, Iterable, Set, Tuple, TypeVar

class CFG:
    """Control-flow graph.

    Node 0 is always assumed to be the entry point. There must be a
    non-empty set of exits.
    """
    succ: Incomplete
    pred: Incomplete
    exits: Incomplete
    def __init__(self, succ: dict[BasicBlock, list[BasicBlock]], pred: dict[BasicBlock, list[BasicBlock]], exits: set[BasicBlock]) -> None: ...

def get_cfg(blocks: list[BasicBlock]) -> CFG:
    """Calculate basic block control-flow graph.

    The result is a dictionary like this:

         basic block index -> (successors blocks, predecesssor blocks)
    """
def get_real_target(label: BasicBlock) -> BasicBlock: ...
def cleanup_cfg(blocks: list[BasicBlock]) -> None:
    """Cleanup the control flow graph.

    This eliminates obviously dead basic blocks and eliminates blocks that contain
    nothing but a single jump.

    There is a lot more that could be done.
    """
T = TypeVar('T')
AnalysisDict = Dict[Tuple[BasicBlock, int], Set[T]]

class AnalysisResult(Generic[T]):
    before: Incomplete
    after: Incomplete
    def __init__(self, before: AnalysisDict[T], after: AnalysisDict[T]) -> None: ...
GenAndKill = Tuple[Set[T], Set[T]]

class BaseAnalysisVisitor(OpVisitor[GenAndKill[T]], metaclass=abc.ABCMeta):
    def visit_goto(self, op: Goto) -> GenAndKill[T]: ...
    @abstractmethod
    def visit_register_op(self, op: RegisterOp) -> GenAndKill[T]: ...
    @abstractmethod
    def visit_assign(self, op: Assign) -> GenAndKill[T]: ...
    @abstractmethod
    def visit_assign_multi(self, op: AssignMulti) -> GenAndKill[T]: ...
    @abstractmethod
    def visit_set_mem(self, op: SetMem) -> GenAndKill[T]: ...
    def visit_call(self, op: Call) -> GenAndKill[T]: ...
    def visit_method_call(self, op: MethodCall) -> GenAndKill[T]: ...
    def visit_load_error_value(self, op: LoadErrorValue) -> GenAndKill[T]: ...
    def visit_load_literal(self, op: LoadLiteral) -> GenAndKill[T]: ...
    def visit_get_attr(self, op: GetAttr) -> GenAndKill[T]: ...
    def visit_set_attr(self, op: SetAttr) -> GenAndKill[T]: ...
    def visit_load_static(self, op: LoadStatic) -> GenAndKill[T]: ...
    def visit_init_static(self, op: InitStatic) -> GenAndKill[T]: ...
    def visit_tuple_get(self, op: TupleGet) -> GenAndKill[T]: ...
    def visit_tuple_set(self, op: TupleSet) -> GenAndKill[T]: ...
    def visit_box(self, op: Box) -> GenAndKill[T]: ...
    def visit_unbox(self, op: Unbox) -> GenAndKill[T]: ...
    def visit_cast(self, op: Cast) -> GenAndKill[T]: ...
    def visit_raise_standard_error(self, op: RaiseStandardError) -> GenAndKill[T]: ...
    def visit_call_c(self, op: CallC) -> GenAndKill[T]: ...
    def visit_truncate(self, op: Truncate) -> GenAndKill[T]: ...
    def visit_extend(self, op: Extend) -> GenAndKill[T]: ...
    def visit_load_global(self, op: LoadGlobal) -> GenAndKill[T]: ...
    def visit_int_op(self, op: IntOp) -> GenAndKill[T]: ...
    def visit_float_op(self, op: FloatOp) -> GenAndKill[T]: ...
    def visit_float_neg(self, op: FloatNeg) -> GenAndKill[T]: ...
    def visit_comparison_op(self, op: ComparisonOp) -> GenAndKill[T]: ...
    def visit_float_comparison_op(self, op: FloatComparisonOp) -> GenAndKill[T]: ...
    def visit_load_mem(self, op: LoadMem) -> GenAndKill[T]: ...
    def visit_get_element_ptr(self, op: GetElementPtr) -> GenAndKill[T]: ...
    def visit_load_address(self, op: LoadAddress) -> GenAndKill[T]: ...
    def visit_keep_alive(self, op: KeepAlive) -> GenAndKill[T]: ...
    def visit_unborrow(self, op: Unborrow) -> GenAndKill[T]: ...

class DefinedVisitor(BaseAnalysisVisitor[Value]):
    """Visitor for finding defined registers.

    Note that this only deals with registers and not temporaries, on
    the assumption that we never access temporaries when they might be
    undefined.

    If strict_errors is True, then we regard any use of LoadErrorValue
    as making a register undefined. Otherwise we only do if
    `undefines` is set on the error value.

    This lets us only consider the things we care about during
    uninitialized variable checking while capturing all possibly
    undefined things for refcounting.
    """
    strict_errors: Incomplete
    def __init__(self, strict_errors: bool = False) -> None: ...
    def visit_branch(self, op: Branch) -> GenAndKill[Value]: ...
    def visit_return(self, op: Return) -> GenAndKill[Value]: ...
    def visit_unreachable(self, op: Unreachable) -> GenAndKill[Value]: ...
    def visit_register_op(self, op: RegisterOp) -> GenAndKill[Value]: ...
    def visit_assign(self, op: Assign) -> GenAndKill[Value]: ...
    def visit_assign_multi(self, op: AssignMulti) -> GenAndKill[Value]: ...
    def visit_set_mem(self, op: SetMem) -> GenAndKill[Value]: ...

def analyze_maybe_defined_regs(blocks: list[BasicBlock], cfg: CFG, initial_defined: set[Value]) -> AnalysisResult[Value]:
    """Calculate potentially defined registers at each CFG location.

    A register is defined if it has a value along some path from the initial location.
    """
def analyze_must_defined_regs(blocks: list[BasicBlock], cfg: CFG, initial_defined: set[Value], regs: Iterable[Value], strict_errors: bool = False) -> AnalysisResult[Value]:
    """Calculate always defined registers at each CFG location.

    This analysis can work before exception insertion, since it is a
    sound assumption that registers defined in a block might not be
    initialized in its error handler.

    A register is defined if it has a value along all paths from the
    initial location.
    """

class BorrowedArgumentsVisitor(BaseAnalysisVisitor[Value]):
    args: Incomplete
    def __init__(self, args: set[Value]) -> None: ...
    def visit_branch(self, op: Branch) -> GenAndKill[Value]: ...
    def visit_return(self, op: Return) -> GenAndKill[Value]: ...
    def visit_unreachable(self, op: Unreachable) -> GenAndKill[Value]: ...
    def visit_register_op(self, op: RegisterOp) -> GenAndKill[Value]: ...
    def visit_assign(self, op: Assign) -> GenAndKill[Value]: ...
    def visit_assign_multi(self, op: AssignMulti) -> GenAndKill[Value]: ...
    def visit_set_mem(self, op: SetMem) -> GenAndKill[Value]: ...

def analyze_borrowed_arguments(blocks: list[BasicBlock], cfg: CFG, borrowed: set[Value]) -> AnalysisResult[Value]:
    """Calculate arguments that can use references borrowed from the caller.

    When assigning to an argument, it no longer is borrowed.
    """

class UndefinedVisitor(BaseAnalysisVisitor[Value]):
    def visit_branch(self, op: Branch) -> GenAndKill[Value]: ...
    def visit_return(self, op: Return) -> GenAndKill[Value]: ...
    def visit_unreachable(self, op: Unreachable) -> GenAndKill[Value]: ...
    def visit_register_op(self, op: RegisterOp) -> GenAndKill[Value]: ...
    def visit_assign(self, op: Assign) -> GenAndKill[Value]: ...
    def visit_assign_multi(self, op: AssignMulti) -> GenAndKill[Value]: ...
    def visit_set_mem(self, op: SetMem) -> GenAndKill[Value]: ...

def analyze_undefined_regs(blocks: list[BasicBlock], cfg: CFG, initial_defined: set[Value]) -> AnalysisResult[Value]:
    """Calculate potentially undefined registers at each CFG location.

    A register is undefined if there is some path from initial block
    where it has an undefined value.

    Function arguments are assumed to be always defined.
    """
def non_trivial_sources(op: Op) -> set[Value]: ...

class LivenessVisitor(BaseAnalysisVisitor[Value]):
    def visit_branch(self, op: Branch) -> GenAndKill[Value]: ...
    def visit_return(self, op: Return) -> GenAndKill[Value]: ...
    def visit_unreachable(self, op: Unreachable) -> GenAndKill[Value]: ...
    def visit_register_op(self, op: RegisterOp) -> GenAndKill[Value]: ...
    def visit_assign(self, op: Assign) -> GenAndKill[Value]: ...
    def visit_assign_multi(self, op: AssignMulti) -> GenAndKill[Value]: ...
    def visit_set_mem(self, op: SetMem) -> GenAndKill[Value]: ...

def analyze_live_regs(blocks: list[BasicBlock], cfg: CFG) -> AnalysisResult[Value]:
    """Calculate live registers at each CFG location.

    A register is live at a location if it can be read along some CFG path starting
    from the location.
    """

MUST_ANALYSIS: int
MAYBE_ANALYSIS: int

def run_analysis(blocks: list[BasicBlock], cfg: CFG, gen_and_kill: OpVisitor[GenAndKill[T]], initial: set[T], kind: int, backward: bool, universe: set[T] | None = None) -> AnalysisResult[T]:
    """Run a general set-based data flow analysis.

    Args:
        blocks: All basic blocks
        cfg: Control-flow graph for the code
        gen_and_kill: Implementation of gen and kill functions for each op
        initial: Value of analysis for the entry points (for a forward analysis) or the
            exit points (for a backward analysis)
        kind: MUST_ANALYSIS or MAYBE_ANALYSIS
        backward: If False, the analysis is a forward analysis; it's backward otherwise
        universe: For a must analysis, the set of all possible values. This is the starting
            value for the work list algorithm, which will narrow this down until reaching a
            fixed point. For a maybe analysis the iteration always starts from an empty set
            and this argument is ignored.

    Return analysis results: (before, after)
    """
