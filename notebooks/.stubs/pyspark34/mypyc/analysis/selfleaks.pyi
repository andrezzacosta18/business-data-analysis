from _typeshed import Incomplete
from mypyc.analysis.dataflow import AnalysisResult as AnalysisResult, CFG as CFG, MAYBE_ANALYSIS as MAYBE_ANALYSIS, run_analysis as run_analysis
from mypyc.ir.ops import Assign as Assign, AssignMulti as AssignMulti, BasicBlock as BasicBlock, Box as Box, Branch as Branch, Call as Call, CallC as CallC, Cast as Cast, ComparisonOp as ComparisonOp, Extend as Extend, FloatComparisonOp as FloatComparisonOp, FloatNeg as FloatNeg, FloatOp as FloatOp, GetAttr as GetAttr, GetElementPtr as GetElementPtr, Goto as Goto, InitStatic as InitStatic, IntOp as IntOp, KeepAlive as KeepAlive, LoadAddress as LoadAddress, LoadErrorValue as LoadErrorValue, LoadGlobal as LoadGlobal, LoadLiteral as LoadLiteral, LoadMem as LoadMem, LoadStatic as LoadStatic, MethodCall as MethodCall, OpVisitor as OpVisitor, RaiseStandardError as RaiseStandardError, Register as Register, RegisterOp as RegisterOp, Return as Return, SetAttr as SetAttr, SetMem as SetMem, Truncate as Truncate, TupleGet as TupleGet, TupleSet as TupleSet, Unborrow as Unborrow, Unbox as Unbox, Unreachable as Unreachable
from mypyc.ir.rtypes import RInstance as RInstance
from typing import Set, Tuple

GenAndKill = Tuple[Set[None], Set[None]]
CLEAN: GenAndKill
DIRTY: GenAndKill

class SelfLeakedVisitor(OpVisitor[GenAndKill]):
    """Analyze whether 'self' may be seen by arbitrary code in '__init__'.

    More formally, the set is not empty if along some path from IR entry point
    arbitrary code could have been executed that has access to 'self'.

    (We don't consider access via 'gc.get_objects()'.)
    """
    self_reg: Incomplete
    def __init__(self, self_reg: Register) -> None: ...
    def visit_goto(self, op: Goto) -> GenAndKill: ...
    def visit_branch(self, op: Branch) -> GenAndKill: ...
    def visit_return(self, op: Return) -> GenAndKill: ...
    def visit_unreachable(self, op: Unreachable) -> GenAndKill: ...
    def visit_assign(self, op: Assign) -> GenAndKill: ...
    def visit_assign_multi(self, op: AssignMulti) -> GenAndKill: ...
    def visit_set_mem(self, op: SetMem) -> GenAndKill: ...
    def visit_call(self, op: Call) -> GenAndKill: ...
    def visit_method_call(self, op: MethodCall) -> GenAndKill: ...
    def visit_load_error_value(self, op: LoadErrorValue) -> GenAndKill: ...
    def visit_load_literal(self, op: LoadLiteral) -> GenAndKill: ...
    def visit_get_attr(self, op: GetAttr) -> GenAndKill: ...
    def visit_set_attr(self, op: SetAttr) -> GenAndKill: ...
    def visit_load_static(self, op: LoadStatic) -> GenAndKill: ...
    def visit_init_static(self, op: InitStatic) -> GenAndKill: ...
    def visit_tuple_get(self, op: TupleGet) -> GenAndKill: ...
    def visit_tuple_set(self, op: TupleSet) -> GenAndKill: ...
    def visit_box(self, op: Box) -> GenAndKill: ...
    def visit_unbox(self, op: Unbox) -> GenAndKill: ...
    def visit_cast(self, op: Cast) -> GenAndKill: ...
    def visit_raise_standard_error(self, op: RaiseStandardError) -> GenAndKill: ...
    def visit_call_c(self, op: CallC) -> GenAndKill: ...
    def visit_truncate(self, op: Truncate) -> GenAndKill: ...
    def visit_extend(self, op: Extend) -> GenAndKill: ...
    def visit_load_global(self, op: LoadGlobal) -> GenAndKill: ...
    def visit_int_op(self, op: IntOp) -> GenAndKill: ...
    def visit_comparison_op(self, op: ComparisonOp) -> GenAndKill: ...
    def visit_float_op(self, op: FloatOp) -> GenAndKill: ...
    def visit_float_neg(self, op: FloatNeg) -> GenAndKill: ...
    def visit_float_comparison_op(self, op: FloatComparisonOp) -> GenAndKill: ...
    def visit_load_mem(self, op: LoadMem) -> GenAndKill: ...
    def visit_get_element_ptr(self, op: GetElementPtr) -> GenAndKill: ...
    def visit_load_address(self, op: LoadAddress) -> GenAndKill: ...
    def visit_keep_alive(self, op: KeepAlive) -> GenAndKill: ...
    def visit_unborrow(self, op: Unborrow) -> GenAndKill: ...
    def check_register_op(self, op: RegisterOp) -> GenAndKill: ...

def analyze_self_leaks(blocks: list[BasicBlock], self_reg: Register, cfg: CFG) -> AnalysisResult[None]: ...
