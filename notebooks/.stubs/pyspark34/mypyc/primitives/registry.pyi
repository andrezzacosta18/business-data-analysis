from mypyc.ir.ops import StealsDescription as StealsDescription
from mypyc.ir.rtypes import RType as RType
from typing import Final, NamedTuple

ERR_NEG_INT: Final[int]

class CFunctionDescription(NamedTuple):
    name: str
    arg_types: list[RType]
    return_type: RType
    var_arg_type: RType | None
    truncated_type: RType | None
    c_function_name: str
    error_kind: int
    steals: StealsDescription
    is_borrowed: bool
    ordering: list[int] | None
    extra_int_constants: list[tuple[int, RType]]
    priority: int

class LoadAddressDescription(NamedTuple):
    name: str
    type: RType
    src: str

method_call_ops: dict[str, list[CFunctionDescription]]
function_ops: dict[str, list[CFunctionDescription]]
binary_ops: dict[str, list[CFunctionDescription]]
unary_ops: dict[str, list[CFunctionDescription]]
builtin_names: dict[str, tuple[RType, str]]

def method_op(name: str, arg_types: list[RType], return_type: RType, c_function_name: str, error_kind: int, var_arg_type: RType | None = None, truncated_type: RType | None = None, ordering: list[int] | None = None, extra_int_constants: list[tuple[int, RType]] | None = None, steals: StealsDescription = False, is_borrowed: bool = False, priority: int = 1) -> CFunctionDescription:
    """Define a c function call op that replaces a method call.

    This will be automatically generated by matching against the AST.

    Args:
        name: short name of the method (for example, 'append')
        arg_types: argument types; the receiver is always the first argument
        return_type: type of the return value. Use void_rtype to represent void.
        c_function_name: name of the C function to call
        error_kind: how errors are represented in the result (one of ERR_*)
        var_arg_type: type of all variable arguments
        truncated_type: type to truncated to(See Truncate for info)
                        if it's defined both return_type and it should be non-referenced
                        integer types or bool type
        ordering: optional ordering of the arguments, if defined,
                  reorders the arguments accordingly.
                  should never be used together with var_arg_type.
                  all the other arguments(such as arg_types) are in the order
                  accepted by the python syntax(before reordering)
        extra_int_constants: optional extra integer constants as the last arguments to a C call
        steals: description of arguments that this steals (ref count wise)
        is_borrowed: if True, returned value is borrowed (no need to decrease refcount)
        priority: if multiple ops match, the one with the highest priority is picked
    """
def function_op(name: str, arg_types: list[RType], return_type: RType, c_function_name: str, error_kind: int, var_arg_type: RType | None = None, truncated_type: RType | None = None, ordering: list[int] | None = None, extra_int_constants: list[tuple[int, RType]] | None = None, steals: StealsDescription = False, is_borrowed: bool = False, priority: int = 1) -> CFunctionDescription:
    """Define a c function call op that replaces a function call.

    This will be automatically generated by matching against the AST.

    Most arguments are similar to method_op().

    Args:
        name: full name of the function
        arg_types: positional argument types for which this applies
    """
def binary_op(name: str, arg_types: list[RType], return_type: RType, c_function_name: str, error_kind: int, var_arg_type: RType | None = None, truncated_type: RType | None = None, ordering: list[int] | None = None, extra_int_constants: list[tuple[int, RType]] | None = None, steals: StealsDescription = False, is_borrowed: bool = False, priority: int = 1) -> CFunctionDescription:
    """Define a c function call op for a binary operation.

    This will be automatically generated by matching against the AST.

    Most arguments are similar to method_op(), but exactly two argument types
    are expected.
    """
def custom_op(arg_types: list[RType], return_type: RType, c_function_name: str, error_kind: int, var_arg_type: RType | None = None, truncated_type: RType | None = None, ordering: list[int] | None = None, extra_int_constants: list[tuple[int, RType]] | None = None, steals: StealsDescription = False, is_borrowed: bool = False) -> CFunctionDescription:
    """Create a one-off CallC op that can't be automatically generated from the AST.

    Most arguments are similar to method_op().
    """
def unary_op(name: str, arg_type: RType, return_type: RType, c_function_name: str, error_kind: int, truncated_type: RType | None = None, ordering: list[int] | None = None, extra_int_constants: list[tuple[int, RType]] | None = None, steals: StealsDescription = False, is_borrowed: bool = False, priority: int = 1) -> CFunctionDescription:
    """Define a c function call op for an unary operation.

    This will be automatically generated by matching against the AST.

    Most arguments are similar to method_op(), but exactly one argument type
    is expected.
    """
def load_address_op(name: str, type: RType, src: str) -> LoadAddressDescription: ...
