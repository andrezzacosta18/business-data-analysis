from .match import MatchVisitor as MatchVisitor
from mypy.nodes import AssertStmt as AssertStmt, AssignmentStmt as AssignmentStmt, AwaitExpr as AwaitExpr, Block as Block, BreakStmt as BreakStmt, ContinueStmt as ContinueStmt, DelStmt as DelStmt, Expression as Expression, ExpressionStmt as ExpressionStmt, ForStmt as ForStmt, IfStmt as IfStmt, Import as Import, ImportAll as ImportAll, ImportFrom as ImportFrom, Lvalue as Lvalue, MatchStmt as MatchStmt, OperatorAssignmentStmt as OperatorAssignmentStmt, RaiseStmt as RaiseStmt, ReturnStmt as ReturnStmt, TryStmt as TryStmt, WhileStmt as WhileStmt, WithStmt as WithStmt, YieldExpr as YieldExpr, YieldFromExpr as YieldFromExpr
from mypyc.ir.ops import Assign as Assign, BasicBlock as BasicBlock, Branch as Branch, InitStatic as InitStatic, Integer as Integer, LoadAddress as LoadAddress, LoadErrorValue as LoadErrorValue, LoadLiteral as LoadLiteral, LoadStatic as LoadStatic, MethodCall as MethodCall, NAMESPACE_MODULE as NAMESPACE_MODULE, NO_TRACEBACK_LINE_NO as NO_TRACEBACK_LINE_NO, RaiseStandardError as RaiseStandardError, Register as Register, Return as Return, TupleGet as TupleGet, Unborrow as Unborrow, Unreachable as Unreachable, Value as Value
from mypyc.ir.rtypes import RInstance as RInstance, RTuple as RTuple, c_pyssize_t_rprimitive as c_pyssize_t_rprimitive, exc_rtuple as exc_rtuple, is_tagged as is_tagged, none_rprimitive as none_rprimitive, object_pointer_rprimitive as object_pointer_rprimitive, object_rprimitive as object_rprimitive
from mypyc.irbuild.ast_helpers import is_borrow_friendly_expr as is_borrow_friendly_expr, process_conditional as process_conditional
from mypyc.irbuild.builder import IRBuilder as IRBuilder, int_borrow_friendly_op as int_borrow_friendly_op
from mypyc.irbuild.for_helpers import for_loop_helper as for_loop_helper
from mypyc.irbuild.generator import add_raise_exception_blocks_to_generator_class as add_raise_exception_blocks_to_generator_class
from mypyc.irbuild.nonlocalcontrol import ExceptNonlocalControl as ExceptNonlocalControl, FinallyNonlocalControl as FinallyNonlocalControl, TryFinallyNonlocalControl as TryFinallyNonlocalControl
from mypyc.irbuild.targets import AssignmentTarget as AssignmentTarget, AssignmentTargetAttr as AssignmentTargetAttr, AssignmentTargetIndex as AssignmentTargetIndex, AssignmentTargetRegister as AssignmentTargetRegister, AssignmentTargetTuple as AssignmentTargetTuple
from mypyc.primitives.exc_ops import error_catch_op as error_catch_op, exc_matches_op as exc_matches_op, get_exc_info_op as get_exc_info_op, get_exc_value_op as get_exc_value_op, keep_propagating_op as keep_propagating_op, raise_exception_op as raise_exception_op, reraise_exception_op as reraise_exception_op, restore_exc_info_op as restore_exc_info_op
from mypyc.primitives.generic_ops import iter_op as iter_op, next_raw_op as next_raw_op, py_delattr_op as py_delattr_op
from mypyc.primitives.misc_ops import check_stop_op as check_stop_op, coro_op as coro_op, import_from_many_op as import_from_many_op, import_many_op as import_many_op, send_op as send_op, type_op as type_op, yield_from_except_op as yield_from_except_op
from typing import Callable, Sequence

GenFunc = Callable[[], None]
ValueGenFunc = Callable[[], Value]

def transform_block(builder: IRBuilder, block: Block) -> None: ...
def transform_expression_stmt(builder: IRBuilder, stmt: ExpressionStmt) -> None: ...
def transform_return_stmt(builder: IRBuilder, stmt: ReturnStmt) -> None: ...
def transform_assignment_stmt(builder: IRBuilder, stmt: AssignmentStmt) -> None: ...
def is_simple_lvalue(expr: Expression) -> bool: ...
def transform_operator_assignment_stmt(builder: IRBuilder, stmt: OperatorAssignmentStmt) -> None:
    """Operator assignment statement such as x += 1"""
def import_globals_id_and_name(module_id: str, as_name: str | None) -> tuple[str, str]:
    """Compute names for updating the globals dict with the appropriate module.

    * For 'import foo.bar as baz' we add 'foo.bar' with the name 'baz'
    * For 'import foo.bar' we add 'foo' with the name 'foo'

    Typically we then ignore these entries and access things directly
    via the module static, but we will use the globals version for
    modules that mypy couldn't find, since it doesn't analyze module
    references from those properly."""
def transform_import(builder: IRBuilder, node: Import) -> None: ...
def transform_import_from(builder: IRBuilder, node: ImportFrom) -> None: ...
def transform_import_all(builder: IRBuilder, node: ImportAll) -> None: ...
def transform_if_stmt(builder: IRBuilder, stmt: IfStmt) -> None: ...
def transform_while_stmt(builder: IRBuilder, s: WhileStmt) -> None: ...
def transform_for_stmt(builder: IRBuilder, s: ForStmt) -> None: ...
def transform_break_stmt(builder: IRBuilder, node: BreakStmt) -> None: ...
def transform_continue_stmt(builder: IRBuilder, node: ContinueStmt) -> None: ...
def transform_raise_stmt(builder: IRBuilder, s: RaiseStmt) -> None: ...
def transform_try_except(builder: IRBuilder, body: GenFunc, handlers: Sequence[tuple[tuple[ValueGenFunc, int] | None, Expression | None, GenFunc]], else_body: GenFunc | None, line: int) -> None:
    """Generalized try/except/else handling that takes functions to gen the bodies.

    The point of this is to also be able to support with."""
def transform_try_except_stmt(builder: IRBuilder, t: TryStmt) -> None: ...
def try_finally_try(builder: IRBuilder, err_handler: BasicBlock, return_entry: BasicBlock, main_entry: BasicBlock, try_body: GenFunc) -> Register | AssignmentTarget | None: ...
def try_finally_entry_blocks(builder: IRBuilder, err_handler: BasicBlock, return_entry: BasicBlock, main_entry: BasicBlock, finally_block: BasicBlock, ret_reg: Register | AssignmentTarget | None) -> Value: ...
def try_finally_body(builder: IRBuilder, finally_block: BasicBlock, finally_body: GenFunc, old_exc: Value) -> tuple[BasicBlock, FinallyNonlocalControl]: ...
def try_finally_resolve_control(builder: IRBuilder, cleanup_block: BasicBlock, finally_control: FinallyNonlocalControl, old_exc: Value, ret_reg: Register | AssignmentTarget | None) -> BasicBlock:
    """Resolve the control flow out of a finally block.

    This means returning if there was a return, propagating
    exceptions, break/continue (soon), or just continuing on.
    """
def transform_try_finally_stmt(builder: IRBuilder, try_body: GenFunc, finally_body: GenFunc) -> None:
    """Generalized try/finally handling that takes functions to gen the bodies.

    The point of this is to also be able to support with."""
def transform_try_stmt(builder: IRBuilder, t: TryStmt) -> None: ...
def get_sys_exc_info(builder: IRBuilder) -> list[Value]: ...
def transform_with(builder: IRBuilder, expr: Expression, target: Lvalue | None, body: GenFunc, is_async: bool, line: int) -> None: ...
def transform_with_stmt(builder: IRBuilder, o: WithStmt) -> None: ...
def transform_assert_stmt(builder: IRBuilder, a: AssertStmt) -> None: ...
def transform_del_stmt(builder: IRBuilder, o: DelStmt) -> None: ...
def transform_del_item(builder: IRBuilder, target: AssignmentTarget, line: int) -> None: ...
def emit_yield(builder: IRBuilder, val: Value, line: int) -> Value: ...
def emit_yield_from_or_await(builder: IRBuilder, val: Value, line: int, *, is_await: bool) -> Value: ...
def emit_await(builder: IRBuilder, val: Value, line: int) -> Value: ...
def transform_yield_expr(builder: IRBuilder, expr: YieldExpr) -> Value: ...
def transform_yield_from_expr(builder: IRBuilder, o: YieldFromExpr) -> Value: ...
def transform_await_expr(builder: IRBuilder, o: AwaitExpr) -> Value: ...
def transform_match_stmt(builder: IRBuilder, m: MatchStmt) -> None: ...
