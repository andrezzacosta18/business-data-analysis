import typing
import typing as t
import typing_extensions as te
from . import nodes as nodes
from .environment import Environment as Environment
from .exceptions import TemplateAssertionError as TemplateAssertionError, TemplateSyntaxError as TemplateSyntaxError
from .lexer import describe_token as describe_token, describe_token_expr as describe_token_expr
from _typeshed import Incomplete

class Parser:
    """This is the central parsing class Jinja uses.  It's passed to
    extensions and can be used to parse expressions or statements.
    """
    environment: Incomplete
    stream: Incomplete
    name: Incomplete
    filename: Incomplete
    closed: bool
    extensions: Incomplete
    def __init__(self, environment: Environment, source: str, name: str | None = None, filename: str | None = None, state: str | None = None) -> None: ...
    def fail(self, msg: str, lineno: int | None = None, exc: t.Type[TemplateSyntaxError] = ...) -> te.NoReturn:
        """Convenience method that raises `exc` with the message, passed
        line number or last line number as well as the current name and
        filename.
        """
    def fail_unknown_tag(self, name: str, lineno: int | None = None) -> te.NoReturn:
        """Called if the parser encounters an unknown tag.  Tries to fail
        with a human readable error message that could help to identify
        the problem.
        """
    def fail_eof(self, end_tokens: t.Tuple[str, ...] | None = None, lineno: int | None = None) -> te.NoReturn:
        """Like fail_unknown_tag but for end of template situations."""
    def is_tuple_end(self, extra_end_rules: t.Tuple[str, ...] | None = None) -> bool:
        """Are we at the end of a tuple?"""
    def free_identifier(self, lineno: int | None = None) -> nodes.InternalName:
        """Return a new free identifier as :class:`~jinja2.nodes.InternalName`."""
    def parse_statement(self) -> nodes.Node | t.List[nodes.Node]:
        """Parse a single statement."""
    def parse_statements(self, end_tokens: t.Tuple[str, ...], drop_needle: bool = False) -> t.List[nodes.Node]:
        """Parse multiple statements into a list until one of the end tokens
        is reached.  This is used to parse the body of statements as it also
        parses template data if appropriate.  The parser checks first if the
        current token is a colon and skips it if there is one.  Then it checks
        for the block end and parses until if one of the `end_tokens` is
        reached.  Per default the active token in the stream at the end of
        the call is the matched end token.  If this is not wanted `drop_needle`
        can be set to `True` and the end token is removed.
        """
    def parse_set(self) -> nodes.Assign | nodes.AssignBlock:
        """Parse an assign statement."""
    def parse_for(self) -> nodes.For:
        """Parse a for loop."""
    def parse_if(self) -> nodes.If:
        """Parse an if construct."""
    def parse_with(self) -> nodes.With: ...
    def parse_autoescape(self) -> nodes.Scope: ...
    def parse_block(self) -> nodes.Block: ...
    def parse_extends(self) -> nodes.Extends: ...
    def parse_import_context(self, node: _ImportInclude, default: bool) -> _ImportInclude: ...
    def parse_include(self) -> nodes.Include: ...
    def parse_import(self) -> nodes.Import: ...
    def parse_from(self) -> nodes.FromImport: ...
    def parse_signature(self, node: _MacroCall) -> None: ...
    def parse_call_block(self) -> nodes.CallBlock: ...
    def parse_filter_block(self) -> nodes.FilterBlock: ...
    def parse_macro(self) -> nodes.Macro: ...
    def parse_print(self) -> nodes.Output: ...
    @typing.overload
    def parse_assign_target(self, with_tuple: bool = ..., name_only: te.Literal[True] = ...) -> nodes.Name: ...
    @typing.overload
    def parse_assign_target(self, with_tuple: bool = True, name_only: bool = False, extra_end_rules: t.Tuple[str, ...] | None = None, with_namespace: bool = False) -> nodes.NSRef | nodes.Name | nodes.Tuple: ...
    def parse_expression(self, with_condexpr: bool = True) -> nodes.Expr:
        """Parse an expression.  Per default all expressions are parsed, if
        the optional `with_condexpr` parameter is set to `False` conditional
        expressions are not parsed.
        """
    def parse_condexpr(self) -> nodes.Expr: ...
    def parse_or(self) -> nodes.Expr: ...
    def parse_and(self) -> nodes.Expr: ...
    def parse_not(self) -> nodes.Expr: ...
    def parse_compare(self) -> nodes.Expr: ...
    def parse_math1(self) -> nodes.Expr: ...
    def parse_concat(self) -> nodes.Expr: ...
    def parse_math2(self) -> nodes.Expr: ...
    def parse_pow(self) -> nodes.Expr: ...
    def parse_unary(self, with_filter: bool = True) -> nodes.Expr: ...
    def parse_primary(self) -> nodes.Expr: ...
    def parse_tuple(self, simplified: bool = False, with_condexpr: bool = True, extra_end_rules: t.Tuple[str, ...] | None = None, explicit_parentheses: bool = False) -> nodes.Tuple | nodes.Expr:
        """Works like `parse_expression` but if multiple expressions are
        delimited by a comma a :class:`~jinja2.nodes.Tuple` node is created.
        This method could also return a regular expression instead of a tuple
        if no commas where found.

        The default parsing mode is a full tuple.  If `simplified` is `True`
        only names and literals are parsed.  The `no_condexpr` parameter is
        forwarded to :meth:`parse_expression`.

        Because tuples do not require delimiters and may end in a bogus comma
        an extra hint is needed that marks the end of a tuple.  For example
        for loops support tuples between `for` and `in`.  In that case the
        `extra_end_rules` is set to ``['name:in']``.

        `explicit_parentheses` is true if the parsing was triggered by an
        expression in parentheses.  This is used to figure out if an empty
        tuple is a valid expression or not.
        """
    def parse_list(self) -> nodes.List: ...
    def parse_dict(self) -> nodes.Dict: ...
    def parse_postfix(self, node: nodes.Expr) -> nodes.Expr: ...
    def parse_filter_expr(self, node: nodes.Expr) -> nodes.Expr: ...
    def parse_subscript(self, node: nodes.Expr) -> nodes.Getattr | nodes.Getitem: ...
    def parse_subscribed(self) -> nodes.Expr: ...
    def parse_call_args(self) -> t.Tuple: ...
    def parse_call(self, node: nodes.Expr) -> nodes.Call: ...
    def parse_filter(self, node: nodes.Expr | None, start_inline: bool = False) -> nodes.Expr | None: ...
    def parse_test(self, node: nodes.Expr) -> nodes.Expr: ...
    def subparse(self, end_tokens: t.Tuple[str, ...] | None = None) -> t.List[nodes.Node]: ...
    def parse(self) -> nodes.Template:
        """Parse the whole template into a `Template` node."""
