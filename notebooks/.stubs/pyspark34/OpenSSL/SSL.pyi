from _typeshed import Incomplete

__all__ = ['OPENSSL_VERSION_NUMBER', 'SSLEAY_VERSION', 'SSLEAY_CFLAGS', 'SSLEAY_PLATFORM', 'SSLEAY_DIR', 'SSLEAY_BUILT_ON', 'OPENSSL_VERSION', 'OPENSSL_CFLAGS', 'OPENSSL_PLATFORM', 'OPENSSL_DIR', 'OPENSSL_BUILT_ON', 'SENT_SHUTDOWN', 'RECEIVED_SHUTDOWN', 'SSLv23_METHOD', 'TLSv1_METHOD', 'TLSv1_1_METHOD', 'TLSv1_2_METHOD', 'TLS_METHOD', 'TLS_SERVER_METHOD', 'TLS_CLIENT_METHOD', 'DTLS_METHOD', 'DTLS_SERVER_METHOD', 'DTLS_CLIENT_METHOD', 'SSL3_VERSION', 'TLS1_VERSION', 'TLS1_1_VERSION', 'TLS1_2_VERSION', 'TLS1_3_VERSION', 'OP_NO_SSLv2', 'OP_NO_SSLv3', 'OP_NO_TLSv1', 'OP_NO_TLSv1_1', 'OP_NO_TLSv1_2', 'MODE_RELEASE_BUFFERS', 'OP_SINGLE_DH_USE', 'OP_SINGLE_ECDH_USE', 'OP_EPHEMERAL_RSA', 'OP_MICROSOFT_SESS_ID_BUG', 'OP_NETSCAPE_CHALLENGE_BUG', 'OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG', 'OP_SSLREF2_REUSE_CERT_TYPE_BUG', 'OP_MICROSOFT_BIG_SSLV3_BUFFER', 'OP_MSIE_SSLV2_RSA_PADDING', 'OP_SSLEAY_080_CLIENT_DH_BUG', 'OP_TLS_D5_BUG', 'OP_TLS_BLOCK_PADDING_BUG', 'OP_DONT_INSERT_EMPTY_FRAGMENTS', 'OP_CIPHER_SERVER_PREFERENCE', 'OP_TLS_ROLLBACK_BUG', 'OP_PKCS1_CHECK_1', 'OP_PKCS1_CHECK_2', 'OP_NETSCAPE_CA_DN_BUG', 'OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG', 'OP_NO_COMPRESSION', 'OP_NO_QUERY_MTU', 'OP_COOKIE_EXCHANGE', 'OP_NO_TICKET', 'OP_ALL', 'VERIFY_PEER', 'VERIFY_FAIL_IF_NO_PEER_CERT', 'VERIFY_CLIENT_ONCE', 'VERIFY_NONE', 'SESS_CACHE_OFF', 'SESS_CACHE_CLIENT', 'SESS_CACHE_SERVER', 'SESS_CACHE_BOTH', 'SESS_CACHE_NO_AUTO_CLEAR', 'SESS_CACHE_NO_INTERNAL_LOOKUP', 'SESS_CACHE_NO_INTERNAL_STORE', 'SESS_CACHE_NO_INTERNAL', 'SSL_ST_CONNECT', 'SSL_ST_ACCEPT', 'SSL_ST_MASK', 'SSL_CB_LOOP', 'SSL_CB_EXIT', 'SSL_CB_READ', 'SSL_CB_WRITE', 'SSL_CB_ALERT', 'SSL_CB_READ_ALERT', 'SSL_CB_WRITE_ALERT', 'SSL_CB_ACCEPT_LOOP', 'SSL_CB_ACCEPT_EXIT', 'SSL_CB_CONNECT_LOOP', 'SSL_CB_CONNECT_EXIT', 'SSL_CB_HANDSHAKE_START', 'SSL_CB_HANDSHAKE_DONE', 'Error', 'WantReadError', 'WantWriteError', 'WantX509LookupError', 'ZeroReturnError', 'SysCallError', 'NO_OVERLAPPING_PROTOCOLS', 'SSLeay_version', 'Session', 'Context', 'Connection', 'X509VerificationCodes', 'OP_NO_TLSv1_3', 'OP_NO_RENEGOTIATION', 'OP_IGNORE_UNEXPECTED_EOF']

OPENSSL_VERSION_NUMBER: Incomplete
OPENSSL_VERSION: Incomplete
SSLEAY_VERSION: Incomplete
OPENSSL_CFLAGS: Incomplete
SSLEAY_CFLAGS: Incomplete
OPENSSL_PLATFORM: Incomplete
SSLEAY_PLATFORM: Incomplete
OPENSSL_DIR: Incomplete
SSLEAY_DIR: Incomplete
OPENSSL_BUILT_ON: Incomplete
SSLEAY_BUILT_ON: Incomplete
SENT_SHUTDOWN: Incomplete
RECEIVED_SHUTDOWN: Incomplete
SSLv23_METHOD: int
TLSv1_METHOD: int
TLSv1_1_METHOD: int
TLSv1_2_METHOD: int
TLS_METHOD: int
TLS_SERVER_METHOD: int
TLS_CLIENT_METHOD: int
DTLS_METHOD: int
DTLS_SERVER_METHOD: int
DTLS_CLIENT_METHOD: int
SSL3_VERSION: Incomplete
TLS1_VERSION: Incomplete
TLS1_1_VERSION: Incomplete
TLS1_2_VERSION: Incomplete
TLS1_3_VERSION: Incomplete
OP_NO_SSLv2: Incomplete
OP_NO_SSLv3: Incomplete
OP_NO_TLSv1: Incomplete
OP_NO_TLSv1_1: Incomplete
OP_NO_TLSv1_2: Incomplete
OP_NO_TLSv1_3: Incomplete
MODE_RELEASE_BUFFERS: Incomplete
OP_SINGLE_DH_USE: Incomplete
OP_SINGLE_ECDH_USE: Incomplete
OP_EPHEMERAL_RSA: Incomplete
OP_MICROSOFT_SESS_ID_BUG: Incomplete
OP_NETSCAPE_CHALLENGE_BUG: Incomplete
OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: Incomplete
OP_SSLREF2_REUSE_CERT_TYPE_BUG: Incomplete
OP_MICROSOFT_BIG_SSLV3_BUFFER: Incomplete
OP_MSIE_SSLV2_RSA_PADDING: Incomplete
OP_SSLEAY_080_CLIENT_DH_BUG: Incomplete
OP_TLS_D5_BUG: Incomplete
OP_TLS_BLOCK_PADDING_BUG: Incomplete
OP_DONT_INSERT_EMPTY_FRAGMENTS: Incomplete
OP_CIPHER_SERVER_PREFERENCE: Incomplete
OP_TLS_ROLLBACK_BUG: Incomplete
OP_PKCS1_CHECK_1: Incomplete
OP_PKCS1_CHECK_2: Incomplete
OP_NETSCAPE_CA_DN_BUG: Incomplete
OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: Incomplete
OP_NO_COMPRESSION: Incomplete
OP_NO_QUERY_MTU: Incomplete
OP_COOKIE_EXCHANGE: Incomplete
OP_NO_TICKET: Incomplete
OP_NO_RENEGOTIATION: Incomplete
OP_IGNORE_UNEXPECTED_EOF: Incomplete
OP_ALL: Incomplete
VERIFY_PEER: Incomplete
VERIFY_FAIL_IF_NO_PEER_CERT: Incomplete
VERIFY_CLIENT_ONCE: Incomplete
VERIFY_NONE: Incomplete
SESS_CACHE_OFF: Incomplete
SESS_CACHE_CLIENT: Incomplete
SESS_CACHE_SERVER: Incomplete
SESS_CACHE_BOTH: Incomplete
SESS_CACHE_NO_AUTO_CLEAR: Incomplete
SESS_CACHE_NO_INTERNAL_LOOKUP: Incomplete
SESS_CACHE_NO_INTERNAL_STORE: Incomplete
SESS_CACHE_NO_INTERNAL: Incomplete
SSL_ST_CONNECT: Incomplete
SSL_ST_ACCEPT: Incomplete
SSL_ST_MASK: Incomplete
SSL_CB_LOOP: Incomplete
SSL_CB_EXIT: Incomplete
SSL_CB_READ: Incomplete
SSL_CB_WRITE: Incomplete
SSL_CB_ALERT: Incomplete
SSL_CB_READ_ALERT: Incomplete
SSL_CB_WRITE_ALERT: Incomplete
SSL_CB_ACCEPT_LOOP: Incomplete
SSL_CB_ACCEPT_EXIT: Incomplete
SSL_CB_CONNECT_LOOP: Incomplete
SSL_CB_CONNECT_EXIT: Incomplete
SSL_CB_HANDSHAKE_START: Incomplete
SSL_CB_HANDSHAKE_DONE: Incomplete

class X509VerificationCodes:
    """
    Success and error codes for X509 verification, as returned by the
    underlying ``X509_STORE_CTX_get_error()`` function and passed by pyOpenSSL
    to verification callback functions.

    See `OpenSSL Verification Errors
    <https://www.openssl.org/docs/manmaster/man3/X509_verify_cert_error_string.html#ERROR-CODES>`_
    for details.
    """
    OK: Incomplete
    ERR_UNABLE_TO_GET_ISSUER_CERT: Incomplete
    ERR_UNABLE_TO_GET_CRL: Incomplete
    ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE: Incomplete
    ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE: Incomplete
    ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY: Incomplete
    ERR_CERT_SIGNATURE_FAILURE: Incomplete
    ERR_CRL_SIGNATURE_FAILURE: Incomplete
    ERR_CERT_NOT_YET_VALID: Incomplete
    ERR_CERT_HAS_EXPIRED: Incomplete
    ERR_CRL_NOT_YET_VALID: Incomplete
    ERR_CRL_HAS_EXPIRED: Incomplete
    ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD: Incomplete
    ERR_ERROR_IN_CERT_NOT_AFTER_FIELD: Incomplete
    ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD: Incomplete
    ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD: Incomplete
    ERR_OUT_OF_MEM: Incomplete
    ERR_DEPTH_ZERO_SELF_SIGNED_CERT: Incomplete
    ERR_SELF_SIGNED_CERT_IN_CHAIN: Incomplete
    ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY: Incomplete
    ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE: Incomplete
    ERR_CERT_CHAIN_TOO_LONG: Incomplete
    ERR_CERT_REVOKED: Incomplete
    ERR_INVALID_CA: Incomplete
    ERR_PATH_LENGTH_EXCEEDED: Incomplete
    ERR_INVALID_PURPOSE: Incomplete
    ERR_CERT_UNTRUSTED: Incomplete
    ERR_CERT_REJECTED: Incomplete
    ERR_SUBJECT_ISSUER_MISMATCH: Incomplete
    ERR_AKID_SKID_MISMATCH: Incomplete
    ERR_AKID_ISSUER_SERIAL_MISMATCH: Incomplete
    ERR_KEYUSAGE_NO_CERTSIGN: Incomplete
    ERR_UNABLE_TO_GET_CRL_ISSUER: Incomplete
    ERR_UNHANDLED_CRITICAL_EXTENSION: Incomplete
    ERR_KEYUSAGE_NO_CRL_SIGN: Incomplete
    ERR_UNHANDLED_CRITICAL_CRL_EXTENSION: Incomplete
    ERR_INVALID_NON_CA: Incomplete
    ERR_PROXY_PATH_LENGTH_EXCEEDED: Incomplete
    ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE: Incomplete
    ERR_PROXY_CERTIFICATES_NOT_ALLOWED: Incomplete
    ERR_INVALID_EXTENSION: Incomplete
    ERR_INVALID_POLICY_EXTENSION: Incomplete
    ERR_NO_EXPLICIT_POLICY: Incomplete
    ERR_DIFFERENT_CRL_SCOPE: Incomplete
    ERR_UNSUPPORTED_EXTENSION_FEATURE: Incomplete
    ERR_UNNESTED_RESOURCE: Incomplete
    ERR_PERMITTED_VIOLATION: Incomplete
    ERR_EXCLUDED_VIOLATION: Incomplete
    ERR_SUBTREE_MINMAX: Incomplete
    ERR_UNSUPPORTED_CONSTRAINT_TYPE: Incomplete
    ERR_UNSUPPORTED_CONSTRAINT_SYNTAX: Incomplete
    ERR_UNSUPPORTED_NAME_SYNTAX: Incomplete
    ERR_CRL_PATH_VALIDATION_ERROR: Incomplete
    ERR_HOSTNAME_MISMATCH: Incomplete
    ERR_EMAIL_MISMATCH: Incomplete
    ERR_IP_ADDRESS_MISMATCH: Incomplete
    ERR_APPLICATION_VERIFICATION: Incomplete

class Error(Exception):
    """
    An error occurred in an `OpenSSL.SSL` API.
    """
class WantReadError(Error): ...
class WantWriteError(Error): ...
class WantX509LookupError(Error): ...
class ZeroReturnError(Error): ...
class SysCallError(Error): ...

class _CallbackExceptionHelper:
    """
    A base class for wrapper classes that allow for intelligent exception
    handling in OpenSSL callbacks.

    :ivar list _problems: Any exceptions that occurred while executing in a
        context where they could not be raised in the normal way.  Typically
        this is because OpenSSL has called into some Python code and requires a
        return value.  The exceptions are saved to be raised later when it is
        possible to do so.
    """
    def __init__(self) -> None: ...
    def raise_if_problem(self) -> None:
        """
        Raise an exception from the OpenSSL error queue or that was previously
        captured whe running a callback.
        """

class _VerifyHelper(_CallbackExceptionHelper):
    """
    Wrap a callback such that it can be used as a certificate verification
    callback.
    """
    callback: Incomplete
    def __init__(self, callback) -> None: ...

NO_OVERLAPPING_PROTOCOLS: Incomplete

class _ALPNSelectHelper(_CallbackExceptionHelper):
    """
    Wrap a callback such that it can be used as an ALPN selection callback.
    """
    callback: Incomplete
    def __init__(self, callback) -> None: ...

class _OCSPServerCallbackHelper(_CallbackExceptionHelper):
    """
    Wrap a callback such that it can be used as an OCSP callback for the server
    side.

    Annoyingly, OpenSSL defines one OCSP callback but uses it in two different
    ways. For servers, that callback is expected to retrieve some OCSP data and
    hand it to OpenSSL, and may return only SSL_TLSEXT_ERR_OK,
    SSL_TLSEXT_ERR_FATAL, and SSL_TLSEXT_ERR_NOACK. For clients, that callback
    is expected to check the OCSP data, and returns a negative value on error,
    0 if the response is not acceptable, or positive if it is. These are
    mutually exclusive return code behaviours, and they mean that we need two
    helpers so that we always return an appropriate error code if the user's
    code throws an exception.

    Given that we have to have two helpers anyway, these helpers are a bit more
    helpery than most: specifically, they hide a few more of the OpenSSL
    functions so that the user has an easier time writing these callbacks.

    This helper implements the server side.
    """
    callback: Incomplete
    def __init__(self, callback) -> None: ...

class _OCSPClientCallbackHelper(_CallbackExceptionHelper):
    """
    Wrap a callback such that it can be used as an OCSP callback for the client
    side.

    Annoyingly, OpenSSL defines one OCSP callback but uses it in two different
    ways. For servers, that callback is expected to retrieve some OCSP data and
    hand it to OpenSSL, and may return only SSL_TLSEXT_ERR_OK,
    SSL_TLSEXT_ERR_FATAL, and SSL_TLSEXT_ERR_NOACK. For clients, that callback
    is expected to check the OCSP data, and returns a negative value on error,
    0 if the response is not acceptable, or positive if it is. These are
    mutually exclusive return code behaviours, and they mean that we need two
    helpers so that we always return an appropriate error code if the user's
    code throws an exception.

    Given that we have to have two helpers anyway, these helpers are a bit more
    helpery than most: specifically, they hide a few more of the OpenSSL
    functions so that the user has an easier time writing these callbacks.

    This helper implements the client side.
    """
    callback: Incomplete
    def __init__(self, callback) -> None: ...

class _CookieGenerateCallbackHelper(_CallbackExceptionHelper):
    callback: Incomplete
    def __init__(self, callback) -> None: ...

class _CookieVerifyCallbackHelper(_CallbackExceptionHelper):
    callback: Incomplete
    def __init__(self, callback) -> None: ...
SSLeay_version = OpenSSL_version

class Session:
    """
    A class representing an SSL session.  A session defines certain connection
    parameters which may be re-used to speed up the setup of subsequent
    connections.

    .. versionadded:: 0.14
    """

class Context:
    """
    :class:`OpenSSL.SSL.Context` instances define the parameters for setting
    up new SSL connections.

    :param method: One of TLS_METHOD, TLS_CLIENT_METHOD, TLS_SERVER_METHOD,
                   DTLS_METHOD, DTLS_CLIENT_METHOD, or DTLS_SERVER_METHOD.
                   SSLv23_METHOD, TLSv1_METHOD, etc. are deprecated and should
                   not be used.
    """
    def __init__(self, method) -> None: ...
    def set_min_proto_version(self, version) -> None:
        """
        Set the minimum supported protocol version. Setting the minimum
        version to 0 will enable protocol versions down to the lowest version
        supported by the library.

        If the underlying OpenSSL build is missing support for the selected
        version, this method will raise an exception.
        """
    def set_max_proto_version(self, version) -> None:
        """
        Set the maximum supported protocol version. Setting the maximum
        version to 0 will enable protocol versions up to the highest version
        supported by the library.

        If the underlying OpenSSL build is missing support for the selected
        version, this method will raise an exception.
        """
    def load_verify_locations(self, cafile, capath: Incomplete | None = None) -> None:
        """
        Let SSL know where we can find trusted certificates for the certificate
        chain.  Note that the certificates have to be in PEM format.

        If capath is passed, it must be a directory prepared using the
        ``c_rehash`` tool included with OpenSSL.  Either, but not both, of
        *pemfile* or *capath* may be :data:`None`.

        :param cafile: In which file we can find the certificates (``bytes`` or
            ``unicode``).
        :param capath: In which directory we can find the certificates
            (``bytes`` or ``unicode``).

        :return: None
        """
    def set_passwd_cb(self, callback, userdata: Incomplete | None = None) -> None:
        """
        Set the passphrase callback.  This function will be called
        when a private key with a passphrase is loaded.

        :param callback: The Python callback to use.  This must accept three
            positional arguments.  First, an integer giving the maximum length
            of the passphrase it may return.  If the returned passphrase is
            longer than this, it will be truncated.  Second, a boolean value
            which will be true if the user should be prompted for the
            passphrase twice and the callback should verify that the two values
            supplied are equal. Third, the value given as the *userdata*
            parameter to :meth:`set_passwd_cb`.  The *callback* must return
            a byte string. If an error occurs, *callback* should return a false
            value (e.g. an empty string).
        :param userdata: (optional) A Python object which will be given as
                         argument to the callback
        :return: None
        """
    def set_default_verify_paths(self) -> None:
        """
        Specify that the platform provided CA certificates are to be used for
        verification purposes. This method has some caveats related to the
        binary wheels that cryptography (pyOpenSSL's primary dependency) ships:

        *   macOS will only load certificates using this method if the user has
            the ``openssl@1.1`` `Homebrew <https://brew.sh>`_ formula installed
            in the default location.
        *   Windows will not work.
        *   manylinux1 cryptography wheels will work on most common Linux
            distributions in pyOpenSSL 17.1.0 and above.  pyOpenSSL detects the
            manylinux1 wheel and attempts to load roots via a fallback path.

        :return: None
        """
    def use_certificate_chain_file(self, certfile) -> None:
        """
        Load a certificate chain from a file.

        :param certfile: The name of the certificate chain file (``bytes`` or
            ``unicode``).  Must be PEM encoded.

        :return: None
        """
    def use_certificate_file(self, certfile, filetype=...) -> None:
        """
        Load a certificate from a file

        :param certfile: The name of the certificate file (``bytes`` or
            ``unicode``).
        :param filetype: (optional) The encoding of the file, which is either
            :const:`FILETYPE_PEM` or :const:`FILETYPE_ASN1`.  The default is
            :const:`FILETYPE_PEM`.

        :return: None
        """
    def use_certificate(self, cert) -> None:
        """
        Load a certificate from a X509 object

        :param cert: The X509 object
        :return: None
        """
    def add_extra_chain_cert(self, certobj) -> None:
        """
        Add certificate to chain

        :param certobj: The X509 certificate object to add to the chain
        :return: None
        """
    def use_privatekey_file(self, keyfile, filetype=...) -> None:
        """
        Load a private key from a file

        :param keyfile: The name of the key file (``bytes`` or ``unicode``)
        :param filetype: (optional) The encoding of the file, which is either
            :const:`FILETYPE_PEM` or :const:`FILETYPE_ASN1`.  The default is
            :const:`FILETYPE_PEM`.

        :return: None
        """
    def use_privatekey(self, pkey) -> None:
        """
        Load a private key from a PKey object

        :param pkey: The PKey object
        :return: None
        """
    def check_privatekey(self) -> None:
        """
        Check if the private key (loaded with :meth:`use_privatekey`) matches
        the certificate (loaded with :meth:`use_certificate`)

        :return: :data:`None` (raises :exc:`Error` if something's wrong)
        """
    def load_client_ca(self, cafile) -> None:
        """
        Load the trusted certificates that will be sent to the client.  Does
        not actually imply any of the certificates are trusted; that must be
        configured separately.

        :param bytes cafile: The path to a certificates file in PEM format.
        :return: None
        """
    def set_session_id(self, buf) -> None:
        """
        Set the session id to *buf* within which a session can be reused for
        this Context object.  This is needed when doing session resumption,
        because there is no way for a stored session to know which Context
        object it is associated with.

        :param bytes buf: The session id.

        :returns: None
        """
    def set_session_cache_mode(self, mode):
        """
        Set the behavior of the session cache used by all connections using
        this Context.  The previously set mode is returned.  See
        :const:`SESS_CACHE_*` for details about particular modes.

        :param mode: One or more of the SESS_CACHE_* flags (combine using
            bitwise or)
        :returns: The previously set caching mode.

        .. versionadded:: 0.14
        """
    def get_session_cache_mode(self):
        """
        Get the current session cache mode.

        :returns: The currently used cache mode.

        .. versionadded:: 0.14
        """
    def set_verify(self, mode, callback: Incomplete | None = None) -> None:
        """
        Set the verification flags for this Context object to *mode* and
        specify that *callback* should be used for verification callbacks.

        :param mode: The verify mode, this should be one of
            :const:`VERIFY_NONE` and :const:`VERIFY_PEER`. If
            :const:`VERIFY_PEER` is used, *mode* can be OR:ed with
            :const:`VERIFY_FAIL_IF_NO_PEER_CERT` and
            :const:`VERIFY_CLIENT_ONCE` to further control the behaviour.
        :param callback: The optional Python verification callback to use.
            This should take five arguments: A Connection object, an X509
            object, and three integer variables, which are in turn potential
            error number, error depth and return code. *callback* should
            return True if verification passes and False otherwise.
            If omitted, OpenSSL's default verification is used.
        :return: None

        See SSL_CTX_set_verify(3SSL) for further details.
        """
    def set_verify_depth(self, depth) -> None:
        """
        Set the maximum depth for the certificate chain verification that shall
        be allowed for this Context object.

        :param depth: An integer specifying the verify depth
        :return: None
        """
    def get_verify_mode(self):
        """
        Retrieve the Context object's verify mode, as set by
        :meth:`set_verify`.

        :return: The verify mode
        """
    def get_verify_depth(self):
        """
        Retrieve the Context object's verify depth, as set by
        :meth:`set_verify_depth`.

        :return: The verify depth
        """
    def load_tmp_dh(self, dhfile) -> None:
        """
        Load parameters for Ephemeral Diffie-Hellman

        :param dhfile: The file to load EDH parameters from (``bytes`` or
            ``unicode``).

        :return: None
        """
    def set_tmp_ecdh(self, curve) -> None:
        """
        Select a curve to use for ECDHE key exchange.

        :param curve: A curve object to use as returned by either
            :meth:`OpenSSL.crypto.get_elliptic_curve` or
            :meth:`OpenSSL.crypto.get_elliptic_curves`.

        :return: None
        """
    def set_cipher_list(self, cipher_list) -> None:
        """
        Set the list of ciphers to be used in this context.

        See the OpenSSL manual for more information (e.g.
        :manpage:`ciphers(1)`).

        :param bytes cipher_list: An OpenSSL cipher string.
        :return: None
        """
    def set_client_ca_list(self, certificate_authorities) -> None:
        """
        Set the list of preferred client certificate signers for this server
        context.

        This list of certificate authorities will be sent to the client when
        the server requests a client certificate.

        :param certificate_authorities: a sequence of X509Names.
        :return: None

        .. versionadded:: 0.10
        """
    def add_client_ca(self, certificate_authority) -> None:
        """
        Add the CA certificate to the list of preferred signers for this
        context.

        The list of certificate authorities will be sent to the client when the
        server requests a client certificate.

        :param certificate_authority: certificate authority's X509 certificate.
        :return: None

        .. versionadded:: 0.10
        """
    def set_timeout(self, timeout):
        """
        Set the timeout for newly created sessions for this Context object to
        *timeout*.  The default value is 300 seconds. See the OpenSSL manual
        for more information (e.g. :manpage:`SSL_CTX_set_timeout(3)`).

        :param timeout: The timeout in (whole) seconds
        :return: The previous session timeout
        """
    def get_timeout(self):
        """
        Retrieve session timeout, as set by :meth:`set_timeout`. The default
        is 300 seconds.

        :return: The session timeout
        """
    def set_info_callback(self, callback) -> None:
        """
        Set the information callback to *callback*. This function will be
        called from time to time during SSL handshakes.

        :param callback: The Python callback to use.  This should take three
            arguments: a Connection object and two integers.  The first integer
            specifies where in the SSL handshake the function was called, and
            the other the return code from a (possibly failed) internal
            function call.
        :return: None
        """
    def set_keylog_callback(self, callback) -> None:
        """
        Set the TLS key logging callback to *callback*. This function will be
        called whenever TLS key material is generated or received, in order
        to allow applications to store this keying material for debugging
        purposes.

        :param callback: The Python callback to use.  This should take two
            arguments: a Connection object and a bytestring that contains
            the key material in the format used by NSS for its SSLKEYLOGFILE
            debugging output.
        :return: None
        """
    def get_app_data(self):
        """
        Get the application data (supplied via :meth:`set_app_data()`)

        :return: The application data
        """
    def set_app_data(self, data) -> None:
        """
        Set the application data (will be returned from get_app_data())

        :param data: Any Python object
        :return: None
        """
    def get_cert_store(self):
        '''
        Get the certificate store for the context.  This can be used to add
        "trusted" certificates without using the
        :meth:`load_verify_locations` method.

        :return: A X509Store object or None if it does not have one.
        '''
    def set_options(self, options):
        """
        Add options. Options set before are not cleared!
        This method should be used with the :const:`OP_*` constants.

        :param options: The options to add.
        :return: The new option bitmask.
        """
    def set_mode(self, mode):
        """
        Add modes via bitmask. Modes set before are not cleared!  This method
        should be used with the :const:`MODE_*` constants.

        :param mode: The mode to add.
        :return: The new mode bitmask.
        """
    def set_tlsext_servername_callback(self, callback):
        """
        Specify a callback function to be called when clients specify a server
        name.

        :param callback: The callback function.  It will be invoked with one
            argument, the Connection instance.

        .. versionadded:: 0.13
        """
    def set_tlsext_use_srtp(self, profiles) -> None:
        """
        Enable support for negotiating SRTP keying material.

        :param bytes profiles: A colon delimited list of protection profile
            names, like ``b'SRTP_AES128_CM_SHA1_80:SRTP_AES128_CM_SHA1_32'``.
        :return: None
        """
    def set_alpn_protos(self, protos) -> None:
        """
        Specify the protocols that the client is prepared to speak after the
        TLS connection has been negotiated using Application Layer Protocol
        Negotiation.

        :param protos: A list of the protocols to be offered to the server.
            This list should be a Python list of bytestrings representing the
            protocols to offer, e.g. ``[b'http/1.1', b'spdy/2']``.
        """
    def set_alpn_select_callback(self, callback) -> None:
        """
        Specify a callback function that will be called on the server when a
        client offers protocols using ALPN.

        :param callback: The callback function.  It will be invoked with two
            arguments: the Connection, and a list of offered protocols as
            bytestrings, e.g ``[b'http/1.1', b'spdy/2']``.  It can return
            one of those bytestrings to indicate the chosen protocol, the
            empty bytestring to terminate the TLS connection, or the
            :py:obj:`NO_OVERLAPPING_PROTOCOLS` to indicate that no offered
            protocol was selected, but that the connection should not be
            aborted.
        """
    def set_ocsp_server_callback(self, callback, data: Incomplete | None = None) -> None:
        """
        Set a callback to provide OCSP data to be stapled to the TLS handshake
        on the server side.

        :param callback: The callback function. It will be invoked with two
            arguments: the Connection, and the optional arbitrary data you have
            provided. The callback must return a bytestring that contains the
            OCSP data to staple to the handshake. If no OCSP data is available
            for this connection, return the empty bytestring.
        :param data: Some opaque data that will be passed into the callback
            function when called. This can be used to avoid needing to do
            complex data lookups or to keep track of what context is being
            used. This parameter is optional.
        """
    def set_ocsp_client_callback(self, callback, data: Incomplete | None = None) -> None:
        """
        Set a callback to validate OCSP data stapled to the TLS handshake on
        the client side.

        :param callback: The callback function. It will be invoked with three
            arguments: the Connection, a bytestring containing the stapled OCSP
            assertion, and the optional arbitrary data you have provided. The
            callback must return a boolean that indicates the result of
            validating the OCSP data: ``True`` if the OCSP data is valid and
            the certificate can be trusted, or ``False`` if either the OCSP
            data is invalid or the certificate has been revoked.
        :param data: Some opaque data that will be passed into the callback
            function when called. This can be used to avoid needing to do
            complex data lookups or to keep track of what context is being
            used. This parameter is optional.
        """
    def set_cookie_generate_callback(self, callback) -> None: ...
    def set_cookie_verify_callback(self, callback) -> None: ...

class Connection:
    def __init__(self, context, socket: Incomplete | None = None) -> None:
        """
        Create a new Connection object, using the given OpenSSL.SSL.Context
        instance and socket.

        :param context: An SSL Context to use for this connection
        :param socket: The socket to use for transport layer
        """
    def __getattr__(self, name):
        """
        Look up attributes on the wrapped socket object if they are not found
        on the Connection object.
        """
    def get_context(self):
        """
        Retrieve the :class:`Context` object associated with this
        :class:`Connection`.
        """
    def set_context(self, context) -> None:
        """
        Switch this connection to a new session context.

        :param context: A :class:`Context` instance giving the new session
            context to use.
        """
    def get_servername(self):
        """
        Retrieve the servername extension value if provided in the client hello
        message, or None if there wasn't one.

        :return: A byte string giving the server name or :data:`None`.

        .. versionadded:: 0.13
        """
    def set_verify(self, mode, callback: Incomplete | None = None) -> None:
        """
        Override the Context object's verification flags for this specific
        connection. See :py:meth:`Context.set_verify` for details.
        """
    def get_verify_mode(self):
        """
        Retrieve the Connection object's verify mode, as set by
        :meth:`set_verify`.

        :return: The verify mode
        """
    def use_certificate(self, cert) -> None:
        """
        Load a certificate from a X509 object

        :param cert: The X509 object
        :return: None
        """
    def use_privatekey(self, pkey) -> None:
        """
        Load a private key from a PKey object

        :param pkey: The PKey object
        :return: None
        """
    def set_ciphertext_mtu(self, mtu) -> None:
        """
        For DTLS, set the maximum UDP payload size (*not* including IP/UDP
        overhead).

        Note that you might have to set :data:`OP_NO_QUERY_MTU` to prevent
        OpenSSL from spontaneously clearing this.

        :param mtu: An integer giving the maximum transmission unit.

        .. versionadded:: 21.1
        """
    def get_cleartext_mtu(self):
        """
        For DTLS, get the maximum size of unencrypted data you can pass to
        :meth:`write` without exceeding the MTU (as passed to
        :meth:`set_ciphertext_mtu`).

        :return: The effective MTU as an integer.

        .. versionadded:: 21.1
        """
    def set_tlsext_host_name(self, name) -> None:
        """
        Set the value of the servername extension to send in the client hello.

        :param name: A byte string giving the name.

        .. versionadded:: 0.13
        """
    def pending(self):
        """
        Get the number of bytes that can be safely read from the SSL buffer
        (**not** the underlying transport buffer).

        :return: The number of bytes available in the receive buffer.
        """
    def send(self, buf, flags: int = 0):
        """
        Send data on the connection. NOTE: If you get one of the WantRead,
        WantWrite or WantX509Lookup exceptions on this, you have to call the
        method again with the SAME buffer.

        :param buf: The string, buffer or memoryview to send
        :param flags: (optional) Included for compatibility with the socket
                      API, the value is ignored
        :return: The number of bytes written
        """
    write = send
    def sendall(self, buf, flags: int = 0):
        '''
        Send "all" data on the connection. This calls send() repeatedly until
        all data is sent. If an error occurs, it\'s impossible to tell how much
        data has been sent.

        :param buf: The string, buffer or memoryview to send
        :param flags: (optional) Included for compatibility with the socket
                      API, the value is ignored
        :return: The number of bytes written
        '''
    def recv(self, bufsiz, flags: Incomplete | None = None):
        """
        Receive data on the connection.

        :param bufsiz: The maximum number of bytes to read
        :param flags: (optional) The only supported flag is ``MSG_PEEK``,
            all other flags are ignored.
        :return: The string read from the Connection
        """
    read = recv
    def recv_into(self, buffer, nbytes: Incomplete | None = None, flags: Incomplete | None = None):
        """
        Receive data on the connection and copy it directly into the provided
        buffer, rather than creating a new string.

        :param buffer: The buffer to copy into.
        :param nbytes: (optional) The maximum number of bytes to read into the
            buffer. If not present, defaults to the size of the buffer. If
            larger than the size of the buffer, is reduced to the size of the
            buffer.
        :param flags: (optional) The only supported flag is ``MSG_PEEK``,
            all other flags are ignored.
        :return: The number of bytes read into the buffer.
        """
    def bio_read(self, bufsiz):
        """
        If the Connection was created with a memory BIO, this method can be
        used to read bytes from the write end of that memory BIO.  Many
        Connection methods will add bytes which must be read in this manner or
        the buffer will eventually fill up and the Connection will be able to
        take no further actions.

        :param bufsiz: The maximum number of bytes to read
        :return: The string read.
        """
    def bio_write(self, buf):
        """
        If the Connection was created with a memory BIO, this method can be
        used to add bytes to the read end of that memory BIO.  The Connection
        can then read the bytes (for example, in response to a call to
        :meth:`recv`).

        :param buf: The string to put into the memory BIO.
        :return: The number of bytes written
        """
    def renegotiate(self):
        """
        Renegotiate the session.

        :return: True if the renegotiation can be started, False otherwise
        :rtype: bool
        """
    def do_handshake(self) -> None:
        """
        Perform an SSL handshake (usually called after :meth:`renegotiate` or
        one of :meth:`set_accept_state` or :meth:`set_connect_state`). This can
        raise the same exceptions as :meth:`send` and :meth:`recv`.

        :return: None.
        """
    def renegotiate_pending(self):
        """
        Check if there's a renegotiation in progress, it will return False once
        a renegotiation is finished.

        :return: Whether there's a renegotiation in progress
        :rtype: bool
        """
    def total_renegotiations(self):
        """
        Find out the total number of renegotiations.

        :return: The number of renegotiations.
        :rtype: int
        """
    def connect(self, addr):
        """
        Call the :meth:`connect` method of the underlying socket and set up SSL
        on the socket, using the :class:`Context` object supplied to this
        :class:`Connection` object at creation.

        :param addr: A remote address
        :return: What the socket's connect method returns
        """
    def connect_ex(self, addr):
        """
        Call the :meth:`connect_ex` method of the underlying socket and set up
        SSL on the socket, using the Context object supplied to this Connection
        object at creation. Note that if the :meth:`connect_ex` method of the
        socket doesn't return 0, SSL won't be initialized.

        :param addr: A remove address
        :return: What the socket's connect_ex method returns
        """
    def accept(self):
        """
        Call the :meth:`accept` method of the underlying socket and set up SSL
        on the returned socket, using the Context object supplied to this
        :class:`Connection` object at creation.

        :return: A *(conn, addr)* pair where *conn* is the new
            :class:`Connection` object created, and *address* is as returned by
            the socket's :meth:`accept`.
        """
    def DTLSv1_listen(self) -> None:
        """
        Call the OpenSSL function DTLSv1_listen on this connection. See the
        OpenSSL manual for more details.

        :return: None
        """
    def DTLSv1_get_timeout(self):
        """
        Determine when the DTLS SSL object next needs to perform internal
        processing due to the passage of time.

        When the returned number of seconds have passed, the
        :meth:`DTLSv1_handle_timeout` method needs to be called.

        :return: The time left in seconds before the next timeout or `None`
            if no timeout is currently active.
        """
    def DTLSv1_handle_timeout(self):
        """
        Handles any timeout events which have become pending on a DTLS SSL
        object.

        :return: `True` if there was a pending timeout, `False` otherwise.
        """
    def bio_shutdown(self) -> None:
        """
        If the Connection was created with a memory BIO, this method can be
        used to indicate that *end of file* has been reached on the read end of
        that memory BIO.

        :return: None
        """
    def shutdown(self):
        """
        Send the shutdown message to the Connection.

        :return: True if the shutdown completed successfully (i.e. both sides
                 have sent closure alerts), False otherwise (in which case you
                 call :meth:`recv` or :meth:`send` when the connection becomes
                 readable/writeable).
        """
    def get_cipher_list(self):
        """
        Retrieve the list of ciphers used by the Connection object.

        :return: A list of native cipher strings.
        """
    def get_client_ca_list(self):
        """
        Get CAs whose certificates are suggested for client authentication.

        :return: If this is a server connection, the list of certificate
            authorities that will be sent or has been sent to the client, as
            controlled by this :class:`Connection`'s :class:`Context`.

            If this is a client connection, the list will be empty until the
            connection with the server is established.

        .. versionadded:: 0.10
        """
    def makefile(self, *args, **kwargs) -> None:
        """
        The makefile() method is not implemented, since there is no dup
        semantics for SSL connections

        :raise: NotImplementedError
        """
    def get_app_data(self):
        """
        Retrieve application data as set by :meth:`set_app_data`.

        :return: The application data
        """
    def set_app_data(self, data) -> None:
        """
        Set application data

        :param data: The application data
        :return: None
        """
    def get_shutdown(self):
        """
        Get the shutdown state of the Connection.

        :return: The shutdown state, a bitvector of SENT_SHUTDOWN,
            RECEIVED_SHUTDOWN.
        """
    def set_shutdown(self, state) -> None:
        """
        Set the shutdown state of the Connection.

        :param state: bitvector of SENT_SHUTDOWN, RECEIVED_SHUTDOWN.
        :return: None
        """
    def get_state_string(self):
        """
        Retrieve a verbose string detailing the state of the Connection.

        :return: A string representing the state
        :rtype: bytes
        """
    def server_random(self):
        """
        Retrieve the random value used with the server hello message.

        :return: A string representing the state
        """
    def client_random(self):
        """
        Retrieve the random value used with the client hello message.

        :return: A string representing the state
        """
    def master_key(self):
        """
        Retrieve the value of the master key for this session.

        :return: A string representing the state
        """
    def export_keying_material(self, label, olen, context: Incomplete | None = None):
        """
        Obtain keying material for application use.

        :param: label - a disambiguating label string as described in RFC 5705
        :param: olen - the length of the exported key material in bytes
        :param: context - a per-association context value
        :return: the exported key material bytes or None
        """
    def sock_shutdown(self, *args, **kwargs):
        """
        Call the :meth:`shutdown` method of the underlying socket.
        See :manpage:`shutdown(2)`.

        :return: What the socket's shutdown() method returns
        """
    def get_certificate(self):
        """
        Retrieve the local certificate (if any)

        :return: The local certificate
        """
    def get_peer_certificate(self):
        """
        Retrieve the other side's certificate (if any)

        :return: The peer's certificate
        """
    def get_peer_cert_chain(self):
        """
        Retrieve the other side's certificate (if any)

        :return: A list of X509 instances giving the peer's certificate chain,
                 or None if it does not have one.
        """
    def get_verified_chain(self):
        """
        Retrieve the verified certificate chain of the peer including the
        peer's end entity certificate. It must be called after a session has
        been successfully established. If peer verification was not successful
        the chain may be incomplete, invalid, or None.

        :return: A list of X509 instances giving the peer's verified
                 certificate chain, or None if it does not have one.

        .. versionadded:: 20.0
        """
    def want_read(self):
        """
        Checks if more data has to be read from the transport layer to complete
        an operation.

        :return: True iff more data has to be read
        """
    def want_write(self):
        """
        Checks if there is data to write to the transport layer to complete an
        operation.

        :return: True iff there is data to write
        """
    def set_accept_state(self) -> None:
        """
        Set the connection to work in server mode. The handshake will be
        handled automatically by read/write.

        :return: None
        """
    def set_connect_state(self) -> None:
        """
        Set the connection to work in client mode. The handshake will be
        handled automatically by read/write.

        :return: None
        """
    def get_session(self):
        """
        Returns the Session currently used.

        :return: An instance of :class:`OpenSSL.SSL.Session` or
            :obj:`None` if no session exists.

        .. versionadded:: 0.14
        """
    def set_session(self, session) -> None:
        """
        Set the session to be used when the TLS/SSL connection is established.

        :param session: A Session instance representing the session to use.
        :returns: None

        .. versionadded:: 0.14
        """
    def get_finished(self):
        """
        Obtain the latest TLS Finished message that we sent.

        :return: The contents of the message or :obj:`None` if the TLS
            handshake has not yet completed.
        :rtype: :class:`bytes` or :class:`NoneType`

        .. versionadded:: 0.15
        """
    def get_peer_finished(self):
        """
        Obtain the latest TLS Finished message that we received from the peer.

        :return: The contents of the message or :obj:`None` if the TLS
            handshake has not yet completed.
        :rtype: :class:`bytes` or :class:`NoneType`

        .. versionadded:: 0.15
        """
    def get_cipher_name(self):
        """
        Obtain the name of the currently used cipher.

        :returns: The name of the currently used cipher or :obj:`None`
            if no connection has been established.
        :rtype: :class:`unicode` or :class:`NoneType`

        .. versionadded:: 0.15
        """
    def get_cipher_bits(self):
        """
        Obtain the number of secret bits of the currently used cipher.

        :returns: The number of secret bits of the currently used cipher
            or :obj:`None` if no connection has been established.
        :rtype: :class:`int` or :class:`NoneType`

        .. versionadded:: 0.15
        """
    def get_cipher_version(self):
        """
        Obtain the protocol version of the currently used cipher.

        :returns: The protocol name of the currently used cipher
            or :obj:`None` if no connection has been established.
        :rtype: :class:`unicode` or :class:`NoneType`

        .. versionadded:: 0.15
        """
    def get_protocol_version_name(self):
        """
        Retrieve the protocol version of the current connection.

        :returns: The TLS version of the current connection, for example
            the value for TLS 1.2 would be ``TLSv1.2``or ``Unknown``
            for connections that were not successfully established.
        :rtype: :class:`unicode`
        """
    def get_protocol_version(self):
        """
        Retrieve the SSL or TLS protocol version of the current connection.

        :returns: The TLS version of the current connection.  For example,
            it will return ``0x769`` for connections made over TLS version 1.
        :rtype: :class:`int`
        """
    def set_alpn_protos(self, protos) -> None:
        """
        Specify the client's ALPN protocol list.

        These protocols are offered to the server during protocol negotiation.

        :param protos: A list of the protocols to be offered to the server.
            This list should be a Python list of bytestrings representing the
            protocols to offer, e.g. ``[b'http/1.1', b'spdy/2']``.
        """
    def get_alpn_proto_negotiated(self):
        """
        Get the protocol that was negotiated by ALPN.

        :returns: A bytestring of the protocol name.  If no protocol has been
            negotiated yet, returns an empty bytestring.
        """
    def request_ocsp(self) -> None:
        """
        Called to request that the server sends stapled OCSP data, if
        available. If this is not called on the client side then the server
        will not send OCSP data. Should be used in conjunction with
        :meth:`Context.set_ocsp_client_callback`.
        """
