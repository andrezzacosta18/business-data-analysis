import datetime
import numpy as np
import pandas as pd
from .feature import monthly_fourier_features as monthly_fourier_features
from _typeshed import Incomplete
from dataclasses import dataclass
from pandas import DataFrame, to_datetime as to_datetime
from typing import Callable, Dict, Generator, List

class PD: ...

@dataclass
class TimeSeriesDataset:
    train_data: pd.DataFrame
    time_idx: str
    time_col: str
    target_names: List[str]
    frequency: str
    test_data: pd.DataFrame
    time_varying_known_categoricals: List[str] = ...
    time_varying_known_reals: List[str] = ...
    time_varying_unknown_categoricals: List[str] = ...
    time_varying_unknown_reals: List[str] = ...
    def __init__(self, train_data: pd.DataFrame, time_col: str, target_names: str | List[str], time_idx: str = 'time_idx', test_data: pd.DataFrame | None = None) -> None: ...
    def add_test_data(self, X: pd.DataFrame) -> TimeSeriesDataset: ...
    @staticmethod
    def to_dataframe(X, y, target_names: List[str], time_col: str): ...
    @property
    def all_data(self): ...
    @property
    def regressors(self): ...
    @property
    def end_date(self): ...
    @property
    def X_train(self) -> pd.DataFrame: ...
    @property
    def X_val(self) -> pd.DataFrame: ...
    @property
    def X_all(self) -> pd.DataFrame: ...
    @property
    def y_train(self) -> pd.DataFrame: ...
    @property
    def y_val(self) -> pd.DataFrame: ...
    @property
    def y_all(self) -> pd.DataFrame: ...
    def next_scale(self) -> int: ...
    def known_features_to_floats(self, train: bool, drop_first: bool = True) -> np.ndarray: ...
    def to_univariate(self) -> Dict[str, 'TimeSeriesDataset']:
        """
        Convert a multivariate TrainingData  to a dict of univariate ones
        @param df:
        @return:
        """
    def move_validation_boundary(self, steps: int) -> TimeSeriesDataset: ...
    def cv_train_val_sets(self, n_splits: int, val_length: int, step_size: int) -> Generator['TimeSeriesDataset', None, None]: ...
    def filter(self, filter_fun: Callable) -> TimeSeriesDataset: ...
    def prettify_prediction(self, y_pred: pd.DataFrame | pd.Series | np.ndarray): ...
    def merge_prediction_with_target(self, y_pred: pd.DataFrame | pd.Series | np.ndarray): ...

def enrich_dataframe(df: pd.DataFrame | pd.Series, fourier_degree: int, remove_constants: bool = False, fourier_time: bool = True) -> pd.DataFrame: ...
def enrich_dataset(X: TimeSeriesDataset, fourier_degree: int = 0, remove_constants: bool = False, fourier_time: bool = True) -> TimeSeriesDataset: ...
def date_feature_dict(timestamps: pd.Series) -> dict: ...
def date_feature_dict_fourier(timestamps: pd.Series) -> dict: ...
def fourier_series(feature: pd.Series, name: str):
    """
    Assume feature goes from 0 to 1 cyclically, transform that into Fourier
    @param feature: input feature
    @return: sin(2pi*feature), cos(2pi*feature)
    """

class DataTransformerTS:
    """Transform input time series training data."""
    time_col: Incomplete
    time_idx: Incomplete
    label: Incomplete
    cat_columns: Incomplete
    num_columns: Incomplete
    datetime_columns: Incomplete
    drop_columns: Incomplete
    def __init__(self, time_col: str, label: str | List[str], time_idx: str = 'time_idx') -> None: ...
    transformer: Incomplete
    label_transformer: Incomplete
    def fit(self, X: DataFrame | np.array, y):
        """Fit transformer.

        Args:
            X: A numpy array or a pandas dataframe of training data.
            y: A numpy array or a pandas series of labels.

        Returns:
            X: Processed numpy array or pandas dataframe of training data.
            y: Processed numpy array or pandas series of labels.
        """
    def transform(self, X: DataFrame | np.array, y: Incomplete | None = None): ...
    def fit_transform(self, X: DataFrame | np.array, y): ...

def create_forward_frame(frequency: str, steps: int, test_end_date: datetime.datetime, time_col: str): ...
def normalize_ts_data(X_train_all, target_names, time_col, y_train_all: Incomplete | None = None): ...
def validate_data_basic(X_train_all, y_train_all) -> None: ...
