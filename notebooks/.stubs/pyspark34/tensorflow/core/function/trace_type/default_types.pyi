import weakref
from _typeshed import Incomplete
from tensorflow.core.function.trace_type import default_types_pb2 as default_types_pb2, serialization as serialization, util as util
from tensorflow.python.types import trace as trace
from typing import Any, Dict as PythonDict, Hashable, Optional, Sequence, Tuple as PythonTuple, Type

class Literal(trace.TraceType, serialization.Serializable):
    """Represents a Literal type like bool, int or string."""
    value: Incomplete
    def __init__(self, value: Any) -> None: ...
    def is_subtype_of(self, other: trace.TraceType) -> bool: ...
    def most_specific_common_supertype(self, types: Sequence[trace.TraceType]) -> Optional['Literal']: ...
    @classmethod
    def experimental_type_proto(cls) -> Type[default_types_pb2.SerializedLiteral]: ...
    @classmethod
    def experimental_from_proto(cls, proto: default_types_pb2.SerializedLiteral) -> Literal: ...
    def experimental_as_proto(self) -> default_types_pb2.SerializedLiteral: ...
    def placeholder_value(self, placeholder_context: Incomplete | None = None) -> Any: ...
    def __eq__(self, other) -> bool: ...
    def __hash__(self) -> int: ...

class Weakref(trace.TraceType):
    """Represents weakref of an arbitrary Python object.

  When a function argument is a custom class, instead of making a copy of it
  just for the sake of function cache, a weakref is instead kept to save memory.
  """
    def __init__(self, ref: weakref.ReferenceType) -> None: ...
    def is_subtype_of(self, other: trace.TraceType) -> bool: ...
    def most_specific_common_supertype(self, types: Sequence[trace.TraceType]) -> Optional['Weakref']: ...
    def placeholder_value(self, placeholder_context: Incomplete | None = None) -> Any: ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class Tuple(trace.TraceType, serialization.Serializable):
    """Represents a tuple of TraceType objects."""
    components: Incomplete
    def __init__(self, *components: trace.TraceType) -> None: ...
    def is_subtype_of(self, other: trace.TraceType) -> bool: ...
    def most_specific_common_supertype(self, others: Sequence[trace.TraceType]) -> Optional['Tuple']:
        """See base class."""
    @classmethod
    def experimental_type_proto(cls) -> Type[default_types_pb2.SerializedTuple]: ...
    @classmethod
    def experimental_from_proto(cls, proto: default_types_pb2.SerializedTuple) -> Tuple: ...
    def experimental_as_proto(self) -> default_types_pb2.SerializedTuple: ...
    def placeholder_value(self, placeholder_context) -> Any: ...
    def __eq__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...

class List(trace.TraceType, serialization.Serializable):
    """Represents a list of TraceType objects."""
    components_tuple: Incomplete
    def __init__(self, *components: trace.TraceType) -> None: ...
    def is_subtype_of(self, other: trace.TraceType) -> bool: ...
    def most_specific_common_supertype(self, others: Sequence[trace.TraceType]) -> Optional['Tuple']:
        """See base class."""
    @classmethod
    def experimental_type_proto(cls) -> Type[default_types_pb2.SerializedList]: ...
    @classmethod
    def experimental_from_proto(cls, proto: default_types_pb2.SerializedList) -> List: ...
    def experimental_as_proto(self) -> default_types_pb2.SerializedList: ...
    def placeholder_value(self, placeholder_context) -> Any: ...
    def __eq__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...

class NamedTuple(trace.TraceType, serialization.Serializable):
    """Represents a NamedTuple of TraceType objects."""
    type_name: Incomplete
    attribute_names: Incomplete
    attributes: Incomplete
    def __init__(self, type_name: str, attribute_names: PythonTuple[str], attributes: PythonTuple[trace.TraceType], placeholder_type: Optional[Type[Any]] = None) -> None: ...
    @classmethod
    def from_type_and_attributes(cls, named_tuple_type: Any, attributes: PythonTuple[trace.TraceType]) -> NamedTuple: ...
    def is_subtype_of(self, other: trace.TraceType) -> bool: ...
    def most_specific_common_supertype(self, others: Sequence[trace.TraceType]) -> Optional['NamedTuple']:
        """See base class."""
    @classmethod
    def experimental_type_proto(cls) -> Type[default_types_pb2.SerializedNamedTuple]: ...
    @classmethod
    def experimental_from_proto(cls, proto: default_types_pb2.SerializedNamedTuple) -> NamedTuple: ...
    def experimental_as_proto(self) -> default_types_pb2.SerializedNamedTuple: ...
    def placeholder_value(self, placeholder_context) -> Any: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: Any) -> bool: ...

class Attrs(trace.TraceType):
    """Represents a class annotated by attr.s."""
    named_attributes: Incomplete
    def __init__(self, type_name: str, attribute_names: PythonTuple[str], attributes: PythonTuple[trace.TraceType], placeholder_type: Optional[Type[Any]] = None) -> None: ...
    @classmethod
    def from_type_and_attributes(cls, attrs_type: Any, attributes: PythonTuple[trace.TraceType]) -> Attrs: ...
    def is_subtype_of(self, other: trace.TraceType) -> bool: ...
    def most_specific_common_supertype(self, others: Sequence[trace.TraceType]) -> Optional['Attrs']:
        """See base class."""
    @classmethod
    def experimental_type_proto(cls) -> Type[default_types_pb2.SerializedAttrs]: ...
    @classmethod
    def experimental_from_proto(cls, proto: default_types_pb2.SerializedAttrs) -> Attrs: ...
    def experimental_as_proto(self) -> default_types_pb2.SerializedAttrs: ...
    def placeholder_value(self, placeholder_context) -> Any: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: Any) -> bool: ...

class Dict(trace.TraceType, serialization.Serializable):
    """Represents a dictionary of TraceType objects.

  Attributes:
    mapping: A mapping from keys to corresponding TraceTypes of the dict values.
  """
    mapping: Incomplete
    def __init__(self, mapping: PythonDict[Hashable, trace.TraceType], placeholder_type: Optional[Type[Any]] = None) -> None: ...
    def is_subtype_of(self, other: trace.TraceType) -> bool:
        """See base class."""
    def most_specific_common_supertype(self, types: Sequence[trace.TraceType]) -> Optional['Dict']:
        """See base class."""
    @classmethod
    def experimental_type_proto(cls) -> Type[default_types_pb2.SerializedDict]: ...
    @classmethod
    def experimental_from_proto(cls, proto: default_types_pb2.SerializedDict) -> Dict: ...
    def experimental_as_proto(self) -> default_types_pb2.SerializedDict: ...
    def placeholder_value(self, placeholder_context) -> Any: ...
    def __eq__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
