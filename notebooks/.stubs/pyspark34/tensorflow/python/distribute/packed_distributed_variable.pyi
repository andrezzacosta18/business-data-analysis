from _typeshed import Incomplete
from tensorflow.python.distribute import device_util as device_util
from tensorflow.python.eager import context as context
from tensorflow.python.framework import ops as ops, tensor_conversion_registry as tensor_conversion_registry
from tensorflow.python.ops import math_ops as math_ops, resource_variable_ops as resource_variable_ops

class PackedDistributedVariable(resource_variable_ops.BaseResourceVariable):
    """A variable which packs multiple variables distributed across devices.

  It's only supported when eager execution is enabled.
  For op-by-op execution, use an unpacked handle on the current device; for
  function execution, use the packed handle to reduce the overhead of function
  calls.
  """
    def __init__(self, distributed_variables: Incomplete | None = None, name: Incomplete | None = None, **unused_kwargs) -> None:
        """Packs a list of variables which are distributed across devices.

    Args:
      distributed_variables: A list of distributed Variables to pack.
      name: Optional name for the variable. Defaults to `'Variable'` and gets
        uniquified automatically.
    """
    @property
    def devices(self): ...
    def on_device(self, device): ...
    def get_var_on_device(self, device): ...
    def get_var_on_current_device(self): ...
    def initial_value(self, device):
        """Returns the Tensor used as the initial value for the variable."""
    @property
    def handle(self): ...
    @property
    def packed_handle(self): ...
    def value(self): ...
    def is_initialized(self, name: Incomplete | None = None): ...
    def assign_sub(self, delta, use_locking: Incomplete | None = None, name: Incomplete | None = None, read_value: bool = True): ...
    def assign_add(self, delta, use_locking: Incomplete | None = None, name: Incomplete | None = None, read_value: bool = True): ...
    def assign(self, value, use_locking: Incomplete | None = None, name: Incomplete | None = None, read_value: bool = True): ...
    def scatter_sub(self, sparse_delta, use_locking: bool = False, name: Incomplete | None = None): ...
    def scatter_add(self, sparse_delta, use_locking: bool = False, name: Incomplete | None = None): ...
    def scatter_mul(self, sparse_delta, use_locking: bool = False, name: Incomplete | None = None): ...
    def scatter_div(self, sparse_delta, use_locking: bool = False, name: Incomplete | None = None): ...
    def scatter_min(self, sparse_delta, use_locking: bool = False, name: Incomplete | None = None): ...
    def scatter_max(self, sparse_delta, use_locking: bool = False, name: Incomplete | None = None): ...
    def scatter_update(self, sparse_delta, use_locking: bool = False, name: Incomplete | None = None): ...

class PackedVarAndDevice:
    """Holds a packed distributed variable and a device."""
    def __init__(self, var, device) -> None: ...
    def __getattr__(self, name): ...
    def var(self): ...
    def value(self): ...
    def read_value(self): ...
    @property
    def initial_value(self): ...
    def initialized_value(self): ...
    @property
    def device(self): ...
    @property
    def handle(self): ...
    def on_device_handle(self): ...
    @property
    def op(self): ...
    def assign_sub(self, delta, use_locking: Incomplete | None = None, name: Incomplete | None = None, read_value: bool = True): ...
    def assign_add(self, delta, use_locking: Incomplete | None = None, name: Incomplete | None = None, read_value: bool = True): ...
    def assign(self, value, use_locking: Incomplete | None = None, name: Incomplete | None = None, read_value: bool = True): ...
    def scatter_sub(self, sparse_delta, use_locking: bool = False, name: Incomplete | None = None): ...
    def scatter_add(self, sparse_delta, use_locking: bool = False, name: Incomplete | None = None): ...
    def scatter_mul(self, sparse_delta, use_locking: bool = False, name: Incomplete | None = None): ...
    def scatter_div(self, sparse_delta, use_locking: bool = False, name: Incomplete | None = None): ...
    def scatter_min(self, sparse_delta, use_locking: bool = False, name: Incomplete | None = None): ...
    def scatter_max(self, sparse_delta, use_locking: bool = False, name: Incomplete | None = None): ...
    def scatter_update(self, sparse_delta, use_locking: bool = False, name: Incomplete | None = None): ...
