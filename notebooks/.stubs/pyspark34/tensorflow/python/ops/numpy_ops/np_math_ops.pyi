from _typeshed import Incomplete
from tensorflow.python.framework import constant_op as constant_op, dtypes as dtypes, errors as errors, ops as ops
from tensorflow.python.ops import array_ops as array_ops, bitwise_ops as bitwise_ops, clip_ops as clip_ops, control_flow_ops as control_flow_ops, gen_math_ops as gen_math_ops, math_ops as math_ops, nn_ops as nn_ops, sort_ops as sort_ops, special_math_ops as special_math_ops
from tensorflow.python.ops.numpy_ops import np_array_ops as np_array_ops, np_arrays as np_arrays, np_dtypes as np_dtypes, np_export as np_export, np_utils as np_utils

pi: Incomplete
e: Incomplete
inf: Incomplete

def dot(a, b): ...
def add(x1, x2): ...
def subtract(x1, x2): ...
def multiply(x1, x2): ...
def true_divide(x1, x2): ...
def divide(x1, x2): ...
def floor_divide(x1, x2): ...
def mod(x1, x2): ...
def remainder(x1, x2): ...
def divmod(x1, x2): ...
def maximum(x1, x2): ...
def minimum(x1, x2): ...
def clip(a, a_min, a_max): ...
def matmul(x1, x2): ...
def tensordot(a, b, axes: int = 2): ...
def inner(a, b): ...
def cross(a, b, axisa: int = -1, axisb: int = -1, axisc: int = -1, axis: Incomplete | None = None): ...
def vdot(a, b): ...
def power(x1, x2): ...
def float_power(x1, x2): ...
def arctan2(x1, x2): ...
def nextafter(x1, x2): ...
def heaviside(x1, x2): ...
def hypot(x1, x2): ...
def kron(a, b): ...
def outer(a, b): ...
def logaddexp(x1, x2): ...
def logaddexp2(x1, x2): ...
def polyval(p, x): ...
def isclose(a, b, rtol: float = 1e-05, atol: float = 1e-08, equal_nan: bool = False): ...
def allclose(a, b, rtol: float = 1e-05, atol: float = 1e-08, equal_nan: bool = False): ...
def gcd(x1, x2): ...
def lcm(x1, x2): ...
def bitwise_and(x1, x2): ...
def bitwise_or(x1, x2): ...
def bitwise_xor(x1, x2): ...
def bitwise_not(x): ...
def log(x): ...
def exp(x): ...
def sqrt(x): ...
def abs(x): ...
def absolute(x): ...
def fabs(x): ...
def ceil(x): ...
def floor(x): ...
def conj(x): ...
def negative(x): ...
def reciprocal(x): ...
def signbit(x): ...
def sin(x): ...
def cos(x): ...
def tan(x): ...
def sinh(x): ...
def cosh(x): ...
def tanh(x): ...
def arcsin(x): ...
def arccos(x): ...
def arctan(x): ...
def arcsinh(x): ...
def arccosh(x): ...
def arctanh(x): ...
def deg2rad(x): ...
def rad2deg(x): ...
def angle(z, deg: bool = False): ...
def cbrt(x): ...
def conjugate(x): ...
def exp2(x): ...
def expm1(x): ...
def fix(x): ...
def iscomplex(x): ...
def isreal(x): ...
def iscomplexobj(x): ...
def isrealobj(x): ...
def isnan(x): ...

nansum: Incomplete
nanprod: Incomplete

def nanmean(a, axis: Incomplete | None = None, dtype: Incomplete | None = None, keepdims: Incomplete | None = None): ...
def isfinite(x): ...
def isinf(x): ...
def isneginf(x): ...
def isposinf(x): ...
def log2(x): ...
def log10(x): ...
def log1p(x): ...
def positive(x): ...
def sinc(x): ...
def square(x): ...
def diff(a, n: int = 1, axis: int = -1): ...
def equal(x1, x2): ...
def not_equal(x1, x2): ...
def greater(x1, x2): ...
def greater_equal(x1, x2): ...
def less(x1, x2): ...
def less_equal(x1, x2): ...
def array_equal(a1, a2): ...
def logical_and(x1, x2): ...
def logical_or(x1, x2): ...
def logical_xor(x1, x2): ...
def logical_not(x): ...
def linspace(start, stop, num: int = 50, endpoint: bool = True, retstep: bool = False, dtype=..., axis: int = 0): ...
def logspace(start, stop, num: int = 50, endpoint: bool = True, base: float = 10.0, dtype: Incomplete | None = None, axis: int = 0): ...
def geomspace(start, stop, num: int = 50, endpoint: bool = True, dtype: Incomplete | None = None, axis: int = 0): ...
def ptp(a, axis: Incomplete | None = None, keepdims: Incomplete | None = None): ...
def concatenate(arys, axis: int = 0): ...
def tile(a, reps): ...
def count_nonzero(a, axis: Incomplete | None = None): ...
def argsort(a, axis: int = -1, kind: str = 'quicksort', order: Incomplete | None = None): ...
def sort(a, axis: int = -1, kind: str = 'quicksort', order: Incomplete | None = None): ...
def argmax(a, axis: Incomplete | None = None): ...
def argmin(a, axis: Incomplete | None = None): ...
def append(arr, values, axis: Incomplete | None = None): ...
def average(a, axis: Incomplete | None = None, weights: Incomplete | None = None, returned: bool = False): ...
def trace(a, offset: int = 0, axis1: int = 0, axis2: int = 1, dtype: Incomplete | None = None): ...
def meshgrid(*xi, **kwargs):
    """This currently requires copy=True and sparse=False."""
def einsum(subscripts, *operands, **kwargs): ...
def enable_numpy_methods_on_tensor():
    """Adds additional NumPy methods on tf.Tensor class."""
