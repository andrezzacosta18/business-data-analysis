import enum
from _typeshed import Incomplete
from tensorflow.python.framework import constant_op as constant_op, dtypes as dtypes, ops as ops, tensor_shape as tensor_shape
from tensorflow.python.ops import array_ops as array_ops, clip_ops as clip_ops, control_flow_ops as control_flow_ops, linalg_ops as linalg_ops, manip_ops as manip_ops, math_ops as math_ops, sort_ops as sort_ops
from tensorflow.python.ops.numpy_ops import np_arrays as np_arrays, np_dtypes as np_dtypes, np_export as np_export, np_utils as np_utils
from tensorflow.python.util import nest as nest

newaxis: Incomplete

def empty(shape, dtype=...): ...
def empty_like(a, dtype: Incomplete | None = None): ...
def zeros(shape, dtype=...): ...
def zeros_like(a, dtype: Incomplete | None = None): ...
def ones(shape, dtype=...): ...
def ones_like(a, dtype: Incomplete | None = None): ...
def eye(N, M: Incomplete | None = None, k: int = 0, dtype=...): ...
def identity(n, dtype=...): ...
def full(shape, fill_value, dtype: Incomplete | None = None): ...
def full_like(a, fill_value, dtype: Incomplete | None = None, order: str = 'K', subok: bool = True, shape: Incomplete | None = None):
    """order, subok and shape arguments mustn't be changed."""
def array(val, dtype: Incomplete | None = None, copy: bool = True, ndmin: int = 0):
    """Since Tensors are immutable, a copy is made only if val is placed on a

  different device than the current one. Even if `copy` is False, a new Tensor
  may need to be built to satisfy `dtype` and `ndim`. This is used only if `val`
  is an ndarray or a Tensor.
  """
def asarray(a, dtype: Incomplete | None = None): ...
def asanyarray(a, dtype: Incomplete | None = None): ...
def ascontiguousarray(a, dtype: Incomplete | None = None): ...
def arange(start, stop: Incomplete | None = None, step: int = 1, dtype: Incomplete | None = None):
    """Returns `step`-separated values in the range [start, stop).

  Args:
    start: Start of the interval. Included in the range.
    stop: End of the interval. If not specified, `start` is treated as 0 and
      `start` value is used as `stop`. If specified, it is not included in the
      range if `step` is integer. When `step` is floating point, it may or may
      not be included.
    step: The difference between 2 consecutive values in the output range. It is
      recommended to use `linspace` instead of using non-integer values for
      `step`.
    dtype: Optional. Type of the resulting ndarray. Could be a python type, a
      NumPy type or a TensorFlow `DType`. If not provided, the largest type of
      `start`, `stop`, `step` is used.

  Raises:
    ValueError: If step is zero.
  """
def diag(v, k: int = 0):
    """Raises an error if input is not 1- or 2-d."""
def diagonal(a, offset: int = 0, axis1: int = 0, axis2: int = 1): ...
def diagflat(v, k: int = 0): ...
def all(a, axis: Incomplete | None = None, keepdims: Incomplete | None = None): ...
def any(a, axis: Incomplete | None = None, keepdims: Incomplete | None = None): ...
def compress(condition, a, axis: Incomplete | None = None): ...
def copy(a): ...
def cumprod(a, axis: Incomplete | None = None, dtype: Incomplete | None = None): ...
def cumsum(a, axis: Incomplete | None = None, dtype: Incomplete | None = None): ...
def imag(val): ...
def size(x, axis: Incomplete | None = None): ...
def sum(a, axis: Incomplete | None = None, dtype: Incomplete | None = None, keepdims: Incomplete | None = None): ...
def prod(a, axis: Incomplete | None = None, dtype: Incomplete | None = None, keepdims: Incomplete | None = None): ...
def mean(a, axis: Incomplete | None = None, dtype: Incomplete | None = None, out: Incomplete | None = None, keepdims: Incomplete | None = None): ...
def amax(a, axis: Incomplete | None = None, out: Incomplete | None = None, keepdims: Incomplete | None = None): ...
def amin(a, axis: Incomplete | None = None, out: Incomplete | None = None, keepdims: Incomplete | None = None): ...
def var(a, axis: Incomplete | None = None, dtype: Incomplete | None = None, out: Incomplete | None = None, ddof: int = 0, keepdims: Incomplete | None = None): ...
def std(a, axis: Incomplete | None = None, keepdims: Incomplete | None = None): ...
def ravel(a): ...
def real(val): ...
def repeat(a, repeats, axis: Incomplete | None = None): ...
def around(a, decimals: int = 0): ...
def reshape(a, newshape, order: str = 'C'):
    """order argument can only b 'C' or 'F'."""
def expand_dims(a, axis): ...
def squeeze(a, axis: Incomplete | None = None): ...
def transpose(a, axes: Incomplete | None = None): ...
def swapaxes(a, axis1, axis2): ...
def moveaxis(a, source, destination):
    """Raises ValueError if source, destination not in (-ndim(a), ndim(a))."""
def pad(array, pad_width, mode, **kwargs):
    """Only supports modes 'constant', 'reflect' and 'symmetric' currently."""
def take(a, indices, axis: Incomplete | None = None, out: Incomplete | None = None, mode: str = 'clip'):
    """out argument is not supported, and default mode is clip."""
def where(condition, x: Incomplete | None = None, y: Incomplete | None = None):
    """Raises ValueError if exactly one of x or y is not None."""
def select(condlist, choicelist, default: int = 0): ...
def shape(a): ...
def ndim(a): ...
def isscalar(num): ...
def split(ary, indices_or_sections, axis: int = 0): ...

vsplit: Incomplete
hsplit: Incomplete
dsplit: Incomplete

def broadcast_to(array, shape): ...
def stack(arrays, axis: int = 0): ...
def hstack(tup): ...
def vstack(tup): ...
def dstack(tup): ...
def atleast_1d(*arys): ...
def atleast_2d(*arys): ...
def atleast_3d(*arys): ...
def nonzero(a): ...
def diag_indices(n, ndim: int = 2): ...
def tri(N, M: Incomplete | None = None, k: int = 0, dtype: Incomplete | None = None): ...
def tril(m, k: int = 0): ...
def triu(m, k: int = 0): ...
def flip(m, axis: Incomplete | None = None): ...
def flipud(m): ...
def fliplr(m): ...
def roll(a, shift, axis: Incomplete | None = None): ...
def rot90(m, k: int = 1, axes=(0, 1)): ...
def vander(x, N: Incomplete | None = None, increasing: bool = False): ...
def ix_(*args): ...
def broadcast_arrays(*args, **kwargs): ...
def sign(x, out: Incomplete | None = None, where: Incomplete | None = None, **kwargs): ...
def take_along_axis(arr, indices, axis): ...

class _UpdateMethod(enum.Enum):
    UPDATE: int
    ADD: int
    MIN: int
    MAX: int
