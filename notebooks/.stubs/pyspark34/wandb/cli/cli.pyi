import click
from _typeshed import Incomplete
from click.exceptions import ClickException
from wandb import Config as Config, Error as Error, env as env, util as util, wandb_agent as wandb_agent, wandb_sdk as wandb_sdk
from wandb.apis import InternalApi as InternalApi, PublicApi as PublicApi
from wandb.integration.magic import magic_install as magic_install
from wandb.sdk.artifacts.artifacts_cache import get_artifacts_cache as get_artifacts_cache
from wandb.sdk.launch.errors import ExecutionError as ExecutionError, LaunchError as LaunchError
from wandb.sdk.launch.sweeps.scheduler import Scheduler as Scheduler
from wandb.sdk.lib import filesystem as filesystem
from wandb.sdk.lib.wburls import wburls as wburls
from wandb.sync import SyncManager as SyncManager, TMPDIR as TMPDIR, get_run_from_path as get_run_from_path, get_runs as get_runs

logger: Incomplete
CONTEXT: Incomplete
RUN_CONTEXT: Incomplete

def cli_unsupported(argument) -> None: ...

class ClickWandbException(ClickException):
    def format_message(self): ...

def display_error(func):
    """Function decorator for catching common errors and re-raising as wandb.Error."""
def prompt_for_project(ctx, entity):
    """Ask the user for a project, creating one if necessary."""

class RunGroup(click.Group):
    def get_command(self, ctx, cmd_name): ...

def cli(ctx) -> None: ...
def projects(entity, display: bool = True): ...
def login(key, host, cloud, relogin, anonymously, no_offline: bool = False) -> None: ...
def service(sock_port: Incomplete | None = None, port_filename: Incomplete | None = None, address: Incomplete | None = None, pid: Incomplete | None = None, debug: bool = False, serve_sock: bool = False) -> None: ...
def init(ctx, project, entity, reset, mode) -> None: ...
def sync(ctx, path: Incomplete | None = None, view: Incomplete | None = None, verbose: Incomplete | None = None, run_id: Incomplete | None = None, project: Incomplete | None = None, entity: Incomplete | None = None, sync_tensorboard: Incomplete | None = None, include_globs: Incomplete | None = None, exclude_globs: Incomplete | None = None, include_online: Incomplete | None = None, include_offline: Incomplete | None = None, include_synced: Incomplete | None = None, mark_synced: Incomplete | None = None, sync_all: Incomplete | None = None, ignore: Incomplete | None = None, show: Incomplete | None = None, clean: Incomplete | None = None, clean_old_hours: int = 24, clean_force: Incomplete | None = None, append: Incomplete | None = None): ...
def sweep(ctx, project, entity, controller, verbose, name, program, settings, update, stop, cancel, pause, resume, config_yaml_or_sweep_id): ...
def launch_sweep(ctx, project, entity, queue, config, resume_id): ...
def launch(uri, job, entry_point, git_version, name, resource, entity, project, docker_image, config, queue, run_async, resource_args, build, repository, project_queue, dockerfile) -> None:
    """Start a W&B run from the given URI.

    The URI can bea wandb URI, a GitHub repo uri, or a local path). In the case of a
    wandb URI the arguments used in the original run will be used by default. These
    arguments can be overridden using the args option, or specifying those arguments in
    the config's 'overrides' key, 'args' field as a list of strings.

    Running `wandb launch [URI]` will launch the run directly. To add the run to a
    queue, run `wandb launch [URI] --queue [optional queuename]`.
    """
def launch_agent(ctx, project: Incomplete | None = None, entity: Incomplete | None = None, queues: Incomplete | None = None, max_jobs: Incomplete | None = None, config: Incomplete | None = None, url: Incomplete | None = None) -> None: ...
def agent(ctx, project, entity, count, sweep_id) -> None: ...
def scheduler(ctx, sweep_id) -> None: ...
def job() -> None: ...
def describe(job) -> None: ...
def create(path, project, entity, name, job_type, description, aliases, entrypoint, git_hash, runtime) -> None:
    """Create a job from a source, without a wandb run.

    Jobs can be of three types, git, code, or image.

    git: A git source, with an entrypoint either in the path or provided explicitly pointing to the main python executable.
    code: A code path, containing a requirements.txt file.
    image: A docker image.
    """
def controller(verbose, sweep_id) -> None: ...
def docker_run(ctx, docker_run_args) -> None:
    """Wrap `docker run` and adds WANDB_API_KEY and WANDB_DOCKER environment variables.

    This will also set the runtime to nvidia if the nvidia-docker executable is present
    on the system and --runtime wasn't set.

    See `docker run --help` for more details.
    """
def docker(ctx, docker_run_args, docker_image, nvidia, digest, jupyter, dir, no_dir, shell, port, cmd, no_tty) -> None:
    '''Run your code in a docker container.

    W&B docker lets you run your code in a docker image ensuring wandb is configured. It
    adds the WANDB_DOCKER and WANDB_API_KEY environment variables to your container and
    mounts the current directory in /app by default.  You can pass additional args which
    will be added to `docker run` before the image name is declared, we\'ll choose a
    default image for you if one isn\'t passed:

    ```sh
    wandb docker -v /mnt/dataset:/app/data
    wandb docker gcr.io/kubeflow-images-public/tensorflow-1.12.0-notebook-cpu:v0.4.0 --jupyter
    wandb docker wandb/deepo:keras-gpu --no-tty --cmd "python train.py --epochs=5"
    ```

    By default, we override the entrypoint to check for the existence of wandb and
    install it if not present.  If you pass the --jupyter flag we will ensure jupyter is
    installed and start jupyter lab on port 8888.  If we detect nvidia-docker on your
    system we will use the nvidia runtime.  If you just want wandb to set environment
    variable to an existing docker run command, see the wandb docker-run command.
    '''
def local(ctx, *args, **kwargs) -> None: ...
def server() -> None: ...
def start(ctx, port, env, daemon, upgrade, edge) -> None: ...
def stop() -> None: ...
def artifact() -> None: ...
def put(path, name, description, type, alias, run_id, resume) -> None: ...
def get(path, root, type) -> None: ...
def ls(path, type) -> None: ...
def cache() -> None: ...
def cleanup(target_size, remove_temp) -> None: ...
def pull(run, project, entity) -> None: ...
def restore(ctx, run, no_git, branch, project, entity): ...
def magic(ctx, program, args) -> None: ...
def online() -> None: ...
def offline() -> None: ...
def on(ctx) -> None: ...
def off(ctx) -> None: ...
def status(settings) -> None: ...
def disabled(service) -> None: ...
def enabled(service) -> None: ...
def gc(args) -> None: ...
def verify(host) -> None: ...
def importer() -> None: ...
def mlflow(mlflow_tracking_uri, target_entity, target_project) -> None: ...
