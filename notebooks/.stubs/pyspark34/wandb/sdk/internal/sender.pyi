import traceback
from _typeshed import Incomplete
from queue import Queue
from typing import Any, Dict, Literal, Type
from wandb import util as util
from wandb.errors import CommError as CommError, UsageError as UsageError
from wandb.errors.util import ProtobufErrorHandler as ProtobufErrorHandler
from wandb.filesync.dir_watcher import DirWatcher as DirWatcher
from wandb.proto import wandb_internal_pb2 as wandb_internal_pb2
from wandb.proto.wandb_internal_pb2 import ArtifactManifest as ArtifactManifest, ArtifactRecord as ArtifactRecord, HttpResponse as HttpResponse, LocalInfo as LocalInfo, Record as Record, Result as Result, RunExitResult as RunExitResult, RunRecord as RunRecord, SummaryRecord as SummaryRecord
from wandb.sdk.artifacts.artifact_saver import ArtifactSaver as ArtifactSaver
from wandb.sdk.interface import interface as interface
from wandb.sdk.interface.interface_queue import InterfaceQueue as InterfaceQueue
from wandb.sdk.internal import context as context, datastore as datastore, file_stream as file_stream, internal_api as internal_api, job_builder as job_builder, update as update
from wandb.sdk.internal.file_pusher import FilePusher as FilePusher
from wandb.sdk.internal.job_builder import JobBuilder as JobBuilder
from wandb.sdk.internal.settings_static import SettingsStatic as SettingsStatic
from wandb.sdk.lib import config_util as config_util, filenames as filenames, filesystem as filesystem, printer as printer, proto_util as proto_util, redirect as redirect, telemetry as telemetry, tracelog as tracelog
from wandb.sdk.lib.mailbox import ContextCancelledError as ContextCancelledError
from wandb.sdk.lib.proto_util import message_to_dict as message_to_dict

StreamLiterals: Incomplete
logger: Incomplete
DictWithValues: Incomplete
DictNoValues: Incomplete

class ResumeState:
    resumed: bool
    step: int
    history: int
    events: int
    output: int
    runtime: float
    wandb_runtime: int | None
    summary: Dict[str, Any] | None
    config: Dict[str, Any] | None
    def __init__(self) -> None: ...

class _OutputRawStream:
    def __init__(self, stream: str, sm: SendManager) -> None: ...
    def start(self) -> None: ...

class SendManager:
    UPDATE_CONFIG_TIME: int
    UPDATE_STATUS_TIME: int
    def __init__(self, settings: SettingsStatic, record_q: Queue[Record], result_q: Queue[Result], interface: InterfaceQueue, context_keeper: context.ContextKeeper) -> None: ...
    @classmethod
    def setup(cls, root_dir: str, resume: None | bool | str) -> SendManager:
        """Set up a standalone SendManager.

        Currently, we're using this primarily for `sync.py`.
        """
    def __len__(self) -> int: ...
    def __enter__(self) -> SendManager: ...
    def __exit__(self, exc_type: Type[BaseException] | None, exc_value: BaseException | None, exc_traceback: traceback.TracebackException | None) -> Literal[False]: ...
    def retry_callback(self, status: int, response_text: str) -> None: ...
    def send(self, record: Record) -> None: ...
    def send_preempting(self, _: Record) -> None: ...
    def send_request_sender_mark(self, _: Record) -> None: ...
    def send_request(self, record: Record) -> None: ...
    def send_request_sender_read(self, record: Record) -> None: ...
    def send_request_check_version(self, record: Record) -> None: ...
    def send_request_stop_status(self, record: Record) -> None: ...
    def debounce(self, final: bool = False) -> None: ...
    def send_request_network_status(self, record: Record) -> None: ...
    def send_request_login(self, record: Record) -> None: ...
    def send_exit(self, record: Record) -> None: ...
    def send_final(self, record: Record) -> None: ...
    def send_request_status_report(self, record: Record) -> None: ...
    def send_request_defer(self, record: Record) -> None: ...
    def send_request_poll_exit(self, record: Record) -> None: ...
    def send_request_server_info(self, record: Record) -> None: ...
    def send_request_job_info(self, record: Record) -> None:
        """Respond to a request for a job link."""
    def send_run(self, record: Record, file_dir: str | None = None) -> None: ...
    def send_history(self, record: Record) -> None: ...
    def send_summary(self, record: Record) -> None: ...
    def send_request_summary_record(self, record: Record) -> None: ...
    def send_stats(self, record: Record) -> None: ...
    def send_output(self, record: Record) -> None: ...
    def send_output_raw(self, record: Record) -> None: ...
    def send_config(self, record: Record) -> None: ...
    def send_metric(self, record: Record) -> None: ...
    def send_telemetry(self, record: Record) -> None: ...
    def send_request_telemetry_record(self, record: Record) -> None: ...
    def send_files(self, record: Record) -> None: ...
    def send_header(self, record: Record) -> None: ...
    def send_footer(self, record: Record) -> None: ...
    def send_tbrecord(self, record: Record) -> None: ...
    def send_link_artifact(self, record: Record) -> None: ...
    def send_use_artifact(self, record: Record) -> None:
        """Pretend to send a used artifact.

        This function doesn't actually send anything, it is just used internally.
        """
    def send_request_log_artifact(self, record: Record) -> None: ...
    def send_artifact(self, record: Record) -> None: ...
    def send_alert(self, record: Record) -> None: ...
    def finish(self) -> None: ...
    def get_viewer_server_info(self) -> None: ...
    def get_viewer_info(self) -> Dict[str, Any]: ...
    def get_server_info(self) -> Dict[str, Any]: ...
    def get_local_info(self) -> LocalInfo:
        """Queries the server to get the local version information.

        First, we perform an introspection, if it returns empty we deduce that the
        docker image is out-of-date. Otherwise, we use the returned values to deduce the
        state of the local server.
        """
    def __next__(self) -> Record: ...
    next = __next__
