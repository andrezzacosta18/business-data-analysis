from _typeshed import Incomplete

class Transforms:
    def __init__(self) -> None: ...
    def deriv2_inverse(self, phi, args): ...
    def derivk_inverse(self, k, phi, theta) -> None: ...

class TransfFrank(Transforms):
    def evaluate(self, t, theta): ...
    def inverse(self, phi, theta): ...
    def deriv(self, t, theta): ...
    def deriv2(self, t, theta): ...
    def deriv2_inverse(self, phi, theta): ...
    def deriv3_inverse(self, phi, theta): ...
    def deriv4_inverse(self, phi, theta): ...
    def is_completly_monotonic(self, theta): ...

class TransfClayton(Transforms):
    def evaluate(self, t, theta): ...
    def inverse(self, phi, theta): ...
    def deriv(self, t, theta): ...
    def deriv2(self, t, theta): ...
    def deriv_inverse(self, phi, theta): ...
    def deriv2_inverse(self, phi, theta): ...
    def deriv3_inverse(self, phi, theta): ...
    def deriv4_inverse(self, phi, theta): ...
    def derivk_inverse(self, k, phi, theta): ...
    def is_completly_monotonic(self, theta): ...

class TransfGumbel(Transforms):
    """
    requires theta >=1
    """
    def evaluate(self, t, theta): ...
    def inverse(self, phi, theta): ...
    def deriv(self, t, theta): ...
    def deriv2(self, t, theta): ...
    def deriv2_inverse(self, phi, theta): ...
    def deriv3_inverse(self, phi, theta): ...
    def deriv4_inverse(self, phi, theta): ...
    def is_completly_monotonic(self, theta): ...

class TransfIndep(Transforms):
    def evaluate(self, t, *args): ...
    def inverse(self, phi, *args): ...
    def deriv(self, t, *args): ...
    def deriv2(self, t, *args): ...
    def deriv2_inverse(self, phi, *args): ...
    def deriv3_inverse(self, phi, *args): ...
    def deriv4_inverse(self, phi, *args): ...

class _TransfPower(Transforms):
    """generic multivariate Archimedean copula with additional power transforms

    Nelson p.144, equ. 4.5.2

    experimental, not yet tested and used
    """
    transform: Incomplete
    def __init__(self, transform) -> None: ...
    def evaluate(self, t, alpha, beta, *tr_args): ...
    def inverse(self, phi, alpha, beta, *tr_args): ...
