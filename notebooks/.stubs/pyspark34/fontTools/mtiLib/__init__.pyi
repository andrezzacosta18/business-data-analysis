from _typeshed import Incomplete
from collections.abc import Generator
from fontTools import ttLib as ttLib
from fontTools.feaLib.lookupDebugInfo import LOOKUP_DEBUG_ENV_VAR as LOOKUP_DEBUG_ENV_VAR, LOOKUP_DEBUG_INFO_KEY as LOOKUP_DEBUG_INFO_KEY
from fontTools.ttLib import newTable as newTable
from fontTools.ttLib.tables._c_m_a_p import cmap_classes as cmap_classes
from fontTools.ttLib.tables.otBase import ValueRecord as ValueRecord, valueRecordFormatDict as valueRecordFormatDict

class MtiLibError(Exception): ...
class ReferenceNotFoundError(MtiLibError): ...
class FeatureNotFoundError(ReferenceNotFoundError): ...
class LookupNotFoundError(ReferenceNotFoundError): ...

log: Incomplete

def makeGlyph(s): ...
def makeGlyphs(l): ...
def mapLookup(sym, mapping): ...
def mapFeature(sym, mapping): ...
def setReference(mapper, mapping, sym, setter, collection, key): ...

class DeferredMapping(dict):
    def __init__(self) -> None: ...
    def addDeferredMapping(self, setter, sym, e) -> None: ...
    def applyDeferredMappings(self) -> None: ...

def parseScriptList(lines, featureMap: Incomplete | None = None): ...
def parseFeatureList(lines, lookupMap: Incomplete | None = None, featureMap: Incomplete | None = None): ...
def parseLookupFlags(lines): ...
def parseSingleSubst(lines, font, _lookupMap: Incomplete | None = None): ...
def parseMultiple(lines, font, _lookupMap: Incomplete | None = None): ...
def parseAlternate(lines, font, _lookupMap: Incomplete | None = None): ...
def parseLigature(lines, font, _lookupMap: Incomplete | None = None): ...
def parseSinglePos(lines, font, _lookupMap: Incomplete | None = None): ...
def parsePair(lines, font, _lookupMap: Incomplete | None = None): ...
def parseKernset(lines, font, _lookupMap: Incomplete | None = None): ...
def makeAnchor(data, klass=...): ...
def parseCursive(lines, font, _lookupMap: Incomplete | None = None): ...
def makeMarkRecords(data, coverage, c): ...
def makeBaseRecords(data, coverage, c, classCount): ...
def makeLigatureRecords(data, coverage, c, classCount): ...
def parseMarkToSomething(lines, font, c): ...

class MarkHelper:
    def __init__(self) -> None: ...

class MarkToBaseHelper(MarkHelper):
    Mark: str
    Base: str
    Type: Incomplete

class MarkToMarkHelper(MarkHelper):
    Mark: str
    Base: str
    Type: Incomplete

class MarkToLigatureHelper(MarkHelper):
    Mark: str
    Base: str
    Type: Incomplete

def parseMarkToBase(lines, font, _lookupMap: Incomplete | None = None): ...
def parseMarkToMark(lines, font, _lookupMap: Incomplete | None = None): ...
def parseMarkToLigature(lines, font, _lookupMap: Incomplete | None = None): ...
def stripSplitComma(line): ...
def intSplitComma(line): ...

class ContextHelper:
    Typ: Incomplete
    Type: Incomplete
    Chain: Incomplete
    ChainTyp: Incomplete
    InputIdx: Incomplete
    DataLen: Incomplete
    LookupRecord: Incomplete
    Coverage: Incomplete
    ContextData: Incomplete
    SetContextData: Incomplete
    RuleData: Incomplete
    SetRuleData: Incomplete
    Rule: Incomplete
    RuleCount: Incomplete
    RuleSet: Incomplete
    RuleSetCount: Incomplete
    Intersect: Incomplete
    ClassDef: Incomplete
    ClassDefIndex: Incomplete
    Input: Incomplete
    def __init__(self, klassName, Format) -> None: ...

def parseLookupRecords(items, klassName, lookupMap: Incomplete | None = None): ...
def makeClassDef(classDefs, font, klass=...): ...
def parseClassDef(lines, font, klass=...): ...
def makeCoverage(glyphs, font, klass=...): ...
def parseCoverage(lines, font, klass=...): ...
def bucketizeRules(self, c, rules, bucketKeys) -> None: ...
def parseContext(lines, font, Type, lookupMap: Incomplete | None = None): ...
def parseContextSubst(lines, font, lookupMap: Incomplete | None = None): ...
def parseContextPos(lines, font, lookupMap: Incomplete | None = None): ...
def parseChainedSubst(lines, font, lookupMap: Incomplete | None = None): ...
def parseChainedPos(lines, font, lookupMap: Incomplete | None = None): ...
def parseReverseChainedSubst(lines, font, _lookupMap: Incomplete | None = None): ...
def parseLookup(lines, tableTag, font, lookupMap: Incomplete | None = None): ...
def parseGSUBGPOS(lines, font, tableTag): ...
def parseGSUB(lines, font): ...
def parseGPOS(lines, font): ...
def parseAttachList(lines, font): ...
def parseCaretList(lines, font): ...
def makeMarkFilteringSets(sets, font): ...
def parseMarkFilteringSets(lines, font): ...
def parseGDEF(lines, font): ...
def parseCmap(lines, font): ...
def parseCmapId(lines, field): ...
def parseTable(lines, font, tableTag: Incomplete | None = None): ...

class Tokenizer:
    filename: Incomplete
    lines: Incomplete
    line: str
    lineno: int
    stoppers: Incomplete
    buffer: Incomplete
    def __init__(self, f) -> None: ...
    def __iter__(self): ...
    def __next__(self): ...
    def next(self): ...
    def peek(self): ...
    def peeks(self): ...
    def between(self, tag) -> Generator[None, None, None]: ...
    def until(self, tags) -> Generator[None, None, None]: ...
    def expect(self, s): ...
    def expectendswith(self, s): ...

def build(f, font, tableTag: Incomplete | None = None):
    '''Convert a Monotype font layout file to an OpenType layout object

    A font object must be passed, but this may be a "dummy" font; it is only
    used for sorting glyph sets when making coverage tables and to hold the
    OpenType layout table while it is being built.

    Args:
            f: A file object.
            font (TTFont): A font object.
            tableTag (string): If provided, asserts that the file contains data for the
                    given OpenType table.

    Returns:
            An object representing the table. (e.g. ``table_G_S_U_B_``)
    '''
def main(args: Incomplete | None = None, font: Incomplete | None = None) -> None:
    """Convert a FontDame OTL file to TTX XML

    Writes XML output to stdout.

    Args:
            args: Command line arguments (``--font``, ``--table``, input files).
    """
