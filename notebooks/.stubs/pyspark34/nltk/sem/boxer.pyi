from _typeshed import Incomplete
from nltk.internals import find_binary as find_binary
from nltk.sem.drt import DRS as DRS, DrtApplicationExpression as DrtApplicationExpression, DrtEqualityExpression as DrtEqualityExpression, DrtNegatedExpression as DrtNegatedExpression, DrtOrExpression as DrtOrExpression, DrtParser as DrtParser, DrtProposition as DrtProposition, DrtTokens as DrtTokens, DrtVariableExpression as DrtVariableExpression
from nltk.sem.logic import ExpectedMoreTokensException as ExpectedMoreTokensException, LogicalExpressionException as LogicalExpressionException, UnexpectedTokenException as UnexpectedTokenException, Variable as Variable

class Boxer:
    """
    This class is an interface to Johan Bos's program Boxer, a wide-coverage
    semantic parser that produces Discourse Representation Structures (DRSs).
    """
    def __init__(self, boxer_drs_interpreter: Incomplete | None = None, elimeq: bool = False, bin_dir: Incomplete | None = None, verbose: bool = False, resolve: bool = True) -> None:
        """
        :param boxer_drs_interpreter: A class that converts from the
            ``AbstractBoxerDrs`` object hierarchy to a different object.  The
            default is ``NltkDrtBoxerDrsInterpreter``, which converts to the NLTK
            DRT hierarchy.
        :param elimeq: When set to true, Boxer removes all equalities from the
            DRSs and discourse referents standing in the equality relation are
            unified, but only if this can be done in a meaning-preserving manner.
        :param resolve: When set to true, Boxer will resolve all anaphoric DRSs and perform merge-reduction.
            Resolution follows Van der Sandt's theory of binding and accommodation.
        """
    def set_bin_dir(self, bin_dir, verbose: bool = False) -> None: ...
    def interpret(self, input, discourse_id: Incomplete | None = None, question: bool = False, verbose: bool = False):
        """
        Use Boxer to give a first order representation.

        :param input: str Input sentence to parse
        :param occur_index: bool Should predicates be occurrence indexed?
        :param discourse_id: str An identifier to be inserted to each occurrence-indexed predicate.
        :return: ``drt.DrtExpression``
        """
    def interpret_multi(self, input, discourse_id: Incomplete | None = None, question: bool = False, verbose: bool = False):
        """
        Use Boxer to give a first order representation.

        :param input: list of str Input sentences to parse as a single discourse
        :param occur_index: bool Should predicates be occurrence indexed?
        :param discourse_id: str An identifier to be inserted to each occurrence-indexed predicate.
        :return: ``drt.DrtExpression``
        """
    def interpret_sents(self, inputs, discourse_ids: Incomplete | None = None, question: bool = False, verbose: bool = False):
        """
        Use Boxer to give a first order representation.

        :param inputs: list of str Input sentences to parse as individual discourses
        :param occur_index: bool Should predicates be occurrence indexed?
        :param discourse_ids: list of str Identifiers to be inserted to each occurrence-indexed predicate.
        :return: list of ``drt.DrtExpression``
        """
    def interpret_multi_sents(self, inputs, discourse_ids: Incomplete | None = None, question: bool = False, verbose: bool = False):
        """
        Use Boxer to give a first order representation.

        :param inputs: list of list of str Input discourses to parse
        :param occur_index: bool Should predicates be occurrence indexed?
        :param discourse_ids: list of str Identifiers to be inserted to each occurrence-indexed predicate.
        :return: ``drt.DrtExpression``
        """

class BoxerOutputDrsParser(DrtParser):
    discourse_id: Incomplete
    sentence_id_offset: Incomplete
    quote_chars: Incomplete
    def __init__(self, discourse_id: Incomplete | None = None) -> None:
        """
        This class is used to parse the Prolog DRS output from Boxer into a
        hierarchy of python objects.
        """
    def parse(self, data, signature: Incomplete | None = None): ...
    def get_all_symbols(self): ...
    def handle(self, tok, context): ...
    def attempt_adjuncts(self, expression, context): ...
    def parse_condition(self, indices):
        """
        Parse a DRS condition

        :return: list of ``DrtExpression``
        """
    def handle_drs(self, tok): ...
    def handle_condition(self, tok, indices):
        """
        Handle a DRS condition

        :param indices: list of int
        :return: list of ``DrtExpression``
        """
    def parse_drs(self): ...
    def parse_variable(self): ...
    def parse_index(self): ...

class BoxerDrsParser(DrtParser):
    """
    Reparse the str form of subclasses of ``AbstractBoxerDrs``
    """
    discourse_id: Incomplete
    def __init__(self, discourse_id: Incomplete | None = None) -> None: ...
    def get_all_symbols(self): ...
    def attempt_adjuncts(self, expression, context): ...
    def handle(self, tok, context): ...
    def nullableIntToken(self): ...
    def get_next_token_variable(self, description): ...

class AbstractBoxerDrs:
    def variables(self):
        """
        :return: (set<variables>, set<events>, set<propositions>)
        """
    def variable_types(self): ...
    def atoms(self): ...
    def clean(self): ...
    def renumber_sentences(self, f): ...
    def __hash__(self): ...

class BoxerDrs(AbstractBoxerDrs):
    refs: Incomplete
    conds: Incomplete
    consequent: Incomplete
    def __init__(self, refs, conds, consequent: Incomplete | None = None) -> None: ...
    def atoms(self): ...
    def clean(self): ...
    def renumber_sentences(self, f): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    __hash__: Incomplete

class BoxerNot(AbstractBoxerDrs):
    drs: Incomplete
    def __init__(self, drs) -> None: ...
    def atoms(self): ...
    def clean(self): ...
    def renumber_sentences(self, f): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    __hash__: Incomplete

class BoxerIndexed(AbstractBoxerDrs):
    discourse_id: Incomplete
    sent_index: Incomplete
    word_indices: Incomplete
    def __init__(self, discourse_id, sent_index, word_indices) -> None: ...
    def atoms(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    __hash__: Incomplete

class BoxerPred(BoxerIndexed):
    var: Incomplete
    name: Incomplete
    pos: Incomplete
    sense: Incomplete
    def __init__(self, discourse_id, sent_index, word_indices, var, name, pos, sense) -> None: ...
    def change_var(self, var): ...
    def clean(self): ...
    def renumber_sentences(self, f): ...
    def __iter__(self): ...

class BoxerNamed(BoxerIndexed):
    var: Incomplete
    name: Incomplete
    type: Incomplete
    sense: Incomplete
    def __init__(self, discourse_id, sent_index, word_indices, var, name, type, sense) -> None: ...
    def change_var(self, var): ...
    def clean(self): ...
    def renumber_sentences(self, f): ...
    def __iter__(self): ...

class BoxerRel(BoxerIndexed):
    var1: Incomplete
    var2: Incomplete
    rel: Incomplete
    sense: Incomplete
    def __init__(self, discourse_id, sent_index, word_indices, var1, var2, rel, sense) -> None: ...
    def clean(self): ...
    def renumber_sentences(self, f): ...
    def __iter__(self): ...

class BoxerProp(BoxerIndexed):
    var: Incomplete
    drs: Incomplete
    def __init__(self, discourse_id, sent_index, word_indices, var, drs) -> None: ...
    def referenced_labels(self): ...
    def atoms(self): ...
    def clean(self): ...
    def renumber_sentences(self, f): ...
    def __iter__(self): ...

class BoxerEq(BoxerIndexed):
    var1: Incomplete
    var2: Incomplete
    def __init__(self, discourse_id, sent_index, word_indices, var1, var2) -> None: ...
    def atoms(self): ...
    def renumber_sentences(self, f): ...
    def __iter__(self): ...

class BoxerCard(BoxerIndexed):
    var: Incomplete
    value: Incomplete
    type: Incomplete
    def __init__(self, discourse_id, sent_index, word_indices, var, value, type) -> None: ...
    def renumber_sentences(self, f): ...
    def __iter__(self): ...

class BoxerOr(BoxerIndexed):
    drs1: Incomplete
    drs2: Incomplete
    def __init__(self, discourse_id, sent_index, word_indices, drs1, drs2) -> None: ...
    def atoms(self): ...
    def clean(self): ...
    def renumber_sentences(self, f): ...
    def __iter__(self): ...

class BoxerWhq(BoxerIndexed):
    ans_types: Incomplete
    drs1: Incomplete
    variable: Incomplete
    drs2: Incomplete
    def __init__(self, discourse_id, sent_index, word_indices, ans_types, drs1, variable, drs2) -> None: ...
    def atoms(self): ...
    def clean(self): ...
    def renumber_sentences(self, f): ...
    def __iter__(self): ...

class PassthroughBoxerDrsInterpreter:
    def interpret(self, ex): ...

class NltkDrtBoxerDrsInterpreter:
    def __init__(self, occur_index: bool = False) -> None: ...
    def interpret(self, ex):
        """
        :param ex: ``AbstractBoxerDrs``
        :return: ``DrtExpression``
        """

class UnparseableInputException(Exception): ...
