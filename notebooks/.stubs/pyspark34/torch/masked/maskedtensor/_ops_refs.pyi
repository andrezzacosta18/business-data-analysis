import torch
from .binary import NATIVE_BINARY_FNS as NATIVE_BINARY_FNS, NATIVE_INPLACE_BINARY_FNS as NATIVE_INPLACE_BINARY_FNS
from .core import MaskedTensor as MaskedTensor, is_masked_tensor as is_masked_tensor
from .passthrough import PASSTHROUGH_FNS as PASSTHROUGH_FNS
from .reductions import NATIVE_REDUCE_FNS as NATIVE_REDUCE_FNS, TENSOR_REDUCE_FNS as TENSOR_REDUCE_FNS, TORCH_REDUCE_FNS as TORCH_REDUCE_FNS
from .unary import NATIVE_INPLACE_UNARY_FNS as NATIVE_INPLACE_UNARY_FNS, NATIVE_UNARY_FNS as NATIVE_UNARY_FNS

class _MaskedContiguous(torch.autograd.Function):
    @staticmethod
    def forward(ctx, input): ...
    @staticmethod
    def backward(ctx, grad_output): ...

class _MaskedToDense(torch.autograd.Function):
    @staticmethod
    def forward(ctx, input): ...
    @staticmethod
    def backward(ctx, grad_output): ...

class _MaskedToSparse(torch.autograd.Function):
    @staticmethod
    def forward(ctx, input): ...
    @staticmethod
    def backward(ctx, grad_output): ...

class _MaskedToSparseCsr(torch.autograd.Function):
    @staticmethod
    def forward(ctx, input): ...
    @staticmethod
    def backward(ctx, grad_output): ...

class _MaskedWhere(torch.autograd.Function):
    @staticmethod
    def forward(ctx, cond, self, other): ...
    @staticmethod
    def backward(ctx, grad_output): ...

def register_function_func(ops):
    """
    Used for registering a new __torch_function__ function to MaskedTensor
    Called via _MASKEDTENSOR_FUNCTION_TABLE[func](*args, **kwargs)

    The code to register a new function looks like:

    @register_function_func(list_of_ops)
    def foo(func, *args, **kwargs):
        <implementation>
    """
def register_dispatch_func(aten_ops):
    """
    Used for registering a new __torch_dispatch__ function to MaskedTensor
    Called via _MASKEDTENSOR_DISPATCH_TABLE[func](*args, **kwargs)

    The code to register a new function looks like:

    @register_dispatch_func(list_of_ops)
    def foo(func, *args, **kwargs):
        <implementation>
    """
def stride(func, *args, **kwargs) -> None: ...
def sym_stride(func, *args, **kwargs) -> None: ...
def layout(func, *args, **kwargs): ...
def is_contiguous(func, *args, **kwargs): ...
def is_strides_like_format(func, *args, **kwargs): ...
def is_non_overlapping_and_dense(func, *args, **kwargs): ...
def contiguous(func, *args, **kwargs): ...
def new_empty_strided(func, *args, **kwargs): ...
def ones_like(func, *args, **kwargs): ...
def copy_(func, *args, **kwargs): ...
def where(func, *args, **kwargs): ...
def to_sparse(func, *args, **kwargs): ...
def to_sparse_csr(func, *args, **kwargs): ...
def is_same_size(func, *args, **kwargs): ...
