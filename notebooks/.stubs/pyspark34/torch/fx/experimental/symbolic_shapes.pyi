import sympy
import torch
from _typeshed import Incomplete
from collections.abc import Generator
from sympy.printing.str import StrPrinter
from torch._guards import Source
from typing import List

__all__ = ['has_symbolic_sizes_strides', 'create_contiguous', 'ShapeEnv', 'SymDispatchMode', 'FloorDiv', 'guard_int', 'guard_float', 'guard_scalar', 'wrap_node', 'method_to_operator', 'hint_int', 'SYMPY_INTERP']

class GuardOnDataDependentSymNode(RuntimeError): ...

class SymDispatchMode:
    def __sym_dispatch__(self, func, types, args, kwargs) -> None: ...
    inner: Incomplete
    def __enter__(self): ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None) -> None: ...

def has_symbolic_sizes_strides(elem): ...
def create_contiguous(shape): ...
def hint_int(a): ...
def guard_scalar(a): ...
def guard_int(a): ...
def guard_float(a): ...

class SymNode:
    """
    This is a type erased SymInt/SymFloat which we use to do actual operations.
    End users don't touch this.  Magic methods are NOT defined on this object.
    """
    shape_env: Incomplete
    pytype: Incomplete
    constant: Incomplete
    def __init__(self, expr, shape_env, pytype, hint: int | float | None, constant: Incomplete | None = None) -> None: ...
    @property
    def expr(self): ...
    @property
    def hint(self): ...
    def require_hint(self): ...
    def is_int(self): ...
    def is_float(self): ...
    def is_bool(self): ...
    def wrap_int(self, num): ...
    def wrap_float(self, num): ...
    def wrap_bool(self, num): ...
    def clone(self): ...
    def str(self): ...
    def add(self, other) -> SymNode: ...
    def sub(self, other) -> SymNode: ...
    def mul(self, other) -> SymNode: ...
    def mod(self, other) -> SymNode: ...
    def pow(self, other) -> SymNode: ...
    def and_(self, other) -> SymNode: ...
    def or_(self, other) -> SymNode: ...
    def truediv(self, other) -> SymNode: ...
    def floordiv(self, other) -> SymNode: ...
    def sym_not(self) -> SymNode: ...
    def eq(self, other) -> SymNode: ...
    def ne(self, other) -> SymNode: ...
    def gt(self, other) -> SymNode: ...
    def lt(self, other) -> SymNode: ...
    def le(self, other) -> SymNode: ...
    def ge(self, other) -> SymNode: ...
    def floor(self) -> SymNode: ...
    def sym_float(self) -> SymNode: ...
    def ceil(self) -> SymNode: ...
    def neg(self) -> SymNode: ...
    def sym_min(self, other) -> SymNode: ...
    def sym_max(self, other) -> SymNode: ...
    def sym_sqrt(self) -> SymNode: ...
    def is_non_overlapping_and_dense_indicator(self, *args) -> SymNode: ...
    def sym_or(self, other): ...
    def sym_and(self, other): ...
    def int_(self): ...
    def guard_int(self, file, line): ...
    def guard_float(self, file, line): ...
    def guard_bool(self, file, line): ...
    def bool_(self): ...

class Pow(sympy.Function):
    @classmethod
    def eval(cls, base, exp): ...

class TrueDiv(sympy.Function):
    @classmethod
    def eval(cls, base, divisor): ...

class FloorDiv(sympy.Function):
    """
        We maintain this so that:
        1. We can use divisibility guards to simplify FloorDiv(a, b) to a / b.
        2. Printing out the expression is nicer (compared to say, representing a//b as (a - a % b) / b)
        """
    nargs: Incomplete
    precedence: int
    is_real: bool
    @property
    def base(self): ...
    @property
    def divisor(self): ...
    @classmethod
    def eval(cls, base, divisor): ...

class IsNonOverlappingAndDenseIndicator(sympy.Function):
    is_integer: bool
    @classmethod
    def eval(cls, *args): ...

def method_to_operator(method): ...

SYMPY_INTERP: Incomplete

def wrap_node(x): ...

class Symbol(sympy.Dummy):
    sources: List[Source]
    stack: str | None
    def __new__(cls, *args, **kwargs): ...

class ShapeGuardPrinter(StrPrinter):
    symbol_to_source: Incomplete
    source_ref: Incomplete
    def __init__(self, symbol_to_source, source_ref) -> None: ...

class ShapeEnv:
    guards: Incomplete
    var_to_val: Incomplete
    replacements: Incomplete
    divisible: Incomplete
    val_to_var: Incomplete
    unbacked_symfloat_counter: Incomplete
    unbacked_symint_counter: Incomplete
    def __init__(self) -> None: ...
    def suppress_guards(self) -> Generator[None, None, None]: ...
    def create_symbolic_sizes_strides_storage_offset(self, ex: torch.Tensor, source: Source):
        """
        Returns a list of symbolic sizes and strides for the given tensor.
        We try our best to express stride in terms of the sizes, so as to not
        introduce new symbolic variables.
        """
    def create_symintnode(self, sym: sympy.Expr, *, hint: int | None): ...
    def create_unbacked_symfloat(self): ...
    def create_unbacked_symint(self): ...
    def create_symbol(self, val: int, source: Source) -> sympy.Expr: ...
    def duck_int(self, val): ...
    def produce_guards(self, placeholders, sources, source_ref=..., *, _simplified: bool = False) -> List[str]: ...
    def evaluate_guards_for_args(self, placeholders, args): ...
    def bind_symbols(self, placeholders, args): ...
    def get_nontrivial_guards(self): ...
    def format_guards(self, verbose: bool = False): ...
    def get_shape_groups(self): ...
    def replace(self, expr: sympy.Expr) -> sympy.Expr: ...
    def simplify(self, expr: sympy.Expr) -> sympy.Expr: ...
    def size_hint(self, expr: sympy.Expr):
        """
        Gets a size hint for a given expression from the underlying shapes we had.
        Does not introduce a guard, so only use this when you can guarantee that
        your code is still valid for arbitrary shapes (such as optimization decisions)
        """
    def evaluate_expr(self, expr: sympy.Expr, hint: Incomplete | None = None):
        """
        Given an expression, evaluates it, adding guards if necessary
        """
