import weakref
from _typeshed import Incomplete
from collections.abc import Generator, MutableMapping
from typing import Dict

__all__ = ['WeakIdRef', 'WeakIdKeyDictionary', 'WeakTensorKeyDictionary']

class WeakIdRef(weakref.ref):
    def __init__(self, key, callback: Incomplete | None = None) -> None: ...
    def __call__(self): ...
    def __hash__(self): ...
    def __eq__(self, other): ...

class WeakIdKeyDictionary(MutableMapping):
    data: Dict[WeakIdRef, object]
    def __init__(self, dict: Incomplete | None = None) -> None: ...
    def __delitem__(self, key) -> None: ...
    def __getitem__(self, key): ...
    def __len__(self) -> int: ...
    def __setitem__(self, key, value) -> None: ...
    def copy(self): ...
    __copy__ = copy
    def __deepcopy__(self, memo): ...
    def get(self, key, default: Incomplete | None = None): ...
    def __contains__(self, key) -> bool: ...
    def items(self) -> Generator[Incomplete, None, None]: ...
    def keys(self) -> Generator[Incomplete, None, None]: ...
    __iter__ = keys
    def values(self) -> Generator[Incomplete, None, None]: ...
    def keyrefs(self):
        """Return a list of weak references to the keys.

        The references are not guaranteed to be 'live' at the time
        they are used, so the result of calling the references needs
        to be checked before being used.  This can be used to avoid
        creating references that will cause the garbage collector to
        keep the keys around longer than needed.

        """
    def popitem(self): ...
    def pop(self, key, *args): ...
    def setdefault(self, key, default: Incomplete | None = None): ...
    def update(self, dict: Incomplete | None = None, **kwargs) -> None: ...
    def __ior__(self, other): ...
    def __or__(self, other): ...
    def __ror__(self, other): ...
    def __eq__(self, other): ...
WeakTensorKeyDictionary = WeakIdKeyDictionary
