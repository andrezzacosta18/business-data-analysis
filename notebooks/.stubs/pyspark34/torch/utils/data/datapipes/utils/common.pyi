from _typeshed import Incomplete
from io import IOBase
from typing import Any, Callable, Dict, Iterable, List, Tuple

__all__ = ['validate_input_col', 'StreamWrapper', 'get_file_binaries_from_pathnames', 'get_file_pathnames_from_root', 'match_masks', 'validate_pathname_binary_tuple']

def validate_input_col(fn: Callable, input_col: int | tuple | list | None):
    '''
    Checks that function used in a callable datapipe works with the input column

    This simply ensures that the number of positional arguments matches the size
    of the input column. The function must not contain any non-default
    keyword-only arguments.

    Examples:
        >>> # xdoctest: +SKIP("Failing on some CI machines")
        >>> def f(a, b, *, c=1):
        >>>     return a + b + c
        >>> def f_def(a, b=1, *, c=1):
        >>>     return a + b + c
        >>> assert validate_input_col(f, [1, 2])
        >>> assert validate_input_col(f_def, 1)
        >>> assert validate_input_col(f_def, [1, 2])

    Notes:
        If the function contains variable positional (`inspect.VAR_POSITIONAL`) arguments,
        for example, f(a, *args), the validator will accept any size of input column
        greater than or equal to the number of positional arguments.
        (in this case, 1).

    Args:
        fn: The function to check.
        input_col: The input column to check.

    Raises:
        ValueError: If the function is not compatible with the input column.
    '''
def match_masks(name: str, masks: str | List[str]) -> bool: ...
def get_file_pathnames_from_root(root: str, masks: str | List[str], recursive: bool = False, abspath: bool = False, non_deterministic: bool = False) -> Iterable[str]: ...
def get_file_binaries_from_pathnames(pathnames: Iterable, mode: str, encoding: str | None = None): ...
def validate_pathname_binary_tuple(data: Tuple[str, IOBase]): ...

class StreamWrapper:
    """
    StreamWrapper is introduced to wrap file handler generated by
    DataPipe operation like `FileOpener`. StreamWrapper would guarantee
    the wrapped file handler is closed when it's out of scope.
    """
    session_streams: Dict[Any, int]
    debug_unclosed_streams: bool
    file_obj: Incomplete
    child_counter: int
    parent_stream: Incomplete
    close_on_last_child: bool
    name: Incomplete
    closed: bool
    def __init__(self, file_obj, parent_stream: Incomplete | None = None, name: Incomplete | None = None) -> None: ...
    @classmethod
    def close_streams(cls, v, depth: int = 0) -> None:
        """
        Traverse structure and attempts to close all found StreamWrappers on best effort basis.
        """
    def __getattr__(self, name): ...
    def close(self, *args, **kwargs) -> None: ...
    def autoclose(self) -> None:
        """
        Close steam if there is no children, or make it to be automatically closed as soon as
        all child streams are closed.
        """
    def __dir__(self): ...
    def __del__(self) -> None: ...
    def __iter__(self): ...
    def __next__(self): ...
