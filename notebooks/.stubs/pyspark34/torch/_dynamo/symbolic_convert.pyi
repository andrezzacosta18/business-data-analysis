import dataclasses
import types
import typing
from . import allowed_functions as allowed_functions, config as config, exc as exc, side_effects as side_effects, skipfiles as skipfiles, variables as variables
from .allowed_functions import is_allowed as is_allowed, is_builtin_callable as is_builtin_callable, is_builtin_constant as is_builtin_constant
from .bytecode_analysis import JUMP_OPNAMES as JUMP_OPNAMES, livevars_analysis as livevars_analysis
from .bytecode_transformation import Instruction as Instruction, cleaned_instructions as cleaned_instructions, create_instruction as create_instruction, create_jump_absolute as create_jump_absolute, is_generator as is_generator, unique_id as unique_id
from .codegen import PyCodegen as PyCodegen
from .exc import BackendCompilerFailed as BackendCompilerFailed, Unsupported as Unsupported, unimplemented as unimplemented
from .guards import GuardBuilder as GuardBuilder
from .output_graph import GraphCompileReason as GraphCompileReason, OutputGraph as OutputGraph, OutputGraphState as OutputGraphState
from .replay_record import DummyModule as DummyModule, ExecutionRecorder as ExecutionRecorder
from .resume_execution import ContinueExecutionCache as ContinueExecutionCache, ReenterWith as ReenterWith
from .source import AttrSource as AttrSource, GetItemSource as GetItemSource, GlobalSource as GlobalSource, GlobalWeakRefSource as GlobalWeakRefSource, LocalInputSource as LocalInputSource, LocalSource as LocalSource
from .utils import counters as counters, graph_break_dup_warning_checker as graph_break_dup_warning_checker, istype as istype, proxy_args_kwargs as proxy_args_kwargs
from .variables.base import MutableLocal as MutableLocal, VariableTracker as VariableTracker, typestr as typestr
from .variables.builder import VariableBuilder as VariableBuilder, wrap_fx_proxy as wrap_fx_proxy
from .variables.builtin import BuiltinVariable as BuiltinVariable
from .variables.constant import ConstantVariable as ConstantVariable, EnumVariable as EnumVariable
from .variables.dicts import ConstDictVariable as ConstDictVariable
from .variables.functions import BaseUserFunctionVariable as BaseUserFunctionVariable, NestedUserFunctionVariable as NestedUserFunctionVariable, UserFunctionVariable as UserFunctionVariable, UserMethodVariable as UserMethodVariable
from .variables.lists import BaseListVariable as BaseListVariable, ListIteratorVariable as ListIteratorVariable, ListVariable as ListVariable, SliceVariable as SliceVariable, TupleVariable as TupleVariable
from .variables.misc import ClosureVariable as ClosureVariable, ContextWrappingVariable as ContextWrappingVariable, GetAttrVariable as GetAttrVariable, GradModeVariable as GradModeVariable, PythonModuleVariable as PythonModuleVariable, UnknownVariable as UnknownVariable, WithExitFunctionVariable as WithExitFunctionVariable
from .variables.nn_module import NNModuleVariable as NNModuleVariable
from .variables.tensor import SymNodeVariable as SymNodeVariable, TensorVariable as TensorVariable, supported_const_comparison_ops as supported_const_comparison_ops, supported_tensor_comparison_ops as supported_tensor_comparison_ops
from .variables.torch import TorchVariable as TorchVariable
from .variables.user_defined import UserDefinedObjectVariable as UserDefinedObjectVariable, UserDefinedVariable as UserDefinedVariable
from _typeshed import Incomplete
from torch._guards import Checkpointable as Checkpointable
from typing import Any, Callable, Dict, List, NamedTuple, Set, Tuple

log: Incomplete

@dataclasses.dataclass
class BlockStackEntry:
    target: Instruction
    stack_index: int | None = ...
    with_context: ContextWrappingVariable = ...
    def can_restore(self): ...
    def resume_fn(self): ...
    def exit(self, tx): ...
    def __init__(self, target, stack_index, with_context) -> None: ...

class InstructionTranslatorGraphState(NamedTuple):
    output: OutputGraphState
    symbolic_locals: Dict[str, VariableTracker]
    stack: List[VariableTracker]
    block_stack: List[BlockStackEntry]
    instruction_pointer: int | None
    current_instruction: Instruction
    next_instruction: Instruction | None
    lineno: int
    def diff(self, other: InstructionTranslatorGraphState) -> str | None: ...

def stack_op(fn: typing.Callable[..., object]): ...
def generic_jump(truth_fn: typing.Callable[[object], bool], push: bool): ...

explain: bool

def break_graph_if_unsupported(*, push): ...
def is_none(x): ...
def is_not_none(x): ...

class InstructionTranslatorBase(Checkpointable[InstructionTranslatorGraphState]):
    output: OutputGraph
    symbolic_locals: Dict[str, VariableTracker]
    symbolic_globals: Dict[str, VariableTracker]
    stack: List[VariableTracker]
    instruction_pointer: int | None
    current_instruction: Instruction
    next_instruction: Instruction | None
    block_stack: List[BlockStackEntry]
    lineno: int
    mutated_closure_cell_contents: Set[str]
    checkpoint: Tuple[Instruction, InstructionTranslatorGraphState] | None
    random_calls: List[Tuple[Callable[..., object], Tuple[object, ...], Dict[str, object]]]
    def has_backedge(self): ...
    def cell_and_freevars(self): ...
    def prune_dead_locals(self) -> None: ...
    def call_function(self, fn: VariableTracker, args: List[VariableTracker], kwargs: Dict[str, VariableTracker]): ...
    def update_locals_and_stack(self, oldvar: VariableTracker, newvar: VariableTracker): ...
    def replace_all(self, oldvar: VariableTracker, newvar: VariableTracker): ...
    def inline_user_function_return(self, fn, args, kwargs):
        """
        A call to some user defined function by inlining it.
        """
    def step(self):
        """Process exactly one instruction, return False we should exit"""
    def run(self) -> None: ...
    def push(self, val: VariableTracker | None): ...
    def push_many(self, vals: List[VariableTracker]): ...
    def pop(self) -> VariableTracker: ...
    def popn(self, n: int) -> List[VariableTracker]: ...
    def LOAD_FAST(self, inst) -> None: ...
    def LOAD_DEREF(self, inst) -> None: ...
    def STORE_FAST(self, inst) -> None: ...
    def DELETE_FAST(self, inst) -> None: ...
    STORE_DEREF = STORE_FAST
    def LOAD_CLOSURE(self, inst) -> None: ...
    def LOAD_CONST(self, inst) -> None: ...
    def get_global_source(self, name): ...
    def LOAD_GLOBAL(self, inst): ...
    def STORE_GLOBAL(self, inst) -> None: ...
    def import_source(self, module_name):
        """Create an alias to a module for use in guards"""
    def resolve_name(self, name, package, level):
        """
        Copied from the Cpython implementation of __import__
        Resolve a relative module name to an absolute one.
        https://github.com/python/cpython/blob/5a094f0255eea1db58fb2cf14c200971e64ec36e/Lib/importlib/_bootstrap.py#L902
        """
    def calc_package(self):
        """
        Copied from the Cpython implementation of __import__
        https://github.com/python/cpython/blob/5a094f0255eea1db58fb2cf14c200971e64ec36e/Lib/importlib/_bootstrap.py#L1090
        """
    def IMPORT_NAME(self, inst) -> None: ...
    def IMPORT_FROM(self, inst) -> None: ...
    def load_builtin(self, inst) -> None: ...
    def jump(self, inst) -> None: ...
    JUMP_FORWARD = jump
    JUMP_ABSOLUTE = jump
    POP_JUMP_IF_FALSE: Incomplete
    POP_JUMP_IF_TRUE: Incomplete
    JUMP_IF_FALSE_OR_POP: Incomplete
    JUMP_IF_TRUE_OR_POP: Incomplete
    def SETUP_LOOP(self, inst) -> None: ...
    def SETUP_EXCEPT(self, inst) -> None: ...
    def POP_BLOCK(self, inst) -> None: ...
    def SETUP_WITH(self, inst) -> None: ...
    def SETUP_FINALLY(self, inst) -> None: ...
    def BEGIN_FINALLY(self, inst) -> None: ...
    def WITH_CLEANUP_START(self, inst) -> None: ...
    def WITH_CLEANUP_FINISH(self, inst) -> None: ...
    def END_FINALLY(self, inst) -> None: ...
    def FOR_ITER(self, inst) -> None: ...
    def COMPARE_OP(self, inst) -> None: ...
    def GET_ITER(self, inst) -> None: ...
    def CALL_FUNCTION(self, inst) -> None: ...
    def CALL_FUNCTION_EX(self, inst) -> None: ...
    def CALL_FUNCTION_KW(self, inst) -> None: ...
    def LOAD_METHOD(self, inst) -> None: ...
    def CALL_METHOD(self, inst) -> None: ...
    def LOAD_ATTR(self, inst) -> None: ...
    def STORE_ATTR(self, inst) -> None: ...
    def create_call_resume_at(self, offset) -> None: ...
    def should_compile_partial_graph(self) -> bool: ...
    def STORE_SUBSCR(self, inst) -> None: ...
    def BUILD_TUPLE(self, inst) -> None: ...
    def BUILD_SLICE(self, inst) -> None: ...
    def BUILD_LIST(self, inst) -> None: ...
    def BUILD_LIST_UNPACK(self, inst, cls=...) -> None: ...
    def BUILD_TUPLE_UNPACK(self, inst) -> None: ...
    BUILD_TUPLE_UNPACK_WITH_CALL = BUILD_TUPLE_UNPACK
    def BUILD_MAP(self, inst) -> None: ...
    def BUILD_CONST_KEY_MAP(self, inst) -> None: ...
    def MAP_ADD(self, inst) -> None: ...
    def LIST_APPEND(self, inst) -> None: ...
    def MAKE_FUNCTION(self, inst) -> None: ...
    def UNPACK_SEQUENCE(self, inst) -> None: ...
    def UNPACK_EX(self, inst) -> None: ...
    def NOP(self, inst) -> None: ...
    def POP_TOP(self, inst) -> None: ...
    def ROT_TWO(self, inst) -> None: ...
    def ROT_THREE(self, inst) -> None: ...
    def ROT_FOUR(self, inst) -> None: ...
    def DUP_TOP(self, inst) -> None: ...
    def DUP_TOP_TWO(self, inst) -> None: ...
    def FORMAT_VALUE(self, inst) -> None: ...
    def BUILD_STRING(self, inst) -> None: ...
    def IS_OP(self, inst) -> None: ...
    def CONTAINS_OP(self, inst) -> None: ...
    def LIST_EXTEND(self, inst) -> None: ...
    def LIST_TO_TUPLE(self, inst) -> None: ...
    def DICT_MERGE(self, inst) -> None: ...
    def GEN_START(self, inst) -> None: ...
    def GET_LEN(self, inst) -> None: ...
    def MATCH_MAPPING(self, inst) -> None: ...
    def MATCH_SEQUENCE(self, inst) -> None: ...
    def MATCH_KEYS(self, inst) -> None: ...
    UNARY_POSITIVE: Incomplete
    UNARY_NEGATIVE: Incomplete
    UNARY_NOT: Incomplete
    UNARY_INVERT: Incomplete
    BINARY_POWER: Incomplete
    BINARY_MULTIPLY: Incomplete
    BINARY_MATRIX_MULTIPLY: Incomplete
    BINARY_FLOOR_DIVIDE: Incomplete
    BINARY_TRUE_DIVIDE: Incomplete
    BINARY_MODULO: Incomplete
    BINARY_REMAINDER: Incomplete
    BINARY_ADD: Incomplete
    BINARY_SUBTRACT: Incomplete
    BINARY_SUBSCR: Incomplete
    BINARY_LSHIFT: Incomplete
    BINARY_RSHIFT: Incomplete
    BINARY_AND: Incomplete
    BINARY_OR: Incomplete
    BINARY_XOR: Incomplete
    INPLACE_POWER: Incomplete
    INPLACE_MULTIPLY: Incomplete
    INPLACE_MATRIX_MULTIPLY: Incomplete
    INPLACE_FLOOR_DIVIDE: Incomplete
    INPLACE_TRUE_DIVIDE: Incomplete
    INPLACE_MODULO: Incomplete
    INPLACE_REMAINDER: Incomplete
    INPLACE_ADD: Incomplete
    INPLACE_SUBTRACT: Incomplete
    INPLACE_LSHIFT: Incomplete
    INPLACE_RSHIFT: Incomplete
    INPLACE_AND: Incomplete
    INPLACE_XOR: Incomplete
    INPLACE_OR: Incomplete
    def RESUME(self, inst) -> None: ...
    def BINARY_OP(self, inst): ...
    def COPY(self, inst) -> None: ...
    def SWAP(self, inst) -> None: ...
    JUMP_BACKWARD = jump
    JUMP_BACKWARD_NO_INTERRUPT = jump
    POP_JUMP_FORWARD_IF_TRUE: Incomplete
    POP_JUMP_BACKWARD_IF_TRUE: Incomplete
    POP_JUMP_FORWARD_IF_FALSE: Incomplete
    POP_JUMP_BACKWARD_IF_FALSE: Incomplete
    POP_JUMP_FORWARD_IF_NOT_NONE: Incomplete
    POP_JUMP_BACKWARD_IF_NOT_NONE: Incomplete
    POP_JUMP_FORWARD_IF_NONE: Incomplete
    POP_JUMP_BACKWARD_IF_NONE: Incomplete
    def CACHE(self, inst) -> None: ...
    def copy_graphstate(self) -> InstructionTranslatorGraphState:
        """Create a checkpoint of the current state by copying everything"""
    def restore_graphstate(self, state: InstructionTranslatorGraphState):
        """Restore a checkpoint created by self.copy_graphstate()"""
    def empty_checkpoint(self): ...
    def format_frame_summary(self, additional_stack_frames: Incomplete | None = None): ...
    def frame_summary(self): ...
    def store_dict_key(self, name, value) -> None: ...
    @property
    def fake_mode(self): ...
    def find_symbolic_locals_name(self, tensor_variable): ...
    instructions: Incomplete
    indexof: Incomplete
    f_locals: Incomplete
    f_globals: Incomplete
    f_builtins: Incomplete
    code_options: Incomplete
    f_code: Incomplete
    exec_recorder: Incomplete
    nn_module_stack: Incomplete
    export: Incomplete
    def __init__(self, output: OutputGraph, instructions: List[Instruction], f_locals: Dict[str, Any], f_globals: Dict[str, Any], f_builtins: Dict[str, Any], code_options: Dict[str, Any], symbolic_locals: Dict[str, VariableTracker], symbolic_globals: Dict[str, VariableTracker], f_code: types.CodeType, export: bool) -> None: ...

class InstructionTranslator(InstructionTranslatorBase):
    one_graph: Incomplete
    export: Incomplete
    mutated_closure_cell_contents: Incomplete
    symbolic_locals: Incomplete
    def __init__(self, instructions: List[Instruction], f_code, f_locals, f_globals, f_builtins, code_options, compiler_fn, one_graph, export, mutated_closure_cell_contents: Set[str]) -> None: ...
    def run(self) -> None: ...
    def match_nested_cell(self, name, cell):
        """Match a cell in this method to one in a function we are inlining"""
    def should_compile_partial_graph(self): ...
    instruction_pointer: Incomplete
    def create_call_resume_at(self, inst): ...
    def RETURN_VALUE(self, inst) -> None: ...

class InliningInstructionTranslator(InstructionTranslatorBase):
    """Trace and inline a called method"""
    symbolic_result: TensorVariable | None
    @classmethod
    def inline_call(cls, parent, func, args, kwargs): ...
    @staticmethod
    def inline_call_(parent, func, args, kwargs): ...
    parent: Incomplete
    closure_cells: Incomplete
    nn_module_stack: Incomplete
    def __init__(self, parent: InstructionTranslatorBase, code: types.CodeType, symbolic_locals: Dict[str, VariableTracker], symbolic_globals: Dict[str, VariableTracker], closure_cells: Dict[str, VariableTracker], funcvar: BaseUserFunctionVariable) -> None: ...
    @property
    def fake_mode(self): ...
    def STORE_DEREF(self, inst) -> None: ...
    def LOAD_DEREF(self, inst) -> None: ...
    def LOAD_CLOSURE(self, inst) -> None: ...
    def replace_all(self, oldvar: VariableTracker, newvar: VariableTracker): ...
    def should_compile_partial_graph(self): ...
    def create_call_resume_at(self, offset) -> None: ...
    instruction_pointer: Incomplete
    def RETURN_VALUE(self, inst) -> None: ...

class InliningGeneratorInstructionTranslator(InliningInstructionTranslator):
    generated_items: List[VariableTracker]
    def __init__(self, *args, **kwargs) -> None: ...
    def YIELD_VALUE(self, inst: Instruction): ...
