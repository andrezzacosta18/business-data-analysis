import types
from . import config as config, convert_frame as convert_frame, mutation_guard as mutation_guard
from .eval_frame import set_guard_error_hook as set_guard_error_hook, set_guard_fail_hook as set_guard_fail_hook
from .exc import unimplemented as unimplemented
from .types import GuardFail as GuardFail, GuardFn as GuardFn, GuardedCode as GuardedCode
from .utils import HAS_NUMPY as HAS_NUMPY, dict_const_keys as dict_const_keys, dict_const_keys_repr as dict_const_keys_repr, dict_param_key_ids as dict_param_key_ids, guard_failures as guard_failures, istype as istype, np as np, orig_code_map as orig_code_map, rename_implicit as rename_implicit, tuple_iterator_getitem as tuple_iterator_getitem, tuple_iterator_len as tuple_iterator_len
from _typeshed import Incomplete
from collections.abc import Generator
from torch._guards import DuplicateInputs as DuplicateInputs, Guard as Guard, GuardBuilderBase as GuardBuilderBase, GuardEnvExpr as GuardEnvExpr, GuardSource as GuardSource, Source as Source
from torch.fx.experimental.symbolic_shapes import SYMPY_INTERP as SYMPY_INTERP
from typing import Any, Callable, Dict, Tuple, Type

log: Incomplete
TensorGuards: Incomplete
check_obj_id: Incomplete
check_type_id: Incomplete
CLOSURE_VARS: Incomplete

def strip_function_call(name):
    '''
    "___odict_getitem(a, 1)" => "a"
    '''
def strip_getattr_getitem(name):
    '''
    "a[1]" => "a"
    "a.foo" => "a"
    '''

class GuardBuilder(GuardBuilderBase):
    id_ref: Incomplete
    source_ref: Incomplete
    scope: Incomplete
    argnames: Incomplete
    code: Incomplete
    shape_env_code: Incomplete
    tensor_check_names: Incomplete
    tensor_check_examples: Incomplete
    tensor_check_ids: Incomplete
    check_fn_manager: Incomplete
    def __init__(self, id_ref: Callable[[Type[object]], str], source_ref: Callable[[Source], str], scope: Dict[str, object] | None, check_fn_manager: CheckFunctionManager, renames: bool = True) -> None: ...
    def get(self, name: str) -> Any: ...
    def arg_ref(self, guard: str | Guard) -> str: ...
    def TYPE_MATCH(self, guard: Guard): ...
    def ID_MATCH(self, guard: Guard): ...
    def NAME_MATCH(self, guard: Guard): ...
    def HASATTR(self, guard: Guard): ...
    def EQUALS_MATCH(self, guard: Guard): ...
    def CONSTANT_MATCH(self, guard: Guard): ...
    def NN_MODULE(self, guard: Guard): ...
    def FUNCTION_MATCH(self, guard: Guard):
        """things like torch.add and user defined functions"""
    def BUILTIN_MATCH(self, guard: Guard): ...
    def PYMODULE_MATCH(self, guard: Guard): ...
    def LIST_LENGTH(self, guard) -> None: ...
    def TUPLE_ITERATOR_LEN(self, guard) -> None: ...
    def DICT_KEYS(self, guard) -> None: ...
    def WEAKREF_ALIVE(self, guard) -> None: ...
    def NN_MODULE_PARAM_NAMES(self, guard) -> None: ...
    def ODICT_KEYS(self, guard) -> None:
        """OrderedDict keys match"""
    def OBJECT_MUTATION(self, guard: Guard): ...
    def GRAD_MODE(self, guard: Guard):
        """Guard on the initial grad state"""
    def SHAPE_ENV(self, guard: Guard): ...
    def TENSOR_MATCH(self, guard: Guard): ...

class CheckFunctionManager:
    valid: bool
    output_graph: Incomplete
    check_fn: Incomplete
    def __init__(self, output_graph: Incomplete | None = None, f_locals: Dict[str, object] | None = None, f_globals: Dict[str, object] | None = None, guard_fail_fn: Callable[[Tuple[str, str]], None] | None = None) -> None: ...
    def compile_check_fn(self, local_builder, global_builder, guards_out, guard_fail_fn): ...
    def invalidate(self, ref) -> None: ...
    def id_ref(self, obj):
        """add a weakref, return the id"""

def guard_fail_hook(guard_fn: GuardFn, code: types.CodeType, f_locals: Dict[str, object], last: bool) -> None:
    """
    called whenever a guard fails.
    """
def guard_error_hook(guard_fn: GuardFn, code: types.CodeType, f_locals: Dict[str, object], last: bool): ...
def unique(seq) -> Generator[Incomplete, None, None]: ...
