import dataclasses
import torch.nn
import types
from .bytecode_transformation import Instruction as Instruction, create_dup_top as create_dup_top, create_instruction as create_instruction, create_rot_n as create_rot_n
from .exc import unimplemented as unimplemented
from .source import AttrSource as AttrSource, Source as Source
from .utils import is_safe_constant as is_safe_constant, istype as istype, rot_n_helper as rot_n_helper
from .variables.base import VariableTracker as VariableTracker
from .variables.nn_module import NNModuleVariable as NNModuleVariable
from .variables.tensor import SymNodeVariable as SymNodeVariable, TensorVariable as TensorVariable, TensorWithTFOverrideVariable as TensorWithTFOverrideVariable, UnspecializedPythonVariable as UnspecializedPythonVariable
from _typeshed import Incomplete
from typing import List

@dataclasses.dataclass
class GraphOutputEntry:
    index: int
    variable: VariableTracker
    def merge(self, other: VariableTracker): ...
    def __init__(self, index, variable) -> None: ...

class PyCodegen:
    """
    Helper class uses for constructing Python bytecode
    """
    root: Incomplete
    top_of_stack: Incomplete
    uses: Incomplete
    graph_outputs: Incomplete
    tempvars: Incomplete
    tx: Incomplete
    graph_output_var: Incomplete
    code_options: Incomplete
    cell_and_freevars: Incomplete
    new_var: Incomplete
    def __init__(self, tx: Incomplete | None = None, root: torch.nn.Module = None, graph_output_var: str = None, tempvars: Incomplete | None = None) -> None: ...
    def graph_output_vars(self): ...
    def __call__(self, value, allow_cache: bool = True) -> None:
        """Generate code such that top-of-stack (TOS) is set to value"""
    def add_cache(self, value) -> None: ...
    def foreach(self, items) -> None: ...
    def setup_globally_cached(self, name, value):
        """Store value in a new global"""
    def clear_tos(self) -> None: ...
    def append_output(self, inst) -> None: ...
    def extend_output(self, insts) -> None: ...
    def get_instructions(self): ...
    def create_load(self, name): ...
    def create_load_closure(self, name): ...
    def create_store(self, name): ...
    def create_load_global(self, name, add: bool = False): ...
    def create_load_const(self, value): ...
    @staticmethod
    def get_const_index(code_options, value): ...
    create_load_output: Incomplete
    def create_load_attr(self, name): ...
    def create_load_attrs(self, names): ...
    def load_function_name(self, fn_name, num_on_stack: int = 0):
        """Load the global fn_name on the stack num_on_stack down"""
    def rot_n(self, n): ...
    def make_function_with_closure(self, fn_name: str, code: types.CodeType, num_on_stack: int = 0): ...
    def create_load_python_module(self, mod):
        """
        Generate a LOAD_GLOBAL instruction to fetch a given python module.
        """
    def make_call_generated_code(self, fn_name: str) -> List[Instruction]:
        """Call the generated code function stored in fn_name"""
    def load_import_from(self, module_name, object_name) -> None: ...
    def create_begin_finally(self): ...
