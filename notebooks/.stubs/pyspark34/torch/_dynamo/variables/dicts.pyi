from .. import variables as variables
from ..bytecode_transformation import create_instruction as create_instruction
from ..eval_frame import skip_code as skip_code
from ..exc import unimplemented as unimplemented
from ..source import AttrSource as AttrSource, GlobalWeakRefSource as GlobalWeakRefSource
from ..utils import global_key_name as global_key_name, istensor as istensor
from .base import MutableLocal as MutableLocal, VariableTracker as VariableTracker
from .constant import ConstantVariable as ConstantVariable
from .tensor import TensorVariable as TensorVariable
from _typeshed import Incomplete
from typing import Dict, List

class ConstDictVariable(VariableTracker):
    items: Incomplete
    user_cls: Incomplete
    def __init__(self, items, user_cls, recursively_contains: Incomplete | None = None, **kwargs) -> None: ...
    def as_proxy(self): ...
    def as_python_constant(self): ...
    def python_type(self): ...
    def reconstruct(self, codegen): ...
    def getitem_const(self, arg: VariableTracker): ...
    def call_method(self, tx, name, args: List[VariableTracker], kwargs: Dict[str, VariableTracker]) -> VariableTracker: ...
    def modifed(self, items, recursively_contains, **options):
        """a copy of self with different items"""
    def unpack_var_sequence(self, tx): ...
    @classmethod
    def get_key(cls, arg: VariableTracker): ...
    @classmethod
    def is_valid_key(cls, key): ...

class DefaultDictVariable(ConstDictVariable):
    default_factory: Incomplete
    def __init__(self, items, user_cls, default_factory: Incomplete | None = None, **kwargs) -> None: ...
    def call_method(self, tx, name, args: List[VariableTracker], kwargs: Dict[str, VariableTracker]) -> VariableTracker: ...

class DataClassVariable(ConstDictVariable):
    """
    This is a bit of a hack to deal with
    transformers.file_utils.ModelOutput() from huggingface.

    ModelOutput causes trouble because it a a mix of a dataclass and a
    OrderedDict and it calls super() methods implemented in C.
    """
    include_none: bool
    @staticmethod
    def is_matching_cls(cls): ...
    @classmethod
    def is_matching_object(cls, obj): ...
    @classmethod
    def create(cls, user_cls, args, kwargs, options): ...
    @classmethod
    def wrap(cls, builder, obj): ...
    def __init__(self, items, user_cls, **options) -> None: ...
    def as_proxy(self) -> None: ...
    def reconstruct(self, codegen): ...
    def call_method(self, tx, name, args: List[VariableTracker], kwargs: Dict[str, VariableTracker]) -> VariableTracker: ...
    def var_getattr(self, tx, name: str) -> VariableTracker: ...

class HFPretrainedConfigVariable(VariableTracker):
    """
    Hack for HuggingFace PretrainedConfig
    """
    @staticmethod
    def is_matching_cls(cls): ...
    @classmethod
    def is_matching_object(cls, obj): ...
    obj: Incomplete
    def __init__(self, obj, **kwargs) -> None: ...
    def var_getattr(self, tx, name: str) -> VariableTracker: ...
