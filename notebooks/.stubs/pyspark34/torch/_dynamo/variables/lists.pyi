import torch.fx
from .. import config as config, variables as variables
from ..bytecode_transformation import create_instruction as create_instruction
from ..exc import unimplemented as unimplemented
from ..source import GetItemSource as GetItemSource
from ..utils import namedtuple_fields as namedtuple_fields, proxy_args_kwargs as proxy_args_kwargs
from .base import MutableLocal as MutableLocal, VariableTracker as VariableTracker
from .constant import ConstantVariable as ConstantVariable
from _typeshed import Incomplete
from typing import Dict, List

class BaseListVariable(VariableTracker):
    @staticmethod
    def cls_for(obj): ...
    items: Incomplete
    def __init__(self, items: List[VariableTracker], recursively_contains: Incomplete | None = None, regen_guards: bool = True, **kwargs) -> None: ...
    def as_python_constant(self): ...
    def as_proxy(self): ...
    def getitem_const(self, arg: VariableTracker): ...
    def unpack_var_sequence(self, tx): ...
    def call_method(self, tx, name, args: List[VariableTracker], kwargs: Dict[str, VariableTracker]) -> VariableTracker: ...
    @staticmethod
    def list_compare(tx, op, left, right): ...
    @staticmethod
    def list_eq(tx, left, right): ...

class RangeVariable(BaseListVariable):
    def __init__(self, items, **kwargs) -> None: ...
    def python_type(self): ...
    def as_python_constant(self): ...
    def as_proxy(self): ...
    def unpack_var_sequence(self, tx): ...
    def reconstruct(self, codegen): ...
    def var_getattr(self, tx, name): ...

class ListVariable(BaseListVariable):
    def python_type(self): ...
    def reconstruct(self, codegen): ...
    def call_method(self, tx, name, args: List[VariableTracker], kwargs: Dict[str, VariableTracker]) -> VariableTracker: ...

class TupleVariable(BaseListVariable):
    def python_type(self): ...
    def reconstruct(self, codegen): ...
    def call_method(self, tx, name, args: List[VariableTracker], kwargs: Dict[str, VariableTracker]) -> VariableTracker: ...

class SizeVariable(TupleVariable):
    """torch.Size(...)"""
    proxy: Incomplete
    def __init__(self, items: List[VariableTracker], proxy: torch.fx.Proxy | None = None, **kwargs) -> None: ...
    def python_type(self): ...
    def as_proxy(self): ...
    def reconstruct(self, codegen): ...
    def unpack_var_sequence(self, tx): ...
    def call_method(self, tx, name, args: List[VariableTracker], kwargs: Dict[str, VariableTracker]) -> VariableTracker: ...
    def get_item_dyn(self, tx, arg: VariableTracker): ...

class ShapeVariable(TupleVariable):
    """
    Represents tensor.shape(...) and helps differentiate between a constant
    TupleVariable and ShapeVariable.
    """

class NamedTupleVariable(TupleVariable):
    tuple_cls: Incomplete
    def __init__(self, items, tuple_cls, **kwargs) -> None: ...
    def python_type(self): ...
    def as_python_constant(self): ...
    def reconstruct(self, codegen): ...
    def var_getattr(self, tx, name): ...
    def call_hasattr(self, tx, name: str) -> VariableTracker: ...

class SliceVariable(BaseListVariable):
    def __init__(self, items, **kwargs) -> None: ...
    def as_proxy(self): ...
    def python_type(self): ...
    def as_python_constant(self): ...
    def reconstruct(self, codegen): ...
    def var_getattr(self, tx, name): ...

class ListIteratorVariable(VariableTracker):
    items: Incomplete
    index: Incomplete
    def __init__(self, items, index: int = 0, recursively_contains: Incomplete | None = None, **kwargs) -> None: ...
    def next_variables(self): ...
    def as_python_constant(self): ...
    def unpack_var_sequence(self, tx): ...
    def reconstruct(self, codegen): ...

class TupleIteratorVariable(ListIteratorVariable): ...
