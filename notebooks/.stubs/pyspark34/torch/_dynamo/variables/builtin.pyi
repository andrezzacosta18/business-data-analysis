from .. import config as config, variables as variables
from ..allowed_functions import is_allowed as is_allowed
from ..exc import Unsupported as Unsupported, unimplemented as unimplemented
from ..guards import GuardBuilder as GuardBuilder
from ..replay_record import DummyModule as DummyModule
from ..source import AttrSource as AttrSource, SuperSource as SuperSource, TypeSource as TypeSource, is_constant_source as is_constant_source
from ..utils import check_constant_args as check_constant_args, check_unspec_python_args as check_unspec_python_args, istype as istype, proxy_args_kwargs as proxy_args_kwargs, specialize_args_kwargs as specialize_args_kwargs
from .base import MutableLocal as MutableLocal, VariableTracker as VariableTracker, typestr as typestr
from .constant import ConstantVariable as ConstantVariable
from .dicts import ConstDictVariable as ConstDictVariable
from .lists import BaseListVariable as BaseListVariable, ListVariable as ListVariable, TupleIteratorVariable as TupleIteratorVariable, TupleVariable as TupleVariable
from .tensor import FakeItemVariable as FakeItemVariable, SymNodeVariable as SymNodeVariable, UnspecializedPythonVariable as UnspecializedPythonVariable
from .user_defined import UserDefinedVariable as UserDefinedVariable
from _typeshed import Incomplete
from torch import sym_float as sym_float, sym_int as sym_int
from typing import Dict, List

log: Incomplete

class BuiltinVariable(VariableTracker):
    def can_constant_fold_through(self): ...
    def can_insert_in_graph(self): ...
    fn: Incomplete
    def __init__(self, fn, **kwargs) -> None: ...
    def python_type(self): ...
    def as_python_constant(self): ...
    def reconstruct(self, codegen): ...
    def constant_args(self, *args, **kwargs): ...
    def tensor_args(self, *args, **kwargs): ...
    def unspec_python_args(self, *args, **kwargs): ...
    @staticmethod
    def unwrap_unspec_args_kwargs(args, kwargs): ...
    def call_function(self, tx, args: List[VariableTracker], kwargs: Dict[str, VariableTracker]) -> VariableTracker: ...
    call_min: Incomplete
    call_max: Incomplete
    def call_range(self, tx, *args): ...
    def call_slice(self, tx, *args): ...
    call_iter: Incomplete
    call_tuple: Incomplete
    call_list: Incomplete
    def call_dict(self, tx, arg): ...
    def call_zip(self, tx, *args): ...
    def call_enumerate(self, tx, *args): ...
    def call_len(self, tx, *args, **kwargs): ...
    def call_getitem(self, tx, *args, **kwargs): ...
    def call_isinstance(self, tx, arg, isinstance_type): ...
    def call_super(self, tx, a, b): ...
    def call_next(self, tx, arg): ...
    def call_hasattr(self, tx, obj, attr): ...
    def call_map(self, tx, fn, seq): ...
    def call_sum(self, tx, seq, **kwargs): ...
    def call_reduce(self, tx, function, iterable, initializer: Incomplete | None = None): ...
    def call_getattr(self, tx, obj: VariableTracker, name_var: VariableTracker, default: Incomplete | None = None): ...
    def call_setattr(self, tx, obj: VariableTracker, name_var: VariableTracker, val: VariableTracker): ...
    def call_type(self, tx, obj: VariableTracker): ...
    def call_reversed(self, tx, obj: VariableTracker): ...
    def call_chain(self, tx, *args): ...
    def call_islice(self, tx, iterable, *args): ...
    def call_id(self, tx, *args): ...
    def call_and_(self, tx, a, b): ...
    def call_not_(self, tx, a): ...
    call_eq: Incomplete
    call_gt: Incomplete
    call_lt: Incomplete
    call_ge: Incomplete
    call_le: Incomplete
    call_ne: Incomplete
    call_is_: Incomplete
    call_is_not: Incomplete
