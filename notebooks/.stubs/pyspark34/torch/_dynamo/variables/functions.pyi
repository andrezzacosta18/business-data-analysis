from .. import variables as variables
from ..bytecode_transformation import create_instruction as create_instruction
from ..exc import unimplemented as unimplemented
from ..source import AttrSource as AttrSource, ConstantSource as ConstantSource, DefaultsSource as DefaultsSource, GetItemSource as GetItemSource
from ..utils import istensor as istensor, istype as istype, make_cell as make_cell
from .base import VariableTracker as VariableTracker, typestr as typestr
from _typeshed import Incomplete
from typing import Dict, List

def wrap_bound_arg(tx, val, options, source: Incomplete | None = None): ...
def wrap_args_kwargs(tx, result, options) -> None: ...
def init_cellvars(parent, result, code): ...

class BaseUserFunctionVariable(VariableTracker):
    def get_filename(self): ...
    def get_name(self): ...
    def call_function(self, tx, args: List[VariableTracker], kwargs: Dict[str, VariableTracker]) -> VariableTracker: ...
    def num_parameters(self): ...
    def closure_vars(self, tx): ...

class UserFunctionVariable(BaseUserFunctionVariable):
    """Some unsupported user-defined global function"""
    is_constant: bool
    fn: Incomplete
    def __init__(self, fn, is_constant: bool = False, **kwargs) -> None: ...
    def self_args(self): ...
    def get_function(self): ...
    def get_code(self): ...
    def python_type(self): ...
    def has_self(self): ...
    def get_globals(self): ...
    def bind_args(self, parent, args, kwargs): ...
    def export_freevars(self, parent, child) -> None: ...
    def call_function(self, tx, args: List[VariableTracker], kwargs: Dict[str, VariableTracker]) -> VariableTracker: ...

class UserMethodVariable(UserFunctionVariable):
    """Some unsupported user-defined method"""
    obj: Incomplete
    def __init__(self, fn, obj, **kwargs) -> None: ...
    def self_args(self): ...
    def python_type(self): ...
    def call_function(self, tx, args: List[VariableTracker], kwargs: Dict[str, VariableTracker]) -> VariableTracker: ...
    def num_parameters(self): ...

class WrappedUserMethodVariable(UserMethodVariable):
    wrapped: Incomplete
    context: Incomplete
    def __init__(self, wrapped, context, **kwargs) -> None: ...
    def call_function(self, tx, args: List[VariableTracker], kwargs: Dict[str, VariableTracker]) -> VariableTracker: ...

class WrappedUserFunctionVariable(UserFunctionVariable):
    wrapped: Incomplete
    context: Incomplete
    def __init__(self, wrapped, context, **kwargs) -> None: ...
    def call_function(self, tx, args: List[VariableTracker], kwargs: Dict[str, VariableTracker]) -> VariableTracker: ...

def invoke_and_store_as_constant(tx, fn, name, options, args, kwargs): ...

class NestedUserFunctionVariable(BaseUserFunctionVariable):
    fn_name: Incomplete
    code: Incomplete
    f_globals: Incomplete
    defaults: Incomplete
    kwdefaults: Incomplete
    annotations: Incomplete
    closure: Incomplete
    closure_scope: Incomplete
    def __init__(self, fn_name, code, f_globals, defaults, kwdefaults, annotations, closure, closure_scope, **kwargs) -> None: ...
    def self_args(self): ...
    def get_code(self): ...
    def get_function(self): ...
    def has_closure(self): ...
    def has_self(self): ...
    def get_globals(self): ...
    def bind_args(self, parent, args, kwargs): ...
    def export_freevars(self, parent, child) -> None: ...
    def reconstruct(self, codegen): ...
