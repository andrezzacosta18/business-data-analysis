import dataclasses
from . import utils as utils, variables as variables
from .bytecode_transformation import create_instruction as create_instruction
from .codegen import PyCodegen as PyCodegen
from .source import LocalSource as LocalSource, Source as Source
from .utils import object_new as object_new
from .variables.base import VariableTracker as VariableTracker
from _typeshed import Incomplete
from typing import Any, Dict, List

@dataclasses.dataclass
class MutableSideEffects:
    """
    VariableTracker.mutable_local marker to indicate a list passed as
    an input that if we mutate we need to re-apply those mutations after
    the graph runs.
    """
    source: Source
    is_modified: bool = ...
    def __hash__(self): ...
    def __eq__(self, other): ...
    def __init__(self, source, is_modified) -> None: ...

@dataclasses.dataclass
class AttributeMutation:
    """
    VariableTracker.mutable_local marker to track changes to attributes
    """
    source: Source
    def __init__(self, source) -> None: ...

class AttributeMutationExisting(AttributeMutation):
    def __hash__(self): ...
    def __eq__(self, other): ...

@dataclasses.dataclass
class AttributeMutationNew(AttributeMutation):
    cls_source: Source
    def __hash__(self): ...
    def __eq__(self, other): ...
    def __init__(self, source, cls_source) -> None: ...

class SideEffects:
    """
    Track side effects (list mutation, setattr, etc) that need to be
    applied after an FX graph is run.
    """
    id_to_variable: Dict[int, VariableTracker]
    store_attr_mutations: Dict[AttributeMutation, Dict[str, VariableTracker]]
    keepalive: List[Any]
    def __init__(self, id_to_variable: Incomplete | None = None, store_attr_mutations: Incomplete | None = None, keepalive: Incomplete | None = None) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def diff(self, other: SideEffects) -> str | None: ...
    def clone(self):
        """Create a shallow copy"""
    def apply(self, fn, cache: Incomplete | None = None, skip_fn=...): ...
    def __contains__(self, item) -> bool: ...
    def __getitem__(self, item): ...
    def store_attr(self, item: VariableTracker, name: str, value: VariableTracker): ...
    def load_attr(self, item, name): ...
    def store_cell(self, cellvar, value) -> None: ...
    def load_cell(self, cellvar): ...
    def load_global(self, gvar: VariableTracker, name: str): ...
    def store_global(self, gvar: VariableTracker, name: str, value: VariableTracker): ...
    @staticmethod
    def cls_supports_mutation_side_effects(cls): ...
    def is_attribute_mutation(self, item): ...
    def is_modified(self, item): ...
    track_list: Incomplete
    track_dict: Incomplete
    def track_object_existing(self, source: Source, item: Any, variable: VariableTracker): ...
    def track_object_new(self, cls_source: Source, user_cls: Any, variable_cls: Any, options): ...
    def track_cell_new(self): ...
    def track_cell_existing(self, source: Source, item: Any): ...
    def track_global_existing(self, source: Source, item: Any): ...
    def prune_dead_object_new(self, tx): ...
    def mutation(self, oldvar, newvar): ...
    def codegen_save_tempvars(self, cg: PyCodegen): ...
    def codegen_update_mutated(self, cg: PyCodegen): ...
    def is_empty(self): ...
