import abc
import dataclasses
import enum
import sympy
from _typeshed import Incomplete
from abc import ABC, abstractmethod
from typing import Callable, Generic, List, NamedTuple, Set, TypeVar

log: Incomplete

class GuardSource(enum.Enum):
    LOCAL: int
    GLOBAL: int
    LOCAL_NN_MODULE: int
    GLOBAL_NN_MODULE: int
    CONSTANT: int
    RANDOM_VALUE: int
    SHAPE_ENV: int
    def select(self, locals_, globals_): ...
    def is_nn_module(self) -> bool: ...
    def is_local(self): ...

class GuardBuilderBase: ...

class ShapeGuard(NamedTuple):
    expr: sympy.Expr
    stack: str

@dataclasses.dataclass
class Guard:
    name: str
    source: GuardSource
    create_fn: Callable[[GuardBuilderBase, Guard], None]
    is_volatile: bool = ...
    guard_types: List[str] | None = ...
    code_list: List[str] | None = ...
    obj_weakref: object | None = ...
    guarded_class_weakref: type | None = ...
    def __hash__(self): ...
    def sort_key(self): ...
    def __lt__(self, other): ...
    @staticmethod
    def weakref_to_str(obj_weakref):
        """
        This is a workaround of a Python weakref bug.

        `obj_weakref` is instance returned by `weakref.ref`,
        `str(obj_weakref)` is buggy if the original obj overrides __getattr__, e.g:

            class MyConfig(dict):
                def __getattr__(self, x):
                    return self[x]

            obj = MyConfig(offset=5)
            obj_weakref = weakref.ref(obj)
            str(obj_weakref)  # raise error: KeyError: '__name__'
        """
    def create(self, local_builder: GuardBuilderBase, global_builder: GuardBuilderBase): ...
    def is_nn_module(self): ...
    def is_local(self): ...
    def set_export_info(self, guard_type, guarded_class, code_list, obj_weakref) -> None: ...
    def __init__(self, name, source, create_fn, is_volatile, guard_types, code_list, obj_weakref, guarded_class_weakref) -> None: ...
T = TypeVar('T')

@dataclasses.dataclass
class GuardEnvExpr: ...

@dataclasses.dataclass
class DuplicateInputs(GuardEnvExpr):
    input_pos_a: int
    input_pos_b: int
    def __post_init__(self) -> None: ...
    def __init__(self, input_pos_a, input_pos_b) -> None: ...

class Checkpointable(ABC, Generic[T], metaclass=abc.ABCMeta):
    @abstractmethod
    def copy_graphstate(self) -> T: ...
    @abstractmethod
    def restore_graphstate(self, state: T): ...

class GuardsCheckpointState:
    dynamo_guards: Set[Guard]
    def __init__(self, dynamo_guards) -> None: ...
    def diff(self, other): ...
    def __eq__(self, other): ...

class GuardsContext(Checkpointable[GuardsCheckpointState]):
    dynamo_guards: Incomplete
    aotautograd_guards: Incomplete
    def __init__(self) -> None: ...
    def copy_graphstate(self): ...
    def restore_graphstate(self, state) -> None: ...

class TracingContext:
    """
    Provides the currently installed TracingContext, or None.

    Note that it is a staticmethod, and invocations outside of `with tracing()` (see below), are valid but
    will return NoNe.
    """
    @staticmethod
    def get() -> TracingContext | None: ...
    guards_context: Incomplete
    fake_mode: Incomplete
    def __init__(self, fake_mode) -> None: ...

def tracing(context: TracingContext): ...

@dataclasses.dataclass
class Source:
    def reconstruct(self, codegen) -> None: ...
    def guard_source(self) -> None: ...
    def name(self) -> None: ...
    def make_guard(self, fn, is_volatile: bool = False): ...
    def is_nn_module(self): ...
