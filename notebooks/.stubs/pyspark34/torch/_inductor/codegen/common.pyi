import sympy
import typing
from .. import metrics as metrics
from ..utils import DeferredLineBase as DeferredLineBase, IndentedBuffer as IndentedBuffer, free_symbol_startswith as free_symbol_startswith, sympy_dot as sympy_dot, sympy_subs as sympy_subs, sympy_symbol as sympy_symbol, unique as unique
from ..virtualized import V as V, ops as ops
from _typeshed import Incomplete
from collections.abc import Generator
from sympy.printing.printer import Printer
from typing import NamedTuple

log: Incomplete

class TensorArg(NamedTuple):
    name: Incomplete
    buffer: Incomplete
    dtype: Incomplete

class SizeArg(NamedTuple):
    name: Incomplete
    expr: Incomplete

def index_prevent_reordering(index: typing.List[sympy.Expr], index_vars, sizes): ...

class ExprPrinter(Printer):
    @staticmethod
    def paren(string): ...

class PythonPrinter(ExprPrinter): ...

class OpOverrides:
    def __init__(self, parent) -> None: ...
    def __getattr__(self, item): ...
    @staticmethod
    def identity(value): ...
    @staticmethod
    def constant(value, dtype): ...
    @staticmethod
    def reciprocal(x): ...
    @staticmethod
    def square(x): ...
    @staticmethod
    def sign(x): ...
    @staticmethod
    def bitwise_not(x): ...
    @staticmethod
    def logical_not(a): ...
    @staticmethod
    def bitwise_and(x, y): ...
    @staticmethod
    def bitwise_or(x, y): ...
    @staticmethod
    def bitwise_xor(x, y): ...
    @staticmethod
    def bitwise_left_shift(x, y): ...
    @staticmethod
    def bitwise_right_shift(x, y): ...
    @staticmethod
    def remainder(a, b): ...

class DeferredLine(DeferredLineBase):
    """A line that can be 'unwritten' by adding name to V.graph.removed_buffers"""
    name: Incomplete
    def __init__(self, name, line) -> None: ...
    def __call__(self): ...

class DeferredIndentedBuffer(IndentedBuffer):
    def __init__(self, initial_indent: int = 0) -> None: ...
    def writeline(self, name, line): ...
    def writelines(self, name, lines) -> None: ...

class BracesBuffer(IndentedBuffer):
    def indent(self, offset: int = 1): ...

class InplacedBuffer(typing.NamedTuple):
    inner_name: str
    other_names: typing.List[str]

class KernelArgs:
    input_buffers: Incomplete
    output_buffers: Incomplete
    inplace_buffers: Incomplete
    sizevars: Incomplete
    def __init__(self, sizevars: Incomplete | None = None) -> None: ...
    def input(self, name): ...
    def output(self, name): ...
    def make_inplace(self, input_name, output_name) -> None: ...
    def size(self, name): ...
    def call_names(self): ...
    def wrap_ptr_arg(self, buf, dtype): ...
    def wrap_size_arg(self, size): ...
    def cpp_argdefs(self): ...
    def python_argdefs(self): ...
    def aliases(self) -> Generator[Incomplete, None, None]: ...
    def is_removed(self, name): ...

class CSEVariable:
    '''A CSEVariable is just a name for an expression but it is useful to be able to annotate them on a backend dependent basis.
    The backends can inherit from this class and overload the "create_cse_var" Kernel to do that.
    The "update_on_args" method gives you a hook for annotations, see example of TritonCSEVariable in triton.py.'''
    name: Incomplete
    def __init__(self, name) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other) -> bool: ...
    def update_on_args(self, name, args, kwargs) -> None: ...

class CppWrapperKernelArgs(KernelArgs):
    def wrap_ptr_arg(self, buf, dtype): ...
    def wrap_size_arg(self, size): ...

class CSE:
    """Common subexpression elimination"""
    prefix: Incomplete
    suffix: Incomplete
    cache: Incomplete
    name_prefix: Incomplete
    store_cache: Incomplete
    reduction_cache: Incomplete
    iter_buffer_ids: Incomplete
    invalidated_stores: Incomplete
    varname_map: Incomplete
    def __init__(self, prefix: str = '', suffix: str = '', name_prefix: str = 'tmp', iter_buffers: Incomplete | None = None, store_cache: Incomplete | None = None, reduction_cache: Incomplete | None = None, varname_map: Incomplete | None = None) -> None: ...
    def invalidate(self, keep_vars: typing.Set[str]): ...
    def clone(self): ...
    def generate(self, buffer: IndentedBuffer, expr: str | CSEVariable, write: bool = True, append_broadcast: Incomplete | None = None) -> CSEVariable: ...
    def newvar(self) -> CSEVariable: ...

class CodeGen:
    exit_stack: Incomplete
    def __init__(self) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None) -> None: ...

class Kernel(CodeGen):
    newvar_prefix: str
    suffix: str
    overrides: Incomplete
    load_format: Incomplete
    store_format: Incomplete
    args: Incomplete
    loads: Incomplete
    compute: Incomplete
    stores: Incomplete
    cse: Incomplete
    must_keep_buffers: Incomplete
    current_node: Incomplete
    store_buffer_names: Incomplete
    def __init__(self, args: Incomplete | None = None) -> None: ...
    def set_current_node(self, node) -> Generator[None, None, None]: ...
    def swap_buffers(self, lb, cb: Incomplete | None = None, sb: Incomplete | None = None) -> Generator[None, None, None]: ...
    def load(self, name: str, index: sympy.Expr): ...
    def indirect_load(self, name: str, index: sympy.Expr):
        """A load the depends on an index we have read"""
    def store(self, name, index, value, mode: Incomplete | None = None) -> None: ...
    def reduction(self, name, dtype, src_dtype, reduction_type, index, value) -> None: ...
    name: str
    def __enter__(self): ...
    def __exit__(self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: types.TracebackType | None) -> None: ...
    def rename_indexing(self, index) -> sympy.Expr: ...
    def create_cse_var(self, *args, **kwargs): ...
