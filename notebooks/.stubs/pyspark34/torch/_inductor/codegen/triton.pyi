import dataclasses
import sympy
import torch
from .. import config as config, ir as ir, scheduler as scheduler
from ..ir import ReductionHint as ReductionHint
from ..optimize_indexing import indexing_dtype_strength_reduction as indexing_dtype_strength_reduction
from ..utils import get_fused_kernel_name as get_fused_kernel_name, instance_descriptor as instance_descriptor, sympy_product as sympy_product, sympy_subs as sympy_subs, sympy_symbol as sympy_symbol
from ..virtualized import V as V, ops as ops
from .common import CSEVariable as CSEVariable, DeferredLine as DeferredLine, IndentedBuffer as IndentedBuffer, Kernel as Kernel, OpOverrides as OpOverrides, PythonPrinter as PythonPrinter, SizeArg as SizeArg, TensorArg as TensorArg, free_symbol_startswith as free_symbol_startswith, index_prevent_reordering as index_prevent_reordering
from _typeshed import Incomplete
from collections.abc import Generator
from typing import Dict, List

log: Incomplete

def signature_of(arg): ...
def config_of(args): ...

class TritonPrinter(PythonPrinter): ...

texpr: Incomplete
pexpr: Incomplete

def triton_compute_type(dtype): ...
def triton_constant(value): ...

class TritonCSEVariable(CSEVariable):
    mask_vars: Incomplete
    def __init__(self, name) -> None: ...
    def update_on_args(self, name, args, kwargs) -> None: ...

class TritonOverrides(OpOverrides):
    """Map element-wise ops to Triton"""
    @staticmethod
    def to_dtype(x, dtype: torch.dtype): ...
    @staticmethod
    def constant(value, dtype): ...
    @staticmethod
    def abs(x): ...
    @staticmethod
    def libdevice_abs(x): ...
    @staticmethod
    def exp(x): ...
    @staticmethod
    def libdevice_exp(x): ...
    @staticmethod
    def exp2(x): ...
    @staticmethod
    def expm1(x): ...
    @staticmethod
    def sqrt(x): ...
    @staticmethod
    def libdevice_sqrt(x): ...
    @staticmethod
    def relu(x): ...
    @staticmethod
    def minimum(a, b): ...
    @staticmethod
    def maximum(a, b): ...
    @staticmethod
    def where(a, b, c): ...
    @staticmethod
    def cos(x): ...
    @staticmethod
    def libdevice_cos(x): ...
    @staticmethod
    def sin(x): ...
    @staticmethod
    def libdevice_sin(x): ...
    @staticmethod
    def index_expr(expr, dtype): ...
    @staticmethod
    def masked(mask, body, other): ...
    @staticmethod
    def lgamma(x): ...
    @staticmethod
    def erf(x): ...
    @staticmethod
    def cosh(x): ...
    @staticmethod
    def sinh(x): ...
    @staticmethod
    def acos(x): ...
    @staticmethod
    def acosh(x): ...
    @staticmethod
    def asin(x): ...
    @staticmethod
    def asinh(x): ...
    @staticmethod
    def atan2(x, y): ...
    @staticmethod
    def atan(x): ...
    @staticmethod
    def atanh(x): ...
    @staticmethod
    def copysign(x, y): ...
    @staticmethod
    def erfc(x): ...
    @staticmethod
    def hypot(x, y): ...
    @staticmethod
    def log10(x): ...
    @staticmethod
    def nextafter(x, y): ...
    @staticmethod
    def logical_and(a, b): ...
    @staticmethod
    def logical_or(a, b): ...
    @staticmethod
    def rand(seed, offset, _): ...
    @staticmethod
    def randn(seed, offset, _): ...
    @staticmethod
    def rsqrt(x): ...
    @staticmethod
    def log1p(x): ...
    @staticmethod
    def tan(x): ...
    @staticmethod
    def tanh(x): ...
    @staticmethod
    def sigmoid(x): ...
    @staticmethod
    def libdevice_sigmoid(x): ...
    @staticmethod
    def signbit(x): ...
    @staticmethod
    def fmod(a, b): ...
    @staticmethod
    def pow(a, b): ...
    @staticmethod
    def log(x): ...
    @staticmethod
    def libdevice_log(x): ...
    @staticmethod
    def isinf(x): ...
    @staticmethod
    def isnan(x): ...
    @staticmethod
    def round(x): ...
    @staticmethod
    def floor(x): ...
    @staticmethod
    def floordiv(a, b): ...
    @staticmethod
    def trunc(x): ...
    @staticmethod
    def truncdiv(a, b): ...
    @staticmethod
    def ceil(x): ...

@dataclasses.dataclass
class IterationRanges:
    """
    Each range tree represents multiple sets of iteration indexing
    in a single tiled dimension in the output kernel.

    If you have two loops ranges one (4, 3, 2) and another (4, 6),
    then the range tree will be:
            4 (i0)
        3 (i1)  6 (i3)
        2 (i2)
    Where i0 is shared between both loops, but then the split into
    different indexing vars.  All loop ranges must iterate over
    the same number of elements.
    """
    name = ...
    var_list = ...
    var_ranges = ...
    numel = ...
    prefix = ...
    divisor = ...
    length = ...
    kernel = ...
    def __init__(self, name: str, var_list: List[sympy.Symbol], var_ranges: Dict[sympy.Symbol, sympy.Expr], numel: sympy.Expr, prefix: str, *, kernel: Kernel, divisor=..., length=...) -> None: ...
    def is_loop(self): ...

class IterationRangesRoot(IterationRanges):
    index: Incomplete
    nodes: Incomplete
    pid_cache: Incomplete
    def __init__(self, name: str, numel: sympy.Expr, prefix: str, index: int, kernel: Kernel, pid_cache: Incomplete | None = None) -> None: ...
    def cache_clear(self) -> None: ...
    def lookup(self, divisor, length):
        """
        Lookup a given RangeTreeEntry, creating it if needed
        """
    def construct_entries(self, lengths: List[sympy.Expr]): ...
    def construct(self, lengths: List[sympy.Expr]): ...
    def vars_and_sizes(self, index: sympy.Expr):
        """Figure out vars from this tree used in index"""
    def ranges_code(self): ...
    def pid_cache_lookup(self, key): ...
    def codegen_header(self, code) -> None: ...

class IterationRangesEntry(IterationRanges):
    parent: Incomplete
    codegen: Incomplete
    expr: Incomplete
    def __init__(self, name: str, divisor: sympy.Expr, length: sympy.Expr, expr: sympy.Expr, parent: IterationRanges) -> None: ...
    name: Incomplete
    def set_name(self, name): ...
    def cache_clear(self) -> None: ...
    def writeline(self, line) -> None: ...
    def precomputed_args(self): ...
    def symbol(self): ...
    def __hash__(self): ...
    def __eq__(self, other): ...

class TritonKernel(Kernel):
    overrides = TritonOverrides
    sexpr = pexpr
    numels: Incomplete
    mutations: Incomplete
    range_trees: Incomplete
    range_tree_nodes: Incomplete
    iter_vars_count: Incomplete
    inside_reduction: Incomplete
    body: Incomplete
    indexing_code: Incomplete
    suffix: Incomplete
    outside_loop_vars: Incomplete
    reduction_hint: Incomplete
    persistent_reduction: Incomplete
    simplify_indexing: Incomplete
    def __init__(self, *groups, mutations: Incomplete | None = None, pid_cache: Incomplete | None = None, reduction_hint=...) -> None: ...
    def should_use_persistent_reduction(self):
        """
        Heuristic to set self.persistent_reduction and add guards
        if needed.
        """
    def initialize_range_tree(self, pid_cache) -> None: ...
    def disable_reduction(self): ...
    def set_ranges(self, *lengths): ...
    @classmethod
    def is_compatible(cls, groups: List[sympy.Expr], lengths: List[List[sympy.Expr]]): ...
    def split_and_set_ranges(self, lengths: List[List[sympy.Expr]]):
        """
        We may want to fuse `for i0 in s0*s1` into a tiled kernel with groups (s0, s1).

        To do this we need to split up the iteration space of i0 into something like:
            for i1 in s0:
              for i2 in s1:
                i0 = i1*s1 + i2
                ....

        This function matches and resplits lengths to the groups of
        this kernel to enable tiled + non-tiled fusions.
        """
    def is_indirect_indexing(self, index: sympy.Expr): ...
    def combine_contiguous_dims(self, index: sympy.Expr, tree: IterationRangesRoot):
        """
        More aggressive simplification to merge contiguous dims
        """
    def indexing(self, index: sympy.Expr, *, copy_shape: Incomplete | None = None, dense_indexing: bool = False, override_mask: Incomplete | None = None):
        """
        Compute the index and mask to pass to tl.load() or tl.store()
        """
    def filter_masks(self, mask_vars) -> None: ...
    def var_ranges(self): ...
    def codegen_indexing(self, expr: sympy.Expr): ...
    def mask_loads(self, mask) -> Generator[Incomplete, None, None]:
        """Context manager to add an additional mask to tl.load/store"""
    def load(self, name: str, index: sympy.Expr): ...
    def store(self, name, index, value, mode: Incomplete | None = None) -> None: ...
    def reduction(self, name, dtype, src_dtype, reduction_type, index, value) -> None: ...
    def codegen_body(self) -> None:
        """
        Concat output code from index_code, loads, compute, stores,
        suffix into self.body.

        For pointwise kernels, this is called just once at the end.

        For reduction kernels, this generates a loop over the reduction
        axis.
        """
    def codegen_kernel(self, name: Incomplete | None = None): ...
    def codegen_template_wrapper(self, src_code): ...
    def codegen_static_numels(self, code) -> None:
        """
        We get a small speedup from hard coding numels if they are static.
        """
    def indexing_size_str(self, i: Incomplete | None = None, x: Incomplete | None = None): ...
    def dense_size_str(self): ...
    def call_kernel(self, code, name: str): ...
    def create_cse_var(self, *args, **kwargs): ...

class TritonScheduling:
    scheduler: Incomplete
    def __init__(self, scheduler) -> None: ...
    def group_fn(self, sizes): ...
    def can_fuse(self, node1, node2):
        """
        Hook called by Scheduler to determine if the Triton backend
        can fuse node1 and node2.  These nodes might already be
        FusedSchedulerNodes.
        """
    can_fuse_vertical = can_fuse
    can_fuse_horizontal = can_fuse
    def codegen_nodes(self, nodes):
        """
        Given a set of pre-fused nodes, generate a Triton kernel.
        """
    @staticmethod
    def reduction_hint(node): ...
    def codegen_node_schedule(self, node_schedule, numel, reduction_numel): ...
    def define_kernel(self, src_code, node_schedule): ...
    def codegen_template(self, template_node, epilogue_nodes) -> None:
        """
        Codegen a triton template
        """
    def codegen_sync(self) -> None: ...
    @staticmethod
    def candidate_tilings(node): ...
    @classmethod
    def select_tiling(cls, node_schedule, numel, reduction_numel=...):
        """
        Heuristics to decide how to tile kernels.
        Currently, we tile based on stride-1 dimensions.

        Returns:
            `(tile1, tile2, reduction_numel)` s.t. `tile1 * tile2 == numel`

        """
    def flush(self) -> None: ...

@dataclasses.dataclass
class CandidateTiling:
    tiling: List[sympy.Expr]
    score: int
    name: str = ...
    @staticmethod
    def is_good_size(s):
        """Somewhat arbitrary heuristic used to boost scores for some sizes"""
    def __init__(self, tiling, score, name) -> None: ...

class DisableReduction:
    """
    Marker to invoke `kernel.disable_reduction()`.  This closes a
    reduction loop and allows for pointwise ops to occur on the output
    of a reduction.
    """

class EnableReduction:
    """
    Marker to end a DisableReduction block.
    """
    @staticmethod
    def filter(node_schedule) -> Generator[Incomplete, None, None]:
        """
        Get the nodes from node_schedule skipping those in a
        DisableReduction block.
        """

class CantSplit(Exception): ...
