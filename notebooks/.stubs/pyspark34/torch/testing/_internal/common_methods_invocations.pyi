import enum
import numpy as np
import torch
from _typeshed import Incomplete
from collections.abc import Generator
from torch import inf as inf, nan as nan
from torch.testing import make_tensor as make_tensor
from torch.testing._internal import opinfo as opinfo
from torch.testing._internal.common_cuda import PLATFORM_SUPPORTS_FUSED_SDPA as PLATFORM_SUPPORTS_FUSED_SDPA, SM53OrLater as SM53OrLater, SM60OrLater as SM60OrLater, SM80OrLater as SM80OrLater, TEST_CUDNN as TEST_CUDNN, with_tf32_off as with_tf32_off
from torch.testing._internal.common_device_type import disablecuDNN as disablecuDNN, onlyCPU as onlyCPU, onlyCUDA as onlyCUDA, onlyNativeDeviceTypes as onlyNativeDeviceTypes, precisionOverride as precisionOverride, skipCPUIfNoFFT as skipCPUIfNoFFT, skipCPUIfNoLapack as skipCPUIfNoLapack, skipCPUIfNoMklSparse as skipCPUIfNoMklSparse, skipCUDAIf as skipCUDAIf, skipCUDAIfNoCusolver as skipCUDAIfNoCusolver, skipCUDAIfNoMagma as skipCUDAIfNoMagma, skipCUDAIfNoMagmaAndNoCusolver as skipCUDAIfNoMagmaAndNoCusolver, tol as tol, toleranceOverride as toleranceOverride
from torch.testing._internal.common_dtype import all_types as all_types, all_types_and as all_types_and, all_types_and_complex as all_types_and_complex, all_types_and_complex_and as all_types_and_complex_and, complex_types as complex_types, complex_types_and as complex_types_and, empty_types as empty_types, floating_and_complex_types as floating_and_complex_types, floating_and_complex_types_and as floating_and_complex_types_and, floating_types as floating_types, floating_types_and as floating_types_and, integral_types as integral_types, integral_types_and as integral_types_and
from torch.testing._internal.common_utils import GRADCHECK_NONDET_TOL as GRADCHECK_NONDET_TOL, IS_MACOS as IS_MACOS, IS_WINDOWS as IS_WINDOWS, TEST_SCIPY as TEST_SCIPY, TEST_WITH_ASAN as TEST_WITH_ASAN, TEST_WITH_ROCM as TEST_WITH_ROCM, TEST_WITH_SLOW as TEST_WITH_SLOW, freeze_rng_state as freeze_rng_state, make_fullrank_matrices_with_distinct_singular_values as make_fullrank_matrices_with_distinct_singular_values, slowTest as slowTest, torch_to_numpy_dtype_dict as torch_to_numpy_dtype_dict
from torch.testing._internal.opinfo.core import AliasInfo as AliasInfo, BinaryUfuncInfo as BinaryUfuncInfo, DecorateInfo as DecorateInfo, ErrorInput as ErrorInput, ForeachFuncInfo as ForeachFuncInfo, L as L, M as M, NumericsFilter as NumericsFilter, OpInfo as OpInfo, ReductionOpInfo as ReductionOpInfo, S as S, SampleInput as SampleInput, ShapeFuncInfo as ShapeFuncInfo, SpectralFuncInfo as SpectralFuncInfo, SpectralFuncType as SpectralFuncType, UnaryUfuncInfo as UnaryUfuncInfo, XS as XS, clone_sample as clone_sample, generate_elementwise_binary_arbitrarily_strided_tensors as generate_elementwise_binary_arbitrarily_strided_tensors, generate_elementwise_binary_broadcasting_tensors as generate_elementwise_binary_broadcasting_tensors, generate_elementwise_binary_extremal_value_tensors as generate_elementwise_binary_extremal_value_tensors, generate_elementwise_binary_large_value_tensors as generate_elementwise_binary_large_value_tensors, generate_elementwise_binary_noncontiguous_tensors as generate_elementwise_binary_noncontiguous_tensors, generate_elementwise_binary_small_value_tensors as generate_elementwise_binary_small_value_tensors, generate_elementwise_binary_tensors as generate_elementwise_binary_tensors, generate_elementwise_binary_with_scalar_and_type_promotion_samples as generate_elementwise_binary_with_scalar_and_type_promotion_samples, generate_elementwise_binary_with_scalar_samples as generate_elementwise_binary_with_scalar_samples, generate_elementwise_unary_extremal_value_tensors as generate_elementwise_unary_extremal_value_tensors, generate_elementwise_unary_large_value_tensors as generate_elementwise_unary_large_value_tensors, generate_elementwise_unary_small_value_tensors as generate_elementwise_unary_small_value_tensors, generate_elementwise_unary_tensors as generate_elementwise_unary_tensors, gradcheck_wrapper_hermitian_input as gradcheck_wrapper_hermitian_input, gradcheck_wrapper_masked_operation as gradcheck_wrapper_masked_operation, gradcheck_wrapper_masked_pointwise_operation as gradcheck_wrapper_masked_pointwise_operation, gradcheck_wrapper_triangular_input as gradcheck_wrapper_triangular_input, gradcheck_wrapper_triangular_input_real_positive_diagonal as gradcheck_wrapper_triangular_input_real_positive_diagonal, make_error_inputs_elementwise_binary as make_error_inputs_elementwise_binary, reference_inputs_elementwise_binary as reference_inputs_elementwise_binary, reference_inputs_elementwise_unary as reference_inputs_elementwise_unary, sample_inputs_elementwise_binary as sample_inputs_elementwise_binary, sample_inputs_elementwise_unary as sample_inputs_elementwise_unary, sample_inputs_foreach as sample_inputs_foreach, sample_inputs_reduction as sample_inputs_reduction, sample_inputs_spectral_ops as sample_inputs_spectral_ops
from torch.testing._internal.opinfo.definitions._masked import sample_inputs_softmax_variant as sample_inputs_softmax_variant
from torch.testing._internal.opinfo.definitions.linalg import sample_inputs_cross as sample_inputs_cross, sample_inputs_legacy_solve as sample_inputs_legacy_solve, sample_inputs_linalg_cholesky as sample_inputs_linalg_cholesky, sample_inputs_linalg_cholesky_inverse as sample_inputs_linalg_cholesky_inverse, sample_inputs_linalg_det_logdet_slogdet as sample_inputs_linalg_det_logdet_slogdet, sample_inputs_linalg_invertible as sample_inputs_linalg_invertible, sample_inputs_linalg_lu as sample_inputs_linalg_lu, sample_inputs_linalg_qr_geqrf as sample_inputs_linalg_qr_geqrf, sample_inputs_lu_solve as sample_inputs_lu_solve, sample_inputs_svd as sample_inputs_svd
from torch.testing._internal.opinfo.definitions.special import reference_polygamma as reference_polygamma, sample_inputs_i0_i1 as sample_inputs_i0_i1, sample_inputs_polygamma as sample_inputs_polygamma
from torch.testing._internal.opinfo.refs import ElementwiseBinaryPythonRefInfo as ElementwiseBinaryPythonRefInfo, ElementwiseUnaryPythonRefInfo as ElementwiseUnaryPythonRefInfo, PythonRefInfo as PythonRefInfo, ReductionPythonRefInfo as ReductionPythonRefInfo
from torch.testing._internal.opinfo.utils import np_unary_ufunc_integer_promotion_wrapper as np_unary_ufunc_integer_promotion_wrapper, prod_numpy as prod_numpy, reference_reduction_numpy as reference_reduction_numpy
from torch.utils._pytree import tree_flatten as tree_flatten
from typing import List, Tuple

def close_to_int(x, eps: float = 0.1): ...
def sample_inputs_slice(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_tensor_split(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_hsplit(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_vsplit(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_dsplit(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_hsplit(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_vsplit(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_dsplit(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_as_strided(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_as_strided_partial_views(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_as_strided_scatter(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_as_strided_scatter(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_combinations(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_cartesian_prod(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_cosine_similarity(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_batch_norm(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_softmax_backward_data(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_native_batch_norm(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs__native_batch_norm_legit(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_nn_activation_relu(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_prelu(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def reference_inputs_prelu(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def sample_kwargs_prelu_scalar_weight(device, dtype, input): ...
def error_inputs_prelu(op, device) -> Generator[Incomplete, None, None]: ...
def sample_inputs_norm(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_norm_fro(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_norm_nuc(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_norm_inf(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_equal(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_jiterator(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_broadcast_shapes(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_add_sub(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def error_inputs_arange(op, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_arange(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_randn(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_cauchy(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_cauchy(op, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_exponential(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_exponential(op, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_geometric(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_geometric(op, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_log_normal(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_log_normal(op, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_uniform(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_ones_zeros(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_full(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def error_inputs_uniform(op, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_linspace(op, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_linspace(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_logpace(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_isclose(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def error_inputs_isclose(op, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_t(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_mm(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_addmm(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_sparse_sampled_addmm(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_sparse_mm_reduce(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_mv(self, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_bmm(self, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_dot_vdot(self, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_addmv(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_addbmm(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_addcmul_addcdiv(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def reference_inputs_addcmul_addcdiv(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def sample_inputs_baddbmm(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_multilabel_soft_margin_loss(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_addr(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_zero_(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_multi_margin_loss(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_logsumexp(self, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def reference_inputs_logsumexp(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def sample_inputs_like_fns(self, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def reference_inputs_like_fns(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def sample_inputs_multilabel_margin_loss(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def get_independent_tensor(tensor): ...
def sample_inputs_randint(self, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_randint_like(self, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_margin_ranking_loss(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def reference_inputs_margin_ranking_loss(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def error_inputs_margin_ranking_loss(op, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_new_fns(self, device, dtype, requires_grad, *, is_strided: bool = False, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_empty(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_scalar_tensor(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_eye(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_eye(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_new_full(self, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_full_like(self, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_multinomial(self, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_normal_common(self, device, dtype, requires_grad, cases, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_normal_tensor_first(self, device, dtype, requires_grad, **kwargs): ...
def sample_inputs_normal_tensor_second(self, device, dtype, requires_grad, **kwargs): ...
def sample_inputs_bernoulli(self, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_bernoulli(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_logcumsumexp(self, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_trace(self, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_trace(op, device) -> Generator[Incomplete, None, None]: ...
def sample_inputs_renorm(self, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_transpose_swapdims(self, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_adjoint(self, device, dtype, requires_grad, **kwargs): ...
def sample_inputs_T(self, device, dtype, requires_grad, **kwargs): ...
def error_inputs_T(self, device, has_ndims_error: bool = False) -> Generator[Incomplete, None, None]: ...
def sample_inputs_singular_matrix_factors(op_info, device, dtype, requires_grad: bool = False, **kwargs) -> Generator[Incomplete, None, None]:
    """
    This function produces two tensors of shape (*, m, k) and (*, n, k) with k <= min(m, n).
    Their matrix product could be used to generate tensor of shape (*, m, n) of rank k.
    """
def sample_inputs_svd_lowrank(op_info, device, dtype, requires_grad: bool = False, **kwargs) -> Generator[Incomplete, None, None]: ...
def chunk_iter(iterable, size) -> Generator[Incomplete, None, None]: ...
def sample_inputs_pca_lowrank(op_info, device, dtype, requires_grad: bool = False, **kwargs) -> Generator[Incomplete, None, None]: ...
def np_sinc_with_fp16_as_fp32(x): ...
def sample_inputs_broadcast_to(op_info, device, dtype, requires_grad, **kwargs): ...
def sample_inputs_broadcast_tensors(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def reference_inputs_broadcast_tensors(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def sample_inputs_block_diag(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_cdist(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_fill_(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_comparison_ops(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def sample_inputs_stack(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_cat_concat(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_cat(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def reference_inputs_cat(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def sample_inputs_hstack_dstack_vstack(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_hstack_dstack_vstack(op, device) -> Generator[Incomplete, None, None]: ...
def sample_inputs_unbind(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_unbind(op_info, device) -> Generator[Incomplete, None, None]: ...
def reference_unbind(t, dim):
    """A numpy implementation of torch.unbind"""
def sample_inputs_gather(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_gather(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_take(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_scatter_and_scatter_add(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_renorm(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_ormqr(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_diag(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_embedding(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_t(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_multinomial(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_gradient(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_rrelu(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_masked_select(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_median(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_index_select(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_logcumsumexp(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_take_along_dim(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_aminmax_amax_amin(op_info, device, is_ref: bool = False, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_aminmax(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_diff(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_histogram(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_histogramdd(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_histc(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_bincount(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_bucketize(op_info, device, dtype, requires_grad, reference_inputs_mode: bool = False, **kwargs) -> Generator[Incomplete, None, None]: ...

reference_inputs_bucketize: Incomplete

def sample_inputs_searchsorted(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_gradient(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_getitem(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_index_put(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_sort(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_threshold(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_argsort(*args, **kwargs): ...
def sample_inputs_unique(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_unique_consecutive(*args, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_adaptive_avg_pool1d(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_adaptive_avg_pool1d(opinfo, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_adaptive_avg_pool2d(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_adaptive_avg_pool2d(opinfo, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_adaptive_avg_pool3d(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_adaptive_avg_pool3d(opinfo, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_adaptive_max_pool1d(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_adaptive_max_pool1d(opinfo, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_adaptive_max_pool2d(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_adaptive_max_pool2d(opinfo, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_adaptive_max_pool3d(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_adaptive_max_pool3d(opinfo, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_reduction_sparse(op_info, device, dtype, requires_grad, layout, blocksize: Incomplete | None = None, **kwargs) -> Generator[Incomplete, None, None]: ...

class _TestParamsMaxPoolBase:
    kwargs: Incomplete
    shapes: Incomplete
    def __init__(self) -> None: ...
    def gen_input_params(self) -> Generator[Incomplete, Incomplete, None]: ...

class _TestParamsMaxPool1d(_TestParamsMaxPoolBase):
    def __init__(self) -> None: ...

class _TestParamsMaxPool2d(_TestParamsMaxPoolBase):
    def __init__(self) -> None: ...

class _TestParamsMaxPool3d(_TestParamsMaxPoolBase):
    def __init__(self) -> None: ...

def sample_inputs_max_pool(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def max_pool2d_backward(*args, kernel_size=(), stride=(), padding=(0,), dilation=(1,), ceil_mode: bool = False, **kwargs): ...
def error_inputs_max_pool1d(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_max_pool2d(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_max_pool3d(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_normalize(self, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def complex_conv(fn, input_size, weight, grad_output, stride, padding, dilation, groups): ...
def conv_transpose_ref(input, weight, bias, stride: int = 1, padding: int = 0, output_padding: int = 0, dilation: int = 1, groups: int = 1, fn: Incomplete | None = None): ...
def sample_inputs_conv_transpose1d(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_conv_transpose2d(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_conv_transpose3d(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_conv1d(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_conv1d(opinfo, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_conv2d(opinfo, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_conv2d(op_info, device, dtype, requires_grad, jit_fail_sample: bool = False, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_group_norm(opinfo, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def reference_inputs_group_norm(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def sample_inputs_instance_norm(opinfo, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_layer_norm(opinfo, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_native_layer_norm(opinfo, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_group_norm(opinfo, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_native_layer_norm(opinfo, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_local_response_norm(opinfo, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_hardswish(self, device, dtype, requires_grad, **kwargs): ...
def sample_inputs_linear(self, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_bilinear(self, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_glu(self, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_interpolate(mode, self, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_upsample(mode, self, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_gelu(self, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_gelu(op, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_max_min_reduction_with_dim(op_info, device, dtype, requires_grad, **kwargs): ...
def sample_inputs_max_min_reduction_no_dim(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_nan_reduction(supports_multiple_dims): ...
def sample_inputs_reduction_quantile(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_reduction_count_nonzero(*args, **kwargs) -> Generator[Incomplete, None, None]:
    """Sample inputs for count_nonzero"""
def sample_inputs_leaky_relu(op_info, device, dtype, requires_grad, **kwargs): ...
def sample_inputs_fractional_max_pool2d(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_fractional_max_pool3d(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_avgpool2d(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_avgpool1d(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_avgpool3d(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_avg_pool1d(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_avg_pool2d(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_avg_pool3d(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_to(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_topk(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_outer(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_dist(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_index(op_info, device, dtype, requires_grad, reference: bool = False, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_index_reduce(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_mode(op_info, device, dtype, requires_grad, **kwargs): ...
def sample_inputs_put(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_take(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_movedim_moveaxis(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def reference_movedim_moveaxis(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def error_movedim_moveaxis(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_repeat_tile(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_narrow_narrow_copy(op_info, device, dtype, requires_grad, *, is_narrow, **kwargs) -> Generator[Incomplete, None, None]: ...
def reference_inputs_narrow_narrow_copy(op_info, device, dtype, requires_grad, *, is_narrow, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def error_inputs_narrow_narrow_copy(op_info, device, *, is_narrow, is_ref) -> Generator[Incomplete, None, None]: ...
def sample_trapezoid(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_cumulative_trapezoid(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_unsqueeze(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_nn_unfold(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_squeeze(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_squeeze_multiple(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_nn_pad(op_info, device, dtype, requires_grad, mode, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_constant_pad_nd(op_info, device, dtype, *args, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_repeat_interleave(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_stft(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_istft(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_ormqr(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_cholesky_solve(op_info, device, dtype, requires_grad: bool = False, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_lu(op_info, device, dtype, requires_grad: bool = False, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_lu_unpack(op_info, device, dtype, requires_grad: bool = False, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_roll(op_info, device, dtype, requires_grad: bool = False, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_roll(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_rot90(op_info, device, dtype, requires_grad: bool = False, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_rot90(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_std_var(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_std_var_unbiased(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_corrcoef(op_info, device, dtype, requires_grad, **kwargs): ...
def sample_inputs_cov(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_cov(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_permute(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def reference_inputs_permute(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def error_inputs_softshrink(op, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_softshrink(op_info, device, dtype, requires_grad: bool = False, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def sample_inputs_hardshrink(op_info, device, dtype, requires_grad: bool = False, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def sample_inputs_hardtanh(op_info, device, dtype, requires_grad: bool = False, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def sample_inputs_einsum(op_info, device, dtype, requires_grad: bool = False, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_flip(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_fliplr_flipud(op_info, device, dtype, requires_grad, **kwargs): ...
def error_inputs_fliplr(op, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_flipud(op, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_clamp(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def reference_inputs_elementwise_ternary(op, device, dtype, requires_grad, *, sample_inputs_func, supports_scalars: bool = False, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def sample_inputs_cumprod(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_view_as_complex(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_view_as_real(op_info, device, dtype, requires_grad, **kwargs): ...
def error_inputs_complex(op_info, device, is_ref: bool = False, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_logaddexp(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_prod(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def error_inputs_neg(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_diag(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_diagonal_diag_embed(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def reference_inputs_diagonal_diag_embed(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def error_inputs_diagonal_diag_embed(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_diagonal_scatter(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_to_sparse(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_cross_entropy(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_logit(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_isin(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_masked_scatter(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_masked_fill(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_masked_fill(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_masked_select(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_matrix_exp(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_matmul(op_info, device, dtype, requires_grad, is_rmatmul: bool = False, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_meshgrid(op_info: OpInfo, device: torch.device, dtype: torch.dtype, requires_grad: bool, *, variant: str, **kwargs) -> List[SampleInput]: ...
def sample_inputs_mvlgamma(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def skips_mvlgamma(skip_redundant: bool = False): ...
def make_mvlgamma_opinfo(variant_test_name, domain, skips, sample_kwargs): ...
def sample_inputs_cumulative_ops(op_info, device, dtype, requires_grad, supports_dtype_kwargs: bool = True, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_unfold(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_split(op_info, device, dtype, requires_grad, *, list_args: bool = False, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_split_with_sizes(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_msort(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_lerp(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_tensordot(self, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_kron(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_inner(self, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_scatter(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_scatter_add(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_scatter_reduce(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_segment_reduce(op_info, device, dtype, requires_grad, *, mode: str = 'lengths', **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_ravel(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_tril_triu(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_tril_triu(opinfo, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_trilu_indices(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_clone_contiguous(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def reference_inputs_clone_contiguous(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def sample_inputs_sum_to_size(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_sum_to_size(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_resize_ops(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_view_reshape(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def reference_inputs_view_reshape(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def error_inputs_view_reshape(op, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_atleast1d2d3d(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_column_stack(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_flatten(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def reference_inputs_flatten(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def sample_inputs_unflatten(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_select(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_select_scatter(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_slice_scatter(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_expand(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_conversion(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_expand_as(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_where(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def reference_inputs_where(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def error_inputs_where(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_nonzero(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_chunk(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def reference_inputs_chunk(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def sample_inputs_kthvalue(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, Incomplete]: ...
def error_inputs_kthvalue(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_dropout(op_info, device, dtype, requires_grad, *, train: Incomplete | None = None, valid_input_dim: Incomplete | None = None, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_dropout_backward(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_embedding_bag(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_embedding(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_one_hot(op_info, device, dtype, requires_grad, **kwargs): ...
def sample_inputs_loss(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_grid_sample(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_grid_sampler_2d(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_cosine_embedding_loss(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_ctc_loss(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_nll_loss(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_binary_cross_entropy_with_logits(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_argwhere(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_gaussian_nll_loss(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_gaussian_nll_loss(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_hinge_embedding_loss(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_hinge_embedding_loss(op, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def reference_inputs_hinge_embedding_loss(op, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def sample_inputs_huber_loss(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_huber_loss(op, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_poisson_nll_loss(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_poisson_nll_loss(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_soft_margin_loss(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_triplet_margin_loss(op_info, device, dtype, requires_grad, with_distance: bool = False, **kwargs) -> Generator[Incomplete, None, None]: ...
def error_inputs_triplet_margin_loss(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_scaled_dot_product_attention(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def sample_inputs_pairwise_distance(op_info, device, dtype, requires_grad, **kwargs): ...
def sample_inputs_pixel_shuffle(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def sample_inputs_pixel_unshuffle(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def sample_inputs_binary_cross_entropy(op_info, device, dtype, requires_grad, logits: bool = False, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_allclose(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_l1_loss(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def error_inputs_l1_loss(op_info, device, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_smooth_l1_loss(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def sample_inputs_kl_div(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, Incomplete]: ...
def sample_inputs_pdist(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, Incomplete, None]: ...
def reference_pdist(input, p: int = 2): ...
def sample_inputs_diagflat(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_max_unpool(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...
def sample_inputs_max_unpool_grad(op_info, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...

foreach_num_tensors: Incomplete

class ForeachRightmostArgType(enum.Enum):
    TensorList: int
    ScalarList: int
    Scalar: int

foreach_scalars: Incomplete

class foreach_inputs_sample_func:
    arity: Incomplete
    def __init__(self, arity: int, rightmost_supports_scalar: bool, rightmost_supports_scalarlist: bool) -> None: ...
    def __call__(self, opinfo, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...

class foreach_norm_sample_func(foreach_inputs_sample_func):
    def __call__(self, opinfo, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...

class foreach_lerp_sample_func(foreach_inputs_sample_func): ...

class foreach_pointwise_sample_func(foreach_inputs_sample_func):
    def __init__(self, arity: int = 3, rightmost_supports_scalar: bool = False, rightmost_supports_scalarlist: bool = False) -> None: ...
    def __call__(self, opinfo, device, dtype, requires_grad, **kwargs) -> Generator[Incomplete, None, None]: ...

foreach_unary_op_db: List[OpInfo]
foreach_binary_op_db: List[OpInfo]
foreach_pointwise_op_db: List[ForeachFuncInfo]
foreach_reduce_op_db: List[ForeachFuncInfo]
foreach_lerp_op_db: List[ForeachFuncInfo]

def reference_sign(x): ...
def reference_sgn(x): ...
def reference_sigmoid(x): ...
def reference_logsigmoid(x): ...
def reference_hardsigmoid(x): ...
def reference_lgamma(x): ...
def reference_mvlgamma(x, d): ...
def reference_softplus(input, beta: int = 1, threshold: int = 20): ...
def reference_gelu(X, *, approximate: str = 'none'): ...
def reference_one_hot(a: np.ndarray, num_classes: int = -1) -> np.ndarray: ...
def reference_mse_loss(input, target, reduction: str = 'mean'): ...
def wrapper_set_seed(op, *args, **kwargs):
    """Wrapper to set seed manually for some functions like dropout
    See: https://github.com/pytorch/pytorch/pull/62315#issuecomment-896143189 for more details.
    """
def reference_layer_norm(inp: np.ndarray, normalized_shape: Tuple[int], weight: Incomplete | None = None, bias: Incomplete | None = None, eps: float = 1e-05): ...
def reference_native_layer_norm(inp: np.ndarray, normalized_shape: Tuple[int], weight, bias, eps): ...
def reference_group_norm(inp: np.ndarray, num_groups: int, weight: Incomplete | None = None, bias: Incomplete | None = None, eps: float = 1e-05): ...
def reference_searchsorted(sorted_sequence, boundary, out_int32: bool = False, right: bool = False, side: str = 'left', sorter: Incomplete | None = None): ...
def loss_reference_reduction_wrapper(fn): ...
def reference_smooth_l1_loss(input, target, beta: float = 1.0): ...
def reference_std_var(f):
    """Forwards unbiased/correction kwargs as NumPy's equivalent ddof"""
def generate_std_var_kwargs(t: torch.Tensor, **kwargs):
    """Generates unbiased/correction kwargs for std/var operators"""
def error_inputs_mean(op_info, device, is_ref: bool = False, **kwargs) -> Generator[Incomplete, None, None]: ...
def reference_flatten(input, start_dim: int = 0, end_dim: int = -1): ...

op_db: List[OpInfo]
python_ref_db: Incomplete
ops_and_refs: Incomplete
unary_ufuncs: Incomplete
binary_ufuncs: Incomplete
binary_ufuncs_and_refs: Incomplete
spectral_funcs: Incomplete
sparse_unary_ufuncs: Incomplete
sparse_csr_unary_ufuncs: Incomplete
sparse_reduction_ops: Incomplete
shape_funcs: Incomplete
reduction_ops: Incomplete
reference_filtered_ops: Incomplete
reference_masked_ops: Incomplete
sparse_masked_reduction_ops: Incomplete

def index_variable(shape, max_indices, device=...): ...
def gather_variable(shape, index_dim, max_indices, duplicate: bool = False, device=...): ...
def bernoulli_scalar(): ...
def mask_not_all_zeros(shape): ...
