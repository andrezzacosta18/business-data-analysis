from _typeshed import Incomplete
from torch._C import TensorType as TensorType
from torch.testing._internal.common_dtype import floating_and_complex_types_and as floating_and_complex_types_and
from torch.testing._internal.common_utils import TemporaryFileName as TemporaryFileName, TestCase as TestCase, enable_profiling_mode as enable_profiling_mode, enable_profiling_mode_for_profiling_tests as enable_profiling_mode_for_profiling_tests, freeze_rng_state as freeze_rng_state, is_iterable_of_tensors as is_iterable_of_tensors
from typing import List

def check_output_types(self, func, ref_outputs, args, kwargs) -> None: ...

nn_functional_single_grad: Incomplete

def check_against_reference(self, func, reference_func, output_func, args, kwargs: Incomplete | None = None, allow_unused: bool = True, check_types: bool = True, no_grad: bool = False, no_gradgrad: bool = False):
    """Verifies a function performs identically to some reference implementation.

    Commonly, this is used to verify that a JIT implementation
    (output_func) matches the behavior of the eager implementation
    (reference_func).
    """

class JitCommonTestCase(TestCase):
    def createFunctionFromGraph(self, trace): ...
    def assertExportImport(self, trace, inputs) -> None: ...
    def assertExportImportModule(self, m, inputs) -> None: ...
    def runAndSaveRNG(self, func, inputs, kwargs: Incomplete | None = None): ...
    def getExportImportCopy(self, m, also_test_file: bool = True, map_location: Incomplete | None = None): ...
    def autoDiffErrorMessage(self, should_autodiff_node, nodes_not_in_diff_graph, fusion_nodes_not_found, non_fusible_nodes_being_fused, fusion_nodes_found, nodes_in_diff_graph): ...
    def assertAutodiffNode(self, graph, should_autodiff_node, nonfusible_nodes, fusible_nodes) -> None: ...
    def checkShapeAnalysis(self, out_sizes: List[int] | List[List[int]], traced_graph, assert_propagation, constant_prop: bool = True): ...
