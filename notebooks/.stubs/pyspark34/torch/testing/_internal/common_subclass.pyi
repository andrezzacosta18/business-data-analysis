import torch
from _typeshed import Incomplete
from torch.testing._internal.logging_tensor import LoggingTensor as LoggingTensor
from torch.utils._pytree import tree_map as tree_map

class WrapperTensor(torch.Tensor):
    @staticmethod
    def __new__(cls, *args, **kwargs): ...
    @classmethod
    def get_wrapper_properties(cls, *args, **kwargs) -> None: ...

class DiagTensorBelow(WrapperTensor):
    @classmethod
    def get_wrapper_properties(cls, diag, requires_grad: bool = False): ...
    diag: Incomplete
    def __init__(self, diag, requires_grad: bool = False) -> None: ...
    handled_ops: Incomplete
    __torch_function__: Incomplete
    @classmethod
    def __torch_dispatch__(cls, func, types, args=(), kwargs: Incomplete | None = None): ...

class SparseTensor(WrapperTensor):
    @classmethod
    def get_wrapper_properties(cls, size, values, indices, requires_grad: bool = False): ...
    values: Incomplete
    indices: Incomplete
    def __init__(self, size, values, indices, requires_grad: bool = False) -> None: ...
    def sparse_to_dense(self): ...
    @staticmethod
    def from_dense(t): ...
    @classmethod
    def __torch_dispatch__(cls, func, types, args=(), kwargs: Incomplete | None = None): ...
    def __rmul__(self, other): ...

class NonWrapperTensor(torch.Tensor):
    def __new__(cls, data): ...
    @classmethod
    def __torch_function__(cls, func, types, args=(), kwargs: Incomplete | None = None): ...
    def new_empty(self, shape): ...

class SubclassInfo:
    name: Incomplete
    create_fn: Incomplete
    closed_under_ops: Incomplete
    def __init__(self, name, create_fn, closed_under_ops: bool = True) -> None: ...

subclass_db: Incomplete
