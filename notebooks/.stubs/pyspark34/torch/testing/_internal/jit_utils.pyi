from _typeshed import Incomplete
from collections.abc import Generator
from torch.autograd import Variable as Variable
from torch.jit.annotations import BroadcastingList2 as BroadcastingList2, BroadcastingList3 as BroadcastingList3
from torch.onnx import OperatorExportTypes as OperatorExportTypes
from torch.testing import FileCheck as FileCheck
from torch.testing._internal.common_jit import JitCommonTestCase as JitCommonTestCase
from torch.testing._internal.common_utils import IS_WINDOWS as IS_WINDOWS, ProfilingMode as ProfilingMode, TEST_BAILOUTS as TEST_BAILOUTS, enable_profiling_mode as enable_profiling_mode, enable_profiling_mode_for_profiling_tests as enable_profiling_mode_for_profiling_tests, freeze_rng_state as freeze_rng_state, is_iterable_of_tensors as is_iterable_of_tensors

RUN_CUDA: Incomplete
RUN_CUDA_MULTI_GPU: Incomplete
RUN_CUDA_HALF = RUN_CUDA
CUDA_VERSION: Incomplete
major: Incomplete

def execWrapper(code, glob, loc) -> None: ...
def do_input_map(fn, input): ...
def clear_class_registry() -> None: ...
def get_execution_plan(graph_executor_state): ...

class _AssertRaisesRegexWithHighlightContext:
    """
    A context manager that is useful for checking that error messages highlight
    the correct part of the source code.
    """
    test_case: Incomplete
    exception_type: Incomplete
    regex: Incomplete
    highlight: Incomplete
    def __init__(self, test_case, exception, regex, highlight) -> None: ...
    def __enter__(self): ...
    def __exit__(self, type: type[BaseException] | None, value: BaseException | None, traceback: types.TracebackType | None): ...

FUSION_GROUP: str

class JitTestCase(JitCommonTestCase):
    class capture_stdout(list):
        """
        Replace sys.stdout with a temporary StringIO
        """
        sys_stdout: Incomplete
        stringio: Incomplete
        def __enter__(self): ...
        def __exit__(self, *args) -> None: ...
    class capture_stderr(list):
        """
        Replace sys.stderr with a temporary StringIO
        """
        sys_stderr: Incomplete
        stringio: Incomplete
        def __enter__(self): ...
        def __exit__(self, *args) -> None: ...
    def setHooks(self) -> None: ...
    def clearHooks(self) -> None: ...
    def setUp(self) -> None: ...
    def tearDown(self) -> None: ...
    def assertAllFused(self, graph, except_for=()) -> None: ...
    def emitFunctionHook(self, func) -> None: ...
    def emitModuleHook(self, module) -> None: ...
    def getExportImportCopyWithPacking(self, m, also_test_file: bool = True, map_location: Incomplete | None = None): ...
    def assertGraphContains(self, graph, kind, consider_subgraphs: bool = False): ...
    def assertGraphContainsExactly(self, graph, kind, num_kind_nodes, consider_subgraphs: bool = False): ...
    def assertExpectedONNXGraph(self, g, *args, **kwargs) -> None: ...
    def assertExpectedGraph(self, trace, *args, **kwargs) -> None: ...
    def run_pass(self, name, trace): ...
    def get_frame_vars(self, frames_up): ...
    def assertRaisesRegexWithHighlight(self, exception, regex, highlight): ...
    def checkScriptRaisesRegex(self, script, inputs, exception, regex, name: Incomplete | None = None, outputs: Incomplete | None = None, capture_output: bool = False, frames_up: int = 1, profiling=...) -> None:
        """
        Checks that a given function will throw the correct exception,
        when executed with normal python, the string frontend, and the
        AST frontend. Logic taken from `checkScript` (see comments there
        for details)
        """
    def checkBailouts(self, model, inputs, expected) -> None: ...
    def checkScript(self, script, inputs, name: str = 'func', optimize: bool = True, inputs_requires_grad: bool = False, capture_output: bool = False, frames_up: int = 1, profiling=..., atol: Incomplete | None = None, rtol: Incomplete | None = None):
        """
        Checks that a given script generates the same output as the Python
        version using the given inputs.
        """
    def checkTrace(self, func, reference_tensors, input_tensors: Incomplete | None = None, drop: Incomplete | None = None, allow_unused: bool = False, verbose: bool = False, inputs_require_grads: bool = True, check_tolerance: float = 1e-05, export_import: bool = True, _force_outplace: bool = False): ...
    def checkModule(self, nn_module, args):
        """
        Check that a nn.Module's results in Script mode match eager and that it
        can be exported
        """

class NoTracerWarnContextManager:
    prev: Incomplete
    def __enter__(self) -> None: ...
    def __exit__(self, *args) -> None: ...

def inline_everything_mode(should_inline) -> Generator[None, None, None]: ...
def set_fusion_group_inlining(inlining) -> Generator[None, None, None]: ...
def disable_autodiff_subgraph_inlining(enabled: bool = True) -> Generator[None, None, None]: ...
def enable_cpu_fuser(fn): ...
def enable_cpu_fuser_if(cond): ...
def get_forward(c): ...
def get_forward_graph(c): ...
def get_module_method(m, module, method): ...
def attrs_with_prefix(module, prefix): ...
def warmup_backward(f, *args): ...
def make_global(*args) -> None: ...

class TensorExprTestOptions:
    old_profiling_executor: Incomplete
    old_profiling_mode: Incomplete
    old_cpu_fuser_state: Incomplete
    old_gpu_fuser_state: Incomplete
    texpr_fuser_state: Incomplete
    old_fusion_inlining: Incomplete
    old_te_must_use_llvm_cpu: Incomplete
    old_nvfuser: Incomplete
    def __init__(self) -> None: ...
    def restore(self) -> None: ...

def clone_inputs(args): ...
def get_traced_sample_variant_pairs(device, dtype, op): ...
def is_lambda(lamb): ...
