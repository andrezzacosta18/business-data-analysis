import torch
from _typeshed import Incomplete
from enum import Enum
from torch.testing._internal.common_cuda import TEST_CUSPARSE_GENERIC as TEST_CUSPARSE_GENERIC, TEST_HIPSPARSE_GENERIC as TEST_HIPSPARSE_GENERIC
from torch.testing._internal.common_dtype import get_all_dtypes as get_all_dtypes
from torch.testing._internal.common_utils import IS_FBCODE as IS_FBCODE, IS_REMOTE_GPU as IS_REMOTE_GPU, IS_SANDCASTLE as IS_SANDCASTLE, IS_WINDOWS as IS_WINDOWS, NATIVE_DEVICES as NATIVE_DEVICES, TEST_MKL as TEST_MKL, TEST_WITH_ASAN as TEST_WITH_ASAN, TEST_WITH_ROCM as TEST_WITH_ROCM, TEST_WITH_TSAN as TEST_WITH_TSAN, TEST_WITH_UBSAN as TEST_WITH_UBSAN, TestCase as TestCase, _TestParametrizer, compose_parametrize_fns as compose_parametrize_fns, dtype_name as dtype_name, skipCUDANonDefaultStreamIf as skipCUDANonDefaultStreamIf, skipIfTorchDynamo as skipIfTorchDynamo
from typing import Any, ClassVar, List, NamedTuple, Sequence, Tuple

HAS_PSUTIL: bool

class DeviceTypeTestBase(TestCase):
    device_type: str
    @property
    def precision(self): ...
    @precision.setter
    def precision(self, prec) -> None: ...
    @property
    def rel_tol(self): ...
    @rel_tol.setter
    def rel_tol(self, prec) -> None: ...
    @classmethod
    def get_primary_device(cls): ...
    @classmethod
    def get_all_devices(cls): ...
    @classmethod
    def instantiate_test(cls, name, test, *, generic_cls: Incomplete | None = None): ...
    def run(self, result: Incomplete | None = None) -> None: ...

class CPUTestBase(DeviceTypeTestBase):
    device_type: str

class CUDATestBase(DeviceTypeTestBase):
    device_type: str
    primary_device: ClassVar[str]
    cudnn_version: ClassVar[Any]
    no_magma: ClassVar[bool]
    no_cudnn: ClassVar[bool]
    def has_cudnn(self): ...
    @classmethod
    def get_primary_device(cls): ...
    @classmethod
    def get_all_devices(cls): ...
    @classmethod
    def setUpClass(cls) -> None: ...

lazy_ts_backend_init: bool

class LazyTestBase(DeviceTypeTestBase):
    device_type: str
    @classmethod
    def setUpClass(cls) -> None: ...

class MPSTestBase(DeviceTypeTestBase):
    device_type: str

def get_device_type_test_bases(): ...

device_type_test_bases: Incomplete

def filter_desired_device_types(device_type_test_bases, except_for: Incomplete | None = None, only_for: Incomplete | None = None): ...

mod: Incomplete
PYTORCH_CUDA_MEMCHECK: Incomplete
PYTORCH_TESTING_DEVICE_ONLY_FOR_KEY: str
PYTORCH_TESTING_DEVICE_EXCEPT_FOR_KEY: str

def instantiate_device_type_tests(generic_test_class, scope, except_for: Incomplete | None = None, only_for: Incomplete | None = None, include_lazy: bool = False, allow_mps: bool = False): ...

class OpDTypes(Enum):
    supported: int
    unsupported: int
    supported_backward: int
    unsupported_backward: int
    any_one: int
    none: int
    any_common_cpu_cuda_one: int

ANY_DTYPE_ORDER: Incomplete

class ops(_TestParametrizer):
    op_list: Incomplete
    opinfo_dtypes: Incomplete
    allowed_dtypes: Incomplete
    def __init__(self, op_list, *, dtypes: OpDTypes | Sequence[torch.dtype] = ..., allowed_dtypes: Sequence[torch.dtype] | None = None) -> None: ...

class skipIf:
    dep: Incomplete
    reason: Incomplete
    device_type: Incomplete
    def __init__(self, dep, reason, device_type: Incomplete | None = None) -> None: ...
    def __call__(self, fn): ...

class skipCPUIf(skipIf):
    def __init__(self, dep, reason) -> None: ...

class skipCUDAIf(skipIf):
    def __init__(self, dep, reason) -> None: ...

class skipMetaIf(skipIf):
    def __init__(self, dep, reason) -> None: ...

class skipXLAIf(skipIf):
    def __init__(self, dep, reason) -> None: ...

def largeTensorTest(size, device: Incomplete | None = None):
    '''Skip test if the device has insufficient memory to run the test

    size may be a number of bytes, a string of the form "N GB", or a callable

    If the test is a device generic test, available memory on the primary device will be checked.
    It can also be overriden by the optional `device=` argument.
    In other tests, the `device=` argument needs to be specified.
    '''

class expectedFailure:
    device_type: Incomplete
    def __init__(self, device_type) -> None: ...
    def __call__(self, fn): ...

class onlyOn:
    device_type: Incomplete
    def __init__(self, device_type) -> None: ...
    def __call__(self, fn): ...

class deviceCountAtLeast:
    num_required_devices: Incomplete
    def __init__(self, num_required_devices) -> None: ...
    def __call__(self, fn): ...

def onlyNativeDeviceTypes(fn): ...

class precisionOverride:
    d: Incomplete
    def __init__(self, d) -> None: ...
    def __call__(self, fn): ...

class tol(NamedTuple):
    atol: Incomplete
    rtol: Incomplete

class toleranceOverride:
    d: Incomplete
    def __init__(self, d) -> None: ...
    def __call__(self, fn): ...

class dtypes:
    args: Incomplete
    device_type: Incomplete
    def __init__(self, *args, device_type: str = 'all') -> None: ...
    def __call__(self, fn): ...

class dtypesIfCPU(dtypes):
    def __init__(self, *args) -> None: ...

class dtypesIfCUDA(dtypes):
    def __init__(self, *args) -> None: ...

class dtypesIfMPS(dtypes):
    def __init__(self, *args) -> None: ...

def onlyCPU(fn): ...
def onlyCUDA(fn): ...
def onlyMPS(fn): ...
def disablecuDNN(fn): ...
def disableMkldnn(fn): ...
def expectedFailureCUDA(fn): ...
def expectedFailureMeta(fn): ...
def expectedFailureXLA(fn): ...
def skipCPUIfNoLapack(fn): ...
def skipCPUIfNoFFT(fn): ...
def skipCPUIfNoMkl(fn): ...
def skipCPUIfNoMklSparse(fn): ...
def skipCPUIfNoMkldnn(fn): ...
def skipCUDAIfNoMagma(fn): ...
def has_cusolver(): ...
def skipCUDAIfNoCusolver(fn): ...
def skipCUDAIfNoMagmaAndNoCusolver(fn): ...
def skipCUDAIfRocm(fn): ...
def skipCUDAIfNotRocm(fn): ...
def skipCUDAIfRocmVersionLessThan(version: Incomplete | None = None): ...
def skipCUDAVersionIn(versions: List[Tuple[int, int]] = None): ...
def skipCUDAIfCudnnVersionLessThan(version: int = 0): ...
def skipCUDAIfNoCusparseGeneric(fn): ...
def skipCUDAIfNoHipsparseGeneric(fn): ...
def skipCUDAIfNoSparseGeneric(fn): ...
def skipCUDAIfNoCudnn(fn): ...
def skipCUDAIfMiopen(fn): ...
def skipCUDAIfNoMiopen(fn): ...
def skipMeta(fn): ...
def skipXLA(fn): ...
def get_all_device_types() -> List[str]: ...
